[
  {
    "objectID": "exercises/02-booting/05-ex-week3.html",
    "href": "exercises/02-booting/05-ex-week3.html",
    "title": "Desxifrat automàtic mitjançant clau en disc secundari (USB emulat)",
    "section": "",
    "text": "Aprendre a personalitzar la initramfs per buscar una clau en un disc secundari (emulant un USB).\nDesxifrar automàticament una partició LUKS durant l’arrencada amb una keyfile.\nEntendre els hooks i scripts d’initramfs-tools i com incloure binaris (cryptsetup) a la imatge.",
    "crumbs": [
      "Activitats",
      "Unitat 02 · Arrencada del sistema",
      "Activitat 5 · Arrencada automàtica d'una partició LUKS amb clau en un disc secundari"
    ]
  },
  {
    "objectID": "exercises/02-booting/05-ex-week3.html#objectius",
    "href": "exercises/02-booting/05-ex-week3.html#objectius",
    "title": "Desxifrat automàtic mitjançant clau en disc secundari (USB emulat)",
    "section": "",
    "text": "Aprendre a personalitzar la initramfs per buscar una clau en un disc secundari (emulant un USB).\nDesxifrar automàticament una partició LUKS durant l’arrencada amb una keyfile.\nEntendre els hooks i scripts d’initramfs-tools i com incloure binaris (cryptsetup) a la imatge.",
    "crumbs": [
      "Activitats",
      "Unitat 02 · Arrencada del sistema",
      "Activitat 5 · Arrencada automàtica d'una partició LUKS amb clau en un disc secundari"
    ]
  },
  {
    "objectID": "exercises/02-booting/05-ex-week3.html#requeriments-previs",
    "href": "exercises/02-booting/05-ex-week3.html#requeriments-previs",
    "title": "Desxifrat automàtic mitjançant clau en disc secundari (USB emulat)",
    "section": "Requeriments Previs",
    "text": "Requeriments Previs\n\nTenir una màquina virtual (MV) amb Debian instal·lat, aquesta màquina virtual s’ha d’haver creat seleccionat l’opció de LVM xifrat durant la instal·lació.\nAfegeix un disc secundari a la màquina virtual que simularà un USB de 4GB i de tipus SATA.\nTotes les comandes s’han d’executar amb permisos de superusuari (root). Per tant, su -.\nRealitzar un apt update -y && apt upgrade -y per assegurar-se que el sistema està actualitzat.\nInstal·lar el paquet apt install parted vim -y per gestionar particions.",
    "crumbs": [
      "Activitats",
      "Unitat 02 · Arrencada del sistema",
      "Activitat 5 · Arrencada automàtica d'una partició LUKS amb clau en un disc secundari"
    ]
  },
  {
    "objectID": "exercises/02-booting/05-ex-week3.html#passos",
    "href": "exercises/02-booting/05-ex-week3.html#passos",
    "title": "Desxifrat automàtic mitjançant clau en disc secundari (USB emulat)",
    "section": "Passos",
    "text": "Passos\n\nCreació del disc secundari amb la clau\nPrimer, cal crear un disc secundari que simuli un USB. Això es pot fer afegint un nou disc a la màquina virtual. En aquest exemple, suposarem que el nou disc és /dev/sda. Si el teu disc és diferent, substitueix /dev/sda pel nom correcte. Per obtenir el nom del nou disc, pots utilitzar la comanda lsblk o df -h.\nparted --script /dev/sda mklabel msdos\nparted --script /dev/sda mkpart primary ext4 1MiB 100%\nmkfs.ext4 -L KEYDISK /dev/sda1\nAquestes comandes creen una taula de particions MBR i una partició primària que ocupa tot l’espai del disc, formatada amb el sistema de fitxers ext4 i amb l’etiqueta KEYDISK.\n\n\nMuntar el disc i crear la clau\nPrimer crearem un punt de muntatge i muntarem la partició del disc secundari. Després, generarem un fitxer de clau amb dades aleatòries i li assignarem permisos restrictius per garantir la seva seguretat.\nmkdir -p /tmp/keydisk\nmount /dev/sda1 /tmp/keydisk\ndd if=/dev/urandom of=/tmp/keydisk/keyfile.bin bs=4096 count=1\nchmod 0400 /tmp/keydisk/keyfile.bin\n\n\nAfegir la clau a la partició LUKS\nAfegirem el fitxer de clau a la partició LUKS que conté la partició arrel. En aquest exemple, suposarem que la partició LUKS és /dev/nvme0n1p3. Si el teu dispositiu és diferent, substitueix /dev/nvme0n1p3 pel nom correcte.\ncryptsetup luksDump /dev/nvme0n1p3\ncryptsetup luksAddKey /dev/nvme0n1p3 /tmp/keydisk/keyfile.bin\nEn aquest punt, se’t demanarà introduïr una passphrase existent per autoritzar l’afegiment de la nova clau, entra la passphrase i comprova que la clau s’ha afegit correctament amb:\ncryptsetup luksDump /dev/nvme0n1p3\nAra veuras una línia addicional a Key Slot. Indicant que la clau s’ha afegit correctament.",
    "crumbs": [
      "Activitats",
      "Unitat 02 · Arrencada del sistema",
      "Activitat 5 · Arrencada automàtica d'una partició LUKS amb clau en un disc secundari"
    ]
  },
  {
    "objectID": "exercises/02-booting/05-ex-week3.html#edita-el-fitxer-etccrypttab",
    "href": "exercises/02-booting/05-ex-week3.html#edita-el-fitxer-etccrypttab",
    "title": "Desxifrat automàtic mitjançant clau en disc secundari (USB emulat)",
    "section": "Edita el fitxer /etc/crypttab",
    "text": "Edita el fitxer /etc/crypttab\nAquest fitxer s’utilitza per definir les particions xifrades que s’han de desxifrar durant l’arrencada. Edita el fitxer /etc/crypttab i afegeix la a entre el UUID de la partició LUKS i les opcions, la ruta al fitxer de clau que hem creat anteriorment. Per fer-ho, elimineu none i afegiu la ruta al fitxer de clau.\n# /etc/crypttab\nnvme0n1p3_crypt UUID=XXXXXXXXX /tmp/keydisk/keyfile.bin  luks,discard\nIndicarem que la keyfile es troba a /tmp/keydisk/keyfile.bin, ja que en la initramfs muntarem el disc secundari a /tmp/keydisk i llegirem la clau des d’allà.\n\nCrear l’script per muntar el disc i llegir la clau\nCrearem un script que s’executarà durant l’arrencada per muntar el disc secundari, llegir la clau i desxifrar la partició LUKS. Aquest script es col·locarà a /etc/initramfs-tools/scripts/local-top/ i s’anomenarà mount_disk.\n#!/bin/sh\n### BEGIN INIT INFO\n# Provides:          mount_disk\n# Required-Start:    $local_fs\n# Required-Stop:\n# Default-Start:     S\n# Default-Stop:\n# Short-Description: Unlock LUKS root using a keyfile on a secondary disk\n# Description:       Finds and mounts a secondary disk\n### END INIT INFO\n\nlog_msg() {\n    echo \"mount_disk: $1\" &gt; /dev/kmsg\n}\n\nKEYDISK_UUID=\"XXXXXX\" # &lt;-- Substitueix amb el teu UUID corresponent al disc secundari\nKEYFILE_PATH=\"/keyfile.bin\"\n\nlog_msg \"Iniciant desxifrat automàtic amb keyfile.\"\n\nMNT_POINT=\"/tmp/keydisk\"\nmkdir -p \"$MNT_POINT\"\n\nDEV=$(blkid -U \"$KEYDISK_UUID\")\nif [ -n \"$DEV\" ]; then\n    log_msg \"Dispositiu trobat a $DEV. Muntant...\"\n    mount -t ext4 \"$DEV\" \"$MNT_POINT\"\n    if [ $? -ne 0 ]; then\n        log_msg \"ERROR: No s'ha pogut muntar $DEV.\"\n        exit 0\n    fi\nelse\n    log_msg \"ERROR: No s'ha trobat cap dispositiu amb l'UUID especificat.\"\n    exit 0\nfi\n\n# Comprovar si el keyfile existeix\nif [ -f \"$MNT_POINT/$KEYFILE_PATH\" ]; then\n    log_msg \"Keyfile trobat. Desxifrant LUKS...\"\nelse\n    log_msg \"ERROR: No s'ha trobat el keyfile.\"\nfi\n\nexit 0\nGuarda aquest script com a /etc/initramfs-tools/scripts/local-top/mount_disk i fes-lo executable:\nchmod +x /etc/initramfs-tools/scripts/local-top/mount_disk\n\n\nConfiigurar cryptsetup per a la initramfs\ncryptsetup ja esta inclòs en la initramfs per defecte, però cal assegurar-se que està configurat per utilitzar el fitxer de clau des del disc secundari. Edita el fitxer /etc/cryptsetup-initramfs/conf-hook i afegeix la següent línia que permet que no es demani la contrasenya si es troba el fitxer de clau:\n#  /etc/cryptsetup-initramfs/conf-hook\nASKPASS=n\n\n\nIncloure el fitxer /etc/crypttab a la initramfs\nPer assegurar que el fitxer /etc/crypttab es troba disponible durant l’arrencada, cal crear un script que el copiï a la initramfs. Crearem un script anomenat copy-crypttab a /etc/initramfs-tools/hooks/.\n#!/bin/sh\ncp /etc/crypttab \"${DESTDIR}/cryptroot/crypttab\"\nexit\nGuarda aquest script com a /etc/initramfs-tools/hooks/copy-crypttab i fes-lo executable:\nchmod +x /etc/initramfs-tools/hooks/copy-crypttab\n\n\nActualitzar la initramfs\nPerquè els canvis tinguin efecte, cal actualitzar la initramfs. Això es fa amb la comanda següent:\nupdate-initramfs -u -k $(uname -r)\n\n\nComprovar la inclusió de l’script i cryptsetup a la initramfs\nPer assegurar-te que l’script s’ha inclòs correctament a la initramfs i que cryptsetup també hi és, pots utilitzar les següents comandes:\nlsinitramfs /boot/initrd.img-$(uname -r) | grep mount_disk\nlsinitramfs /boot/initrd.img-$(uname -r) | grep cryptsetup\n\n\nProva l’arrencada\nReinicia la màquina virtual per provar l’arrencada. Si tot està configurat correctament, la partició LUKS s’hauria de desxifrar automàticament utilitzant la clau emmagatzemada al disc secundari. Sense demanar la contrasenya manualment.\nreboot\n\n\nConsultar el log d’arrencada\nDurant l’arrencada, el sistema registrarà missatges al kernel log. Pots consultar aquests missatges per verificar que l’script s’ha executat correctament i que la partició LUKS s’ha desxifrat. Utilitza la comanda següent per veure els missatges rellevants:\ndmesg | grep mount_disk",
    "crumbs": [
      "Activitats",
      "Unitat 02 · Arrencada del sistema",
      "Activitat 5 · Arrencada automàtica d'una partició LUKS amb clau en un disc secundari"
    ]
  },
  {
    "objectID": "exercises/02-booting/02-ex-week2.html",
    "href": "exercises/02-booting/02-ex-week2.html",
    "title": "Arrancada UEFI bàsica amb QEMU",
    "section": "",
    "text": "En aquest exercici aprendrem a crear un entorn d’arrencada UEFI senzill utilitzant QEMU. A diferència de la BIOS tradicional, la UEFI utilitza fitxers executables en format PE (Portable Executable) per carregar els sistemes operatius. Aquests fitxers es col·loquen en una partició especial del disc anomenada ESP (EFI System Partition).\nL’objectiu final és carregar i executar un petit joc de Tetris dins de l’entorn UEFI.\n\n\nPer a aquest laboratori, necessitem una màquina virtual amb Debian i una interfície gràfica, ja que la UEFI per defecte utilitza un entorn gràfic.\nSi no teniu una interfície gràfica, podeu instal·lar-la amb la següent comanda:\nsu -c \"apt install task-gnome-desktop -y\"\n\n\n\n\n\n\nNotaNota\n\n\n\nUn cop instal·lada la interfície gràfica, reinicieu la màquina virtual i inicieu sessió a l’entorn d’escriptori.\n\n\nA més, necessitem instal·lar les eines necessàries per compilar i executar el nostre codi UEFI.\nsu -c \"apt install qemu-system-x86 gcc-x86-64-linux-gnu nasm make gnu-efi gdisk mtools -y\"\nsu -c “apt install qemu-system-x86 make gdisk mtools -y”\nFinalment, clonem el repositori amb el codi font del joc de Tetris per UEFI:\ngit clone https://github.com/a1ive/uefi-tetris.git\ncd uefi-tetris\n\n\n\n\n\n\nNotaNota\n\n\n\nQuan executeu les comandes QEMU, no ho feu amb la conexió SSH ja que us donarà problemes amb la interfície gràfica. Utilitzeu la terminal de la màquina virtual directament.\n\n\n\n\n\nAquest mètode ens permetrà executar ràpidament un executable UEFI sense la necessitat de crear una imatge de disc. Utilitzarem la UEFI Shell, una línia de comandes que ens permet interactuar amb l’entorn UEFI.\nqemu-system-x86_64 -bios /usr/share/qemu/OVMF.fd -drive format=raw,file=fat:rw:./ -net none\nOn aquest comandament:\n\nbios /usr/share/qemu/OVMF.fd: Carrega el firmware OVMF (Open Virtual Machine Firmware), que és la implementació UEFI per a QEMU.\n-drive format=raw,file=fat:rw:./: Munta el directori actual (./) com si fos una partició FAT. La UEFI Shell reconeix aquest format de manera nativa, donant-nos accés al nostre fitxer tetris.efi.\n-net none: Deshabilita la xarxa, ja que no la necessitem per a aquest exercici.\n\nEn executar la comanda, QEMU s’iniciarà i, com que no hi ha cap sistema operatiu per arrencar, caurà directament a la UEFI Shell.\n\n\nUn cop a la UEFI Shell, accedim a la partició que QEMU ha muntat per nosaltres.\nfs0:\nLa comanda fs0: ens canvia a la partició FAT que correspon al nostre directori.\n\n\n\n\n\n\nNotaNotes\n\n\n\n\nEl teclat està en anglès per defecte. Per escriure el caràcter : heu de prémer Shift + Ñ.\nSi fs0: no funciona, podeu llistar les particions disponibles amb la comanda map i provar amb les altres.\n\n\n\n\n\n\n\n\n\nNotaNota\n\n\n\nUtilitzeu les comandes ls i cd per navegar pel sistema de fitxers fins que trobeu la carpeta uefi-tetris i dins d’ella el fitxer tetris.efi.\n\n\nFinalment, executem el bootloader UEFI:\ntetris.efi\n\n\n\n\nAquest mètode simula un escenari més real, on el fitxer executable es troba en una partició dedicada al disc. La partició ESP (EFI System Partition) és una partició especial, formatada en FAT32, on es guarden els fitxers d’arrencada del sistema operatiu.\n\n\nPrimer, creem un fitxer que farà de disc dur virtual. Amb 64 MB n’hi ha prou.\nqemu-img create -f raw tetris.img 64M\n\n\n\nUtilitzarem gdisk per crear la partició ESP. La GPT (GUID Partition Table) és el format modern de taules de particions, necessari per a la UEFI.\nsu -\ncd /path/to/uefi-tetris # Canvia al directori on has clonat el repositori\ngdisk tetris.img\nA la consola de gdisk, utilitzarem les següents comandes:\n\nPrémer o per crear una nova taula GPT.\nPrémer n per crear una nova partició.\nPrèmer 1 per assignar el número de partició.\nPrèmer Enter per acceptar l’inici per defecte.\nPrèmer Enter per acceptar la mida per defecte (fins al final del disc).\nPrèmer ef00 per assignar el tipus EFI System Partition.\nPrèmer w per escriure els canvis i sortir.\n\n\n\n\n\n\n\nNotaNota\n\n\n\nConfirmeu tots els canvis escrivint Y quan se us demani. Per assegurar-vos que la partició s’ha creat correctament, podeu utilitzar gdisk -l tetris.img per llistar les particions del fitxer d’imatge. Observeu que la partició té el tipus EF00, indicant que és una partició ESP.\n\n\n\n\n\nAra que tenim la partició, l’hem de formatar, és a dir, donar-li un sistema de fitxers. La UEFI requereix que la partició ESP estigui formatada en FAT32.\n\nIdentificar el dispositiu de bucle:\n\n# Com a root\nlosetup --partscan --find --show tetris.img\nAquesta comanda mostrarà el nom del dispositiu de bucle creat (p. ex., /dev/loop1) i la seva partició (/dev/loop1p1). Anoteu-ho.\n\nFormatejar la partició:\n\n# Com a root\nmkfs.fat -F 32 /dev/loop1p1\n\n\n\nAra, muntem la partició i copiem el fitxer tetris.efi a la ubicació correcta dins de l’estructura de directoris esperada per la UEFI.\n# Com a root\nmount /dev/loop1p1 /mnt\nmkdir -p /mnt/EFI/BOOT\ncp tetris.efi /mnt/EFI/BOOT/BOOTX64.EFI\numount /mnt\nlosetup -d /dev/loop1\n\n\n\n\n\n\nNotaObservació\n\n\n\nLa UEFI espera trobar el fitxer d’arrencada en aquesta ubicació específica: \\EFI\\BOOT\\BOOTX64.EFI per a sistemes x86_64. Si utilitzeu una arquitectura diferent, assegureu-vos de canviar el nom del fitxer segons sigui necessari (per exemple, BOOTAA64.EFI per a ARM64). Com estem emulant un sistema x86_64, utilitzem BOOTX64.EFI.\n\n\n\n\n\nFinalment, podem arrencar la nostra imatge de disc amb QEMU utilitzant el firmware UEFI.\nqemu-system-x86_64 -bios /usr/share/qemu/OVMF.fd -drive format=raw,file=tetris.img -net none\nSi tot ha anat bé, hauríeu de veure el joc de Tetris en funcionament a la pantalla directament sense necessitat d’entrar a la UEFI Shell.",
    "crumbs": [
      "Activitats",
      "Unitat 02 · Arrencada del sistema",
      "Activitat 2 · Booting amb UEFI"
    ]
  },
  {
    "objectID": "exercises/02-booting/02-ex-week2.html#tetris-amb-uefi",
    "href": "exercises/02-booting/02-ex-week2.html#tetris-amb-uefi",
    "title": "Arrancada UEFI bàsica amb QEMU",
    "section": "",
    "text": "En aquest exercici aprendrem a crear un entorn d’arrencada UEFI senzill utilitzant QEMU. A diferència de la BIOS tradicional, la UEFI utilitza fitxers executables en format PE (Portable Executable) per carregar els sistemes operatius. Aquests fitxers es col·loquen en una partició especial del disc anomenada ESP (EFI System Partition).\nL’objectiu final és carregar i executar un petit joc de Tetris dins de l’entorn UEFI.\n\n\nPer a aquest laboratori, necessitem una màquina virtual amb Debian i una interfície gràfica, ja que la UEFI per defecte utilitza un entorn gràfic.\nSi no teniu una interfície gràfica, podeu instal·lar-la amb la següent comanda:\nsu -c \"apt install task-gnome-desktop -y\"\n\n\n\n\n\n\nNotaNota\n\n\n\nUn cop instal·lada la interfície gràfica, reinicieu la màquina virtual i inicieu sessió a l’entorn d’escriptori.\n\n\nA més, necessitem instal·lar les eines necessàries per compilar i executar el nostre codi UEFI.\nsu -c \"apt install qemu-system-x86 gcc-x86-64-linux-gnu nasm make gnu-efi gdisk mtools -y\"\nsu -c “apt install qemu-system-x86 make gdisk mtools -y”\nFinalment, clonem el repositori amb el codi font del joc de Tetris per UEFI:\ngit clone https://github.com/a1ive/uefi-tetris.git\ncd uefi-tetris\n\n\n\n\n\n\nNotaNota\n\n\n\nQuan executeu les comandes QEMU, no ho feu amb la conexió SSH ja que us donarà problemes amb la interfície gràfica. Utilitzeu la terminal de la màquina virtual directament.\n\n\n\n\n\nAquest mètode ens permetrà executar ràpidament un executable UEFI sense la necessitat de crear una imatge de disc. Utilitzarem la UEFI Shell, una línia de comandes que ens permet interactuar amb l’entorn UEFI.\nqemu-system-x86_64 -bios /usr/share/qemu/OVMF.fd -drive format=raw,file=fat:rw:./ -net none\nOn aquest comandament:\n\nbios /usr/share/qemu/OVMF.fd: Carrega el firmware OVMF (Open Virtual Machine Firmware), que és la implementació UEFI per a QEMU.\n-drive format=raw,file=fat:rw:./: Munta el directori actual (./) com si fos una partició FAT. La UEFI Shell reconeix aquest format de manera nativa, donant-nos accés al nostre fitxer tetris.efi.\n-net none: Deshabilita la xarxa, ja que no la necessitem per a aquest exercici.\n\nEn executar la comanda, QEMU s’iniciarà i, com que no hi ha cap sistema operatiu per arrencar, caurà directament a la UEFI Shell.\n\n\nUn cop a la UEFI Shell, accedim a la partició que QEMU ha muntat per nosaltres.\nfs0:\nLa comanda fs0: ens canvia a la partició FAT que correspon al nostre directori.\n\n\n\n\n\n\nNotaNotes\n\n\n\n\nEl teclat està en anglès per defecte. Per escriure el caràcter : heu de prémer Shift + Ñ.\nSi fs0: no funciona, podeu llistar les particions disponibles amb la comanda map i provar amb les altres.\n\n\n\n\n\n\n\n\n\nNotaNota\n\n\n\nUtilitzeu les comandes ls i cd per navegar pel sistema de fitxers fins que trobeu la carpeta uefi-tetris i dins d’ella el fitxer tetris.efi.\n\n\nFinalment, executem el bootloader UEFI:\ntetris.efi\n\n\n\n\nAquest mètode simula un escenari més real, on el fitxer executable es troba en una partició dedicada al disc. La partició ESP (EFI System Partition) és una partició especial, formatada en FAT32, on es guarden els fitxers d’arrencada del sistema operatiu.\n\n\nPrimer, creem un fitxer que farà de disc dur virtual. Amb 64 MB n’hi ha prou.\nqemu-img create -f raw tetris.img 64M\n\n\n\nUtilitzarem gdisk per crear la partició ESP. La GPT (GUID Partition Table) és el format modern de taules de particions, necessari per a la UEFI.\nsu -\ncd /path/to/uefi-tetris # Canvia al directori on has clonat el repositori\ngdisk tetris.img\nA la consola de gdisk, utilitzarem les següents comandes:\n\nPrémer o per crear una nova taula GPT.\nPrémer n per crear una nova partició.\nPrèmer 1 per assignar el número de partició.\nPrèmer Enter per acceptar l’inici per defecte.\nPrèmer Enter per acceptar la mida per defecte (fins al final del disc).\nPrèmer ef00 per assignar el tipus EFI System Partition.\nPrèmer w per escriure els canvis i sortir.\n\n\n\n\n\n\n\nNotaNota\n\n\n\nConfirmeu tots els canvis escrivint Y quan se us demani. Per assegurar-vos que la partició s’ha creat correctament, podeu utilitzar gdisk -l tetris.img per llistar les particions del fitxer d’imatge. Observeu que la partició té el tipus EF00, indicant que és una partició ESP.\n\n\n\n\n\nAra que tenim la partició, l’hem de formatar, és a dir, donar-li un sistema de fitxers. La UEFI requereix que la partició ESP estigui formatada en FAT32.\n\nIdentificar el dispositiu de bucle:\n\n# Com a root\nlosetup --partscan --find --show tetris.img\nAquesta comanda mostrarà el nom del dispositiu de bucle creat (p. ex., /dev/loop1) i la seva partició (/dev/loop1p1). Anoteu-ho.\n\nFormatejar la partició:\n\n# Com a root\nmkfs.fat -F 32 /dev/loop1p1\n\n\n\nAra, muntem la partició i copiem el fitxer tetris.efi a la ubicació correcta dins de l’estructura de directoris esperada per la UEFI.\n# Com a root\nmount /dev/loop1p1 /mnt\nmkdir -p /mnt/EFI/BOOT\ncp tetris.efi /mnt/EFI/BOOT/BOOTX64.EFI\numount /mnt\nlosetup -d /dev/loop1\n\n\n\n\n\n\nNotaObservació\n\n\n\nLa UEFI espera trobar el fitxer d’arrencada en aquesta ubicació específica: \\EFI\\BOOT\\BOOTX64.EFI per a sistemes x86_64. Si utilitzeu una arquitectura diferent, assegureu-vos de canviar el nom del fitxer segons sigui necessari (per exemple, BOOTAA64.EFI per a ARM64). Com estem emulant un sistema x86_64, utilitzem BOOTX64.EFI.\n\n\n\n\n\nFinalment, podem arrencar la nostra imatge de disc amb QEMU utilitzant el firmware UEFI.\nqemu-system-x86_64 -bios /usr/share/qemu/OVMF.fd -drive format=raw,file=tetris.img -net none\nSi tot ha anat bé, hauríeu de veure el joc de Tetris en funcionament a la pantalla directament sense necessitat d’entrar a la UEFI Shell.",
    "crumbs": [
      "Activitats",
      "Unitat 02 · Arrencada del sistema",
      "Activitat 2 · Booting amb UEFI"
    ]
  },
  {
    "objectID": "exercises/02-booting/01-ex-week2.html",
    "href": "exercises/02-booting/01-ex-week2.html",
    "title": "Booting amb MBR i BIOS",
    "section": "",
    "text": "Entendre com funciona el procés d’arrencada amb BIOS i MBR.\nCrear un bootloader senzill de primera i segona etapa.\nPracticar l’ús de QEMU per emular una màquina amb BIOS.",
    "crumbs": [
      "Activitats",
      "Unitat 02 · Arrencada del sistema",
      "Activitat 1 · Booting amb MBR i BIOS"
    ]
  },
  {
    "objectID": "exercises/02-booting/01-ex-week2.html#objectiu",
    "href": "exercises/02-booting/01-ex-week2.html#objectiu",
    "title": "Booting amb MBR i BIOS",
    "section": "",
    "text": "Entendre com funciona el procés d’arrencada amb BIOS i MBR.\nCrear un bootloader senzill de primera i segona etapa.\nPracticar l’ús de QEMU per emular una màquina amb BIOS.",
    "crumbs": [
      "Activitats",
      "Unitat 02 · Arrencada del sistema",
      "Activitat 1 · Booting amb MBR i BIOS"
    ]
  },
  {
    "objectID": "exercises/02-booting/01-ex-week2.html#requisits-previs",
    "href": "exercises/02-booting/01-ex-week2.html#requisits-previs",
    "title": "Booting amb MBR i BIOS",
    "section": "Requisits previs",
    "text": "Requisits previs\n\nUna màquina virtual amb Debian i accés a la terminal.\n\n\nPart 1: El Bootloader de Primera Etapa (MBR)\nL’objectiu d’aquesta part és crear un disc virtual amb un MBR que la BIOS pugui reconèixer i executar, mostrant un missatge de benvinguda.\n\nCreació de la imatge del disc\nCrearem un fitxer de 10 MiB que servirà com a disc dur virtual. Utilitzarem la comanda dd:\ndd if=/dev/zero of=disk.img bs=512 count=20480\nObserveu que bs=512 estableix la mida del bloc a 512 bytes, i count=20480 indica que volem 20480 blocs, resultant en un fitxer de 10 MiB (512 bytes * 20480 blocs = 10 MiB). A més, aquest fitxer estarà inicialitzat amb zeros (if=/dev/zero) i es crearà amb el nom disk.img.\n\n\n\n\n\n\nNotaRecordatori\n\n\n\nMBR significa Master Boot Record i ocupa els primers 512 bytes del disc.\n\n\n\n\nBootloader de primera etapa\nEl bootloader de primera etapa és un petit programa que s’executa quan la BIOS carrega el MBR. Aquest programa ha de ser molt petit, ja que només té 512 bytes per treballar. En aquest exercici, escriurem un bootloader senzill en llenguatge d’assemblador que mostrarà un missatge de benvinguda.\nCrea un fitxer anomenat boot.asm amb el següent contingut:\n[org 0x7c00]      ; L'adreça on la BIOS carrega el nostre codi\n\njmp short start   ; Salt a la rutina principal per evitar que la BIOS executi la taula de particions\nnop               ; \n\nstart:\n    ; Configurem els registres del segment\n    xor ax, ax      ; Posa AX a 0\n    mov ds, ax      ; Configurem DS (segment de dades) a 0\n    mov es, ax      ; Configurem ES (segment extra) a 0\n    mov ss, ax      ; Configurem SS (segment de pila) a 0\n    mov sp, 0x7c00  ; Configurem el punter de pila\n\n    ; Imprimir el missatge de benvinguda\n    mov si, msg     ; Carreguem l'adreça del missatge a SI\n.print_loop:\n    lodsb           ; Carreguem un byte des de [DS:SI] a AL, i incrementem SI\n    cmp al, 0       ; Comparem AL amb zero\n    je .done_print  ; Si AL és zero, hem arribat al final del missatge\n    mov ah, 0x0e    ; Funció BIOS per a l'escriptura en mode teletip\n    int 0x10        ; Crida a la interrupció de vídeo\n    jmp .print_loop\n.done_print:\n\n    ; Bucle infinit per aturar l'execució\n    cli             ; Deshabilitem les interrupcions\n.halt:\n    hlt             ; Aturem la CPU\n    jmp .halt       ; Saltem a nosaltres mateixos en cas de despertar-nos d'un HLT\n\nmsg db \"Hola, soc l'MBR. La primera etapa d'arrencada ha funcionat!\", 0\n\n; Omplim la resta del sector amb zeros\ntimes 510 - ($-$$) db 0\n\n; La signatura MBR\ndw 0xaa55\nLa primera línia [org 0x7c00] indica a l’assemblador que el codi s’ha de considerar com si s’executés a l’adreça 0x7C00, que és on la BIOS carrega el sector MBR a la memòria.\nAbans de l’execució del nostre codi, els registres de segment de la CPU (DS, ES, SS) poden contenir valors aleatoris. Per garantir que les adreces de memòria siguin interpretades correctament en mode real, els inicialitzem a zero amb les instruccions mov ds, ax, mov es, ax i mov ss, ax.\nLa instrucció mov sp, 0x7c00 estableix el punter de pila (SP) a la mateixa adreça on s’ha carregat el MBR, evitant que la pila sobrescrigui el codi. En bootloaders més complexos, això permetria utilitzar instruccions com CALL, PUSH i POP sense problemes.\nLa rutina de bucle llegeix cada caràcter de la cadena de text i el mostra a la pantalla mitjançant la interrupció BIOS 0x10, funció teletip (AH=0x0E). Un cop s’ha imprès tot el missatge, s’utilitza la instrucció HLT dins d’un bucle infinit per aturar la CPU. Això evita que la CPU continuï executant dades no definides més enllà del sector MBR, cosa que podria provocar comportaments inesperats.\n\n\nEnsamblar i escriure el bootloader al disc\nUtilitzarem nasm per ensamblar el nostre codi i dd per escriure’l al disc virtual:\n# Instal·lar nasm si no el tens\nsu -c \"apt install nasm -y\"\n# Ensamblar el codi\nnasm -f bin -o boot.bin boot.asm\nOn -f bin indica que volem un fitxer binari pla, i -o boot.bin especifica el nom del fitxer de sortida.\n\n\n\n\n\n\nImportantProblemes\n\n\n\nSi la comanda d’instalació de qemu no acaba correctament, heu de fer un su -c \"apt update\" i problablement també un su -c \"apt upgrade -y\" abans de tornar a intentar instal·lar qemu.\n\n\nAra, escrivim el bootloader al disc virtual:\ndd if=boot.bin of=disk.img bs=512 count=1 conv=notrunc\nOn conv=notrunc assegura que no truncarem el fitxer de sortida, mantenint la resta del disc intacta.\nPer comprovar que el bootloader s’ha escrit correctament, podem utilitzar hexdump:\nhexdump -C -n 512 disk.img | sed -n '1,16p'\non -n 512 limita la sortida als primers 512 bytes (el sector MBR) i sed -n '1,16p' mostra només les primeres 16 línies de la sortida.\nTambé podem comprovar la signatura MBR (els últims dos bytes del sector) amb:\nhexdump -C -s 510 -n 2 disk.img\nHaurias de veure 55 aa, el 00000200 indica l’offset.\n\n\nExecutar la imatge del disc amb QEMU\nFinalment, podem executar la nostra imatge de disc amb QEMU per veure el nostre missatge de benvinguda:\n# Instal·lar QEMU si no el tens\nsu -c \"apt install qemu-system-x86 -y\"\n# Executar la imatge del disc\nqemu-system-x86_64 -drive file=disk.img,format=raw -nographic\n\n\n\n\n\n\nNotaNota\n\n\n\nLa nostra màquina virtual és mode text (-nographic), així que hauries de veure el missatge de benvinguda a la terminal. Si teniu una interfície gràfica, podeu ometre -nographic per veure la sortida en una finestra de QEMU.\n\n\nEnhorabona! Acabes de crear i executar un bootloader de primera etapa senzill que mostra un missatge de benvinguda. Aquest és el primer pas per entendre com funciona el procés d’arrencada d’un sistema operatiu.\n\n\n\n\n\n\nConsellSortir de QEMU\n\n\n\n\nPer sortir de QEMU, utilitza la combinació de tecles Ctrl + A, seguida de X.\nAlternativament, pots Ctrl + C a la terminal per anar a la línia de comandes de QEMU i després escriure quit per sortir.\n\n\n\n\n\n\nPart 2: El Bootloader de Segona\nEn aquest punt, ja tenim el nostre bootloader de primera etapa, però la seva funció principal és passar el control a un programa més gran. Aquest serà el nostre bootloader de segona etapa. Per fer-ho, el MBR ha de llegir un sector del disc i carregar-lo a la memòria. Normalment, el MBR analitzaria la taula de particions per trobar on comença el següent bootloader. No obstant això, per a aquest exercici, simplificarem aquest procés i codificarem directament l’adreça del nostre bootloader de segona etapa al codi.\nLa interrupció int 0x13h de la BIOS és la responsable de les operacions d’entrada/sortida de disc i requereix un paquet d’adreces de disc (DAP) per funcionar. Aquest DAP és una estructura de dades de 16 bytes que li diu a la BIOS on llegir i on escriure les dades. La proposta és configurar el nostre DAP per llegir el sector 2048 del disc (dword [si+8], 2048) i carregar-lo a la memòria a l’adreça 0x8000 (word [si+4], 0x8000).\nEscriu un fitxer anomenat second_boot.asm amb el següent contingut:\n[org 0x8000]     ; Stage2 carregat pel MBR a 0x8000\n\nmov si, msg\n.print_loop:\n    lodsb\n    or al, al\n    jz .done\n    mov ah, 0x0e\n    int 0x10\n    jmp .print_loop\n\n.done:\n    jmp $       \n\nmsg db \"Hola des del bootloader de segona etapa!\", 0\nAra ensamblarem aquest codi i el prepararem per ser carregat pel nostre bootloader de primera etapa.\nnasm -f bin -o second_boot.bin second_boot.asm\nAra, escriurem aquest bootloader de segona etapa al disc virtual, però no al principi. El MBR està dissenyat per carregar el bootloader de segona etapa des d’una ubicació específica del disc. En aquest cas, utilitzarem el sector 2048 (1 MiB) per a això. Representaria la primera partició d’un disc amb una taula de particions estàndard.\ndd if=second_boot.bin of=disk.img bs=512 count=1 seek=2048 conv=notrunc\nModifiqueu el vostre boot.asm per carregar aquest bootloader de segona etapa des del sector 2048:\n[org 0x7c00]\n\njmp short start\nnop\n\nstart:\n    xor ax, ax\n    mov ds, ax\n    mov es, ax\n    mov ss, ax\n    mov sp, 0x7c00\n\n    ; Missatge Stage1\n    mov si, msg_mbr\n.print_loop_mbr:\n    lodsb\n    or al, al\n    jz .load_next_stage\n    mov ah, 0x0e\n    int 0x10\n    jmp .print_loop_mbr\n\n.load_next_stage:\n    ; Configura DAP a 0x0600\n    mov si, 0x0600\n    mov byte [si], 0x10         ; mida del DAP\n    mov byte [si+1], 0x00\n    mov word [si+2], 1          ; sectors a llegir\n    mov word [si+4], 0x8000     ; offset destí\n    mov word [si+6], 0x0000     ; segment destí\n    mov dword [si+8], 2048      ; LBA\n    mov dword [si+12], 0        ; high LBA\n\n    ; BIOS extended read\n    mov ah, 0x42\n    mov dl, 0x80\n    int 0x13\n    jc .boot_failed\n\n    jmp 0:0x8000\n\n.boot_failed:\n    mov si, msg_fail\n.print_loop_fail:\n    lodsb\n    or al, al\n    jz .halt\n    mov ah, 0x0e\n    int 0x10\n    jmp .print_loop_fail\n.halt:\n    cli\n    hlt\n    jmp .halt\n\nmsg_mbr db \"Hola, soc l'MBR. Carregant Stage2...\",0\nmsg_fail db \"Error carregant Stage2!\",0\n\ntimes 510-($-$$) db 0\ndw 0xAA55\nAra ensamblarem el nou MBR:\nnasm -f bin -o boot.bin boot.asm\nI escriurem el nou MBR al disc virtual:\ndd if=boot.bin of=disk.img bs=512 count=1 conv=notrunc\nFinalment, executem la imatge del disc amb QEMU per veure el nostre missatge de benvinguda i la càrrega del bootloader de segona etapa:\nqemu-system-x86_64 -drive file=disk.img,format=raw -nographic\nEnhorabona! Acabes de crear i executar un bootloader de primera etapa que carrega un bootloader de segona etapa des d’una ubicació específica del disc.",
    "crumbs": [
      "Activitats",
      "Unitat 02 · Arrencada del sistema",
      "Activitat 1 · Booting amb MBR i BIOS"
    ]
  },
  {
    "objectID": "exercises/02-booting/03-ex-week2.html",
    "href": "exercises/02-booting/03-ex-week2.html",
    "title": "Arrancada UEFI",
    "section": "",
    "text": "Entendre com funciona la UEFI i la partició ESP.\nConfigurar una màquina virtual amb dual boot.\nPracticar la gestió de l’ordre d’arrencada i la creació d’entrades UEFI.\n\nAl final, hauries de poder seleccionar entre AlmaLinux i Debian a l’inici de la màquina virtual.",
    "crumbs": [
      "Activitats",
      "Unitat 02 · Arrencada del sistema",
      "Activitat 3 · Dual Boot amb UEFI"
    ]
  },
  {
    "objectID": "exercises/02-booting/03-ex-week2.html#objectiu",
    "href": "exercises/02-booting/03-ex-week2.html#objectiu",
    "title": "Arrancada UEFI",
    "section": "",
    "text": "Entendre com funciona la UEFI i la partició ESP.\nConfigurar una màquina virtual amb dual boot.\nPracticar la gestió de l’ordre d’arrencada i la creació d’entrades UEFI.\n\nAl final, hauries de poder seleccionar entre AlmaLinux i Debian a l’inici de la màquina virtual.",
    "crumbs": [
      "Activitats",
      "Unitat 02 · Arrencada del sistema",
      "Activitat 3 · Dual Boot amb UEFI"
    ]
  },
  {
    "objectID": "exercises/02-booting/03-ex-week2.html#preparació-de-les-màquines-virtuals",
    "href": "exercises/02-booting/03-ex-week2.html#preparació-de-les-màquines-virtuals",
    "title": "Arrancada UEFI",
    "section": "Preparació de les Màquines Virtuals",
    "text": "Preparació de les Màquines Virtuals\nEn primer lloc, heu de crear dues màquines virtuals amb UEFI com a firmware.\n\n\n\nNom\nOS\nDisc\nFirmware\n\n\n\n\nVM1-AlmaLinux\nAlmaLinux 9\n20 GB\nUEFI\n\n\nVM2-Debian\nDebian 12\n20 GB\nUEFI\n\n\n\n\n\n\n\n\n\nNotaNota\n\n\n\nAssegureu-vos que ambdues màquines virtuals tinguin UEFI com a firmware. En el moment de fer les particions, heu de veure que es crea una partició ESP (EFI System Partition) automàticament. Si no és així, pot ser que la màquina virtual no estigui configurada correctament per utilitzar UEFI. No continuïs fins que no tinguis aquesta partició.\n\n\n\n\n\n\n\n\nAlertaAdvertència\n\n\n\nSi VMWare no us deixa seleccionar UEFI com a firmware, un cop creada la màquina virtual amb BIOS, heu de modificar el fitxer .vmx de la màquina virtual i afegir al final les línies següents:\nfirmware = \"efi\"\nefi.secureBoot.enabled = \"FALSE\"\nGuarda els canvis i inicia la màquina virtual de nou, i instal·la el sistema operatiu.",
    "crumbs": [
      "Activitats",
      "Unitat 02 · Arrencada del sistema",
      "Activitat 3 · Dual Boot amb UEFI"
    ]
  },
  {
    "objectID": "exercises/02-booting/03-ex-week2.html#migrar-el-disc-de-debian-a-la-màquina-virtual-dalmalinux",
    "href": "exercises/02-booting/03-ex-week2.html#migrar-el-disc-de-debian-a-la-màquina-virtual-dalmalinux",
    "title": "Arrancada UEFI",
    "section": "Migrar el disc de Debian a la màquina virtual d’AlmaLinux",
    "text": "Migrar el disc de Debian a la màquina virtual d’AlmaLinux\n\nApaga la màquina virtual de Debian si està en funcionament.\nLocalitza el fitxer de disc virtual de la màquina virtual de Debian. Aquest fitxer al programa VMware sol tenir l’extensió .vmdk.\nA la configuració de la màquina virtual d’AlmaLinux, aneu a l’opció de disc dur i afegiu un disc dur existent, seleccionant el disc dur de la màquina virtual de Debian que heu localitzat en el pas anterior.\nConfirmar els parametres i aplica els canvis.\n\n\nTest\nAssegureu-vos que la màquina virtual ara té dos discs durs: un amb AlmaLinux i un altre amb Debian utilitzant la comanda lsblk, hauria de mostrar-vos alguna cosa com això:\n[root@localhost ~]# lsblk\nNAME               MAJ:MIN RM  SIZE RO TYPE MOUNTPOINTS\nsr0                 11:0    1  1.7G  0 rom\nnvme0n1            259:0    0   20G  0 disk\n├─nvme0n1p1        259:1    0  600M  0 part /boot/efi\n├─nvme0n1p2        259:2    0    1G  0 part /boot\n└─nvme0n1p3        259:3    0 18.4G  0 part\n├─almalinux-root 253:0    0 16.4G  0 lvm  /\n└─almalinux-swap 253:1    0    2G  0 lvm  [SWAP]\nnvme0n2            259:4    0   20G  0 disk\n├─nvme0n2p1        259:5    0  512M  0 part\n├─nvme0n2p2        259:6    0 18.5G  0 part\n└─nvme0n2p3        259:7    0  976M  0 part\nOn nvme0n1 és el disc d’AlmaLinux i nvme0n2 és el disc de Debian. Es posible que el nom del disc no sigui nvme, pot ser sda, vda, etc. Depèn del tipus de disc que tinguis.",
    "crumbs": [
      "Activitats",
      "Unitat 02 · Arrencada del sistema",
      "Activitat 3 · Dual Boot amb UEFI"
    ]
  },
  {
    "objectID": "exercises/02-booting/03-ex-week2.html#tasca",
    "href": "exercises/02-booting/03-ex-week2.html#tasca",
    "title": "Arrancada UEFI",
    "section": "Tasca",
    "text": "Tasca\nReinicia la màquina virtual d’AlmaLinux i entra a la UEFI (normalment prement F2 o Esc durant l’arrencada). La teva tasca es configurar la UEFI per afegir una entrada d’arrencada per a Debian. Has de poder arrancar tant AlmaLinux com Debian des del menú d’arrencada de la UEFI.\n\nEl primer pas és identificar com podem arrancar Debian.\nAnalitzeu la comanda bcfg amb help bcfg per veure com funciona.\n\n\n\n\n\n\n\nImportantNota\n\n\n\nLa comanda bcfg es troba disponible a partir de la versió 2.3 de UEFI Shell. Si la vostra màquina virtual utilitza una versió anterior, és possible que no tingueu aquesta comanda disponible. En aquest cas, haureu d’actualitzar el firmware UEFI de la vostra màquina virtual o utilitzar una altra eina per gestionar les entrades d’arrencada com efibootmgr des de Linux.\n\n\nEn cas de no poder accedir a la shell o no tenir disponible la comanda bcfg encara que es compleixi el requisit de la versió de UEFI Shell &gt;= 2.3, cal arrencar des d’un fitxer EFI Shell V2 més complet. Podeu descarregar-lo aquí.\nPer poder arrencar aquest fitxer des de VMware, l’hem d’escriure amb el format correcte a una imatge vmdk:\n\nEl primer pas és crear una imatge de disc buida on després escriurem l’arbre de directoris adequat per EFI així com el fitxer descarregat a arrencar.\ndd if=/dev/zero of=Shell.img bs=1M count=64\nAra utilitzem parted per crear una taula de particions GPT i una partició FAT32 marcada com a bootable.\nparted Shell.img --script mklabel gpt\nparted Shell.img --script mkpart ESP fat32 1MiB 100%\nparted Shell.img --script set 1 boot on\nPer poder treballar amb les particions dins del fitxer de disc, l’associem a un dispositiu loop.\nsudo losetup -Pf Shell.img\nFormatem la partició EFI amb FAT32, obligatori per a UEFI:\nsudo mkfs.vfat -F32 /dev/loop0p1\nMuntem la partició, creem l’arbre de directoris correcte i copiem el fitxer .efi amb el nom BOOTX64.EFI. Finalment, desmuntem la partició i desassociem el dispositiu loop.\nsudo mount /dev/loop0p1 /mnt\nsudo mkdir -p /mnt/EFI/BOOT\nsudo cp Shellx64.efi /mnt/EFI/BOOT/BOOTX64.EFI\nsudo umount /mnt\nsudo losetup -d /dev/loop0\nFinalment convertim la imatge RAW a VMDK perquè pugui ser utilitzada a VMware:\nqemu-img convert -f raw -O vmdk Shell.img Shell.vmdk\n\nPer usar aquest fitxer generat, afegiu un disc dur (Hard Disk) a la vostra màquina i obriu-lo.\n\n\n\n\n\n\nImportantNota\n\n\n\nEn cas de tenir un altre disc dur bootejable a la màquina virtual, per defecte no arrencarà des del de UEFI Shell. Per poder executar-ho, heu d’entrar a la UEFI (normalment prement F2 o Esc durant l’arrencada) i seleccionar el disc dur corresponent a la UEFI Shell.\n\n\nSi per alguna raó no podeu executar les comandes per crear un disc dur amb l’imatge de UEFI Shell, el podeu descarregar des d’aquí.\nA partir d’aquesta shell ja teniu disponible la comanda bcfg",
    "crumbs": [
      "Activitats",
      "Unitat 02 · Arrencada del sistema",
      "Activitat 3 · Dual Boot amb UEFI"
    ]
  },
  {
    "objectID": "exercises/02-booting/03-ex-week2.html#entrega",
    "href": "exercises/02-booting/03-ex-week2.html#entrega",
    "title": "Arrancada UEFI",
    "section": "Entrega",
    "text": "Entrega\nHas de presentar un document amb els següents punts:\n\nEls passos que has seguit per configurar la UEFI i afegir l’entrada d’arrencada per a Debian.\nFes una captura de pantalla del menú d’arrencada de la UEFI mostrant les dues entrades (AlmaLinux i Debian) i puja-la a l’aula virtual juntament amb una breu descripció dels passos que has seguit per aconseguir-ho.",
    "crumbs": [
      "Activitats",
      "Unitat 02 · Arrencada del sistema",
      "Activitat 3 · Dual Boot amb UEFI"
    ]
  },
  {
    "objectID": "exercises/01-foundations-of-systems-administration/01-ex-week1.html",
    "href": "exercises/01-foundations-of-systems-administration/01-ex-week1.html",
    "title": "Configuració d’entorn de virtualització",
    "section": "",
    "text": "Aquest exercici té com a objectiu recordar i consolidar les habilitats en la configuració d’entorns de virtualització utilitzant màquines virtuals (MV). Durant el curs, la creació i destrucció de MV serà una tasca recurrent, per la qual cosa és fonamental tenir una base sòlida. Preparant una plantilla preinstal·lada, podreu estalviar temps significatiu evitant la reinstal·lació completa del sistema operatiu cada cop que necessiteu un nou entorn de treball.",
    "crumbs": [
      "Activitats",
      "Unitat 01 · Fonaments de l'Administració de Sistemes",
      "Activitat 1 · Configuració d'entorn de virtualització"
    ]
  },
  {
    "objectID": "exercises/01-foundations-of-systems-administration/01-ex-week1.html#requeriments-previs",
    "href": "exercises/01-foundations-of-systems-administration/01-ex-week1.html#requeriments-previs",
    "title": "Configuració d’entorn de virtualització",
    "section": "Requeriments previs",
    "text": "Requeriments previs\n\nDisposar d’un hipervisor de virtualització instal·lat a la vostra màquina hoste. Es recomana utilitzar VMware Workstation Pro o VMware Fusion. Podeu reutilitzar la instal·lació que ja vau fer a l’assignatura de Sistemes Operatius.",
    "crumbs": [
      "Activitats",
      "Unitat 01 · Fonaments de l'Administració de Sistemes",
      "Activitat 1 · Configuració d'entorn de virtualització"
    ]
  },
  {
    "objectID": "exercises/01-foundations-of-systems-administration/01-ex-week1.html#objectius",
    "href": "exercises/01-foundations-of-systems-administration/01-ex-week1.html#objectius",
    "title": "Configuració d’entorn de virtualització",
    "section": "Objectius",
    "text": "Objectius\n\nCrear i configurar màquines virtuals amb distribucions Linux.\nUtilitzar snapshots per gestionar l’estat de les MV.\nConfigurar i establir una connexió remota segura a les MV utilitzant SSH.",
    "crumbs": [
      "Activitats",
      "Unitat 01 · Fonaments de l'Administració de Sistemes",
      "Activitat 1 · Configuració d'entorn de virtualització"
    ]
  },
  {
    "objectID": "exercises/01-foundations-of-systems-administration/01-ex-week1.html#tasques",
    "href": "exercises/01-foundations-of-systems-administration/01-ex-week1.html#tasques",
    "title": "Configuració d’entorn de virtualització",
    "section": "Tasques",
    "text": "Tasques\n\nCreació de màquines virtuals\nCreareu dues màquines virtuals amb les distribucions Linux que farem servir durant el curs. Assegureu-vos de descarregar les imatges ISO correctament:\n\nAlmaLinux: Una distribució de GNU/Linux basada en Red Hat Enterprise Linux (RHEL).Descarregueu la versió 9.6.\nDebian: Una distribució popular coneguda per la seva estabilitat. Descarregueu la versió 12.5.0.\n\nEn la configuració no necessitareu finestres gràfiques, i de moment podeu utilitzar una configuració de disc i particions estàndard. Més endavant, durant el curs, anirem ajustant la configuració segons les necessitats específiques de cada pràctica.\n\n\nCreació de snapshots\nUn cop instal·lades les dues màquines virtuals, creeu una snapshot de cadascuna. Una snapshot és una instantània de l’estat actual de la màquina virtual, incloent-hi la seva memòria, configuració i l’estat dels seus discos virtuals. Aquesta eina us permetrà tornar ràpidament a un estat inicial net en qualsevol moment, evitant haver de reinstal·lar el sistema si alguna configuració falla.\n\n\nConfiguració d’accés remot amb SSH\nPer facilitar la connexió i gestió de les màquines virtuals, configurarem l’accés remot mitjançant SSH (Secure Shell). Això us permetrà connectar-vos a les MV des de la vostra màquina hoste utilitzant una terminal o PowerShell amb suport SSH (Linux o MacOS).\nssh user@vm_ip_address\n\n\nÚs de la snapshot\nUn cop hàgiu completat la configuració inicial i les proves amb les màquines virtuals, practiqueu l’ús de les snapshots:\n\nInstal·leu algun programari a la MV amb debian com les eines de desenvolupament (gcc, make, etc).\n\n# Recordeu instal·lar com a root\napt install build-essential\n\nComproveu que el programari està instal·lat correctament.\n\ngcc --version\n\nDesprés, torneu a la snapshot creada anteriorment per veure que el programari ja no està instal·lat.",
    "crumbs": [
      "Activitats",
      "Unitat 01 · Fonaments de l'Administració de Sistemes",
      "Activitat 1 · Configuració d'entorn de virtualització"
    ]
  },
  {
    "objectID": "exercises/01-foundations-of-systems-administration/01-ex-week1.html#activitat-proposada",
    "href": "exercises/01-foundations-of-systems-administration/01-ex-week1.html#activitat-proposada",
    "title": "Configuració d’entorn de virtualització",
    "section": "Activitat proposada",
    "text": "Activitat proposada\n\nEscriu un script senzill que et permeti obrir la MV i connectar-te via SSH amb un sol comandament. Aquest script hauria de:\n\nIniciar la màquina virtual si no està en funcionament.\nEsperar fins que la MV estigui completament engegada.\nConnectar-se a la MV mitjançant SSH.",
    "crumbs": [
      "Activitats",
      "Unitat 01 · Fonaments de l'Administració de Sistemes",
      "Activitat 1 · Configuració d'entorn de virtualització"
    ]
  },
  {
    "objectID": "slides/01-foundations-of-systems-administration.html#benvinguda",
    "href": "slides/01-foundations-of-systems-administration.html#benvinguda",
    "title": "Fonaments de l’Administració de Sistemes",
    "section": "Benvinguda",
    "text": "Benvinguda\n\n\n\n\n\n\n\n\n\n\n\nAdministració i Manteniment de Sistemes i Aplicacions (AMSA)\n\n\n1r Semestre, 3r Curs del Grau en Enginyeria Informàtica. Impartida per Jordi Mateo, professor del Departament d’Enginyeria Informàtica i Disseny Digital (DEIDD).\n\n\n\n\n\n\n\n\n\n(Font: Extret de Neowin)\n\n\n\n\nBenvinguts al curs 25/26 de Administració i Manteniment de Sistemes i Aplicacions. Aquesta assignatura pretén introduir-vos en el món de l’administració de sistemes i aplicacions, així com en la seva gestió i manteniment.\nAquesta vinyeta, amb un toc d’humor, il·lustra la dedicació d’un administrador de sistemes. Malgrat el caos i els reptes, la seva prioritat és assegurar que els sistemes funcionin correctament i estiguin sempre disponibles. Independentment del que passi fora de la sala de servidors. La seva feina consisteix a mantenir la infraestructura, prevenir problemes i resoldre’ls ràpidament per garantir la continuïtat dels serveis.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Fonaments de l'Administració de Sistemes"
    ]
  },
  {
    "objectID": "slides/01-foundations-of-systems-administration.html#què-és-ladministració-de-sistemes",
    "href": "slides/01-foundations-of-systems-administration.html#què-és-ladministració-de-sistemes",
    "title": "Fonaments de l’Administració de Sistemes",
    "section": "Què és l’Administració de Sistemes?",
    "text": "Què és l’Administració de Sistemes?\n\n\n\n\nPer començar, m’agradaria conèixer la vostra opinió sobre què és l’Administració de Sistemes. Per fer-ho, crearem un núvol de paraules amb les vostres respostes, al final de curs analitzarem les respostes i veurem si la vostra opinió ha canviat. Enllaç al wordcloud",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Fonaments de l'Administració de Sistemes"
    ]
  },
  {
    "objectID": "slides/01-foundations-of-systems-administration.html#què-és-ladministració-de-sistemes-1",
    "href": "slides/01-foundations-of-systems-administration.html#què-és-ladministració-de-sistemes-1",
    "title": "Fonaments de l’Administració de Sistemes",
    "section": "Què és l’Administració de Sistemes?",
    "text": "Què és l’Administració de Sistemes?\n\n\n\n\nL’administració de sistemes és la disciplina tècnica que implica la configuració, la gestió, la supervisió i el manteniment continu d’infraestructures informàtiques (servidors, xarxes, emmagatzematge de dades, programari, seguretat, etc.), per garantir la seva disponibilitat, rendiment, seguretat i funcionalitat, amb l’objectiu de satisfer les necessitats operacionals i estratègiques de l’organització.\n\n\nSi preguntem a ChatGPT que ens defineixi formalment què és l’Administració de Sistemes, ens dirà que és la disciplina tècnica que implica la configuració, la gestió, la supervisió i el manteniment continu d’infraestructures informàtiques (servidors, xarxes, emmagatzematge de dades, programari, seguretat, etc.), per garantir la seva disponibilitat, rendiment, seguretat i funcionalitat, amb l’objectiu de satisfer les necessitats operacionals i estratègiques de l’organització.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Fonaments de l'Administració de Sistemes"
    ]
  },
  {
    "objectID": "slides/01-foundations-of-systems-administration.html#què-és-un-administrador",
    "href": "slides/01-foundations-of-systems-administration.html#què-és-un-administrador",
    "title": "Fonaments de l’Administració de Sistemes",
    "section": "Què és un administrador?",
    "text": "Què és un administrador?\n\n\n\n\nUn administrador és una persona que té cura, gestiona o dirigeix els béns o els interessos d’una altra persona o entitat. En aquest cas, configurar, gestionar, supervisar i mantenir sistemes informatics.\n\n\nFixeu-vos en els elements clau de la definició:\nSegons la RAE, un administrador és una persona que té cura, gestiona o dirigeix els béns o els interessos d’una altra persona o entitat. En aquest cas, configurar, gestionar, supervisar i mantenir sistemes informatics. Això implica que la primera part de la definició de ChatGPT està en línia amb la definició de l’administrador.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Fonaments de l'Administració de Sistemes"
    ]
  },
  {
    "objectID": "slides/01-foundations-of-systems-administration.html#què-és-un-sistema",
    "href": "slides/01-foundations-of-systems-administration.html#què-és-un-sistema",
    "title": "Fonaments de l’Administració de Sistemes",
    "section": "Què és un sistema?",
    "text": "Què és un sistema?\n\n\n\n\nUn sistema és un conjunt d’elements interconnectats que treballen junts per aconseguir un objectiu comú. El Sistema Informàtic està format per hardware, programari, dades, xarxes, persones, etc., que treballen junts per processar informació.\n\n\nSegons la RAE, un sistema és un conjunt d’elements interconnectats que treballen junts per aconseguir un objectiu comú. El Sistema Informàtic està format per hardware, programari, dades, xarxes, persones, etc., que treballen junts per processar informació. Això implica que la segona part de la definició de ChatGPT necessita ser més específica per reflectir la complexitat i diversitat dels sistemes informàtics i no únicament la infraestructura.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Fonaments de l'Administració de Sistemes"
    ]
  },
  {
    "objectID": "slides/01-foundations-of-systems-administration.html#quines-són-les-métriques-a-garantir",
    "href": "slides/01-foundations-of-systems-administration.html#quines-són-les-métriques-a-garantir",
    "title": "Fonaments de l’Administració de Sistemes",
    "section": "Quines són les métriques a garantir?",
    "text": "Quines són les métriques a garantir?\n\nDisponibilitat: Capacitat d’un sistema per estar operatiu i accessible als usuaris en tot moment.\nRendiment: Mesura de l’eficiència amb què un sistema utilitza els recursos disponibles per executar tasques.\nSeguretat: Capacitat d’un sistema per protegir les dades i recursos contra accessos no autoritzats, atacs i pèrdues.\nFuncionalitat: Conjunt de característiques i capacitats que un sistema ofereix per complir amb els requisits operatius i les necessitats dels usuaris.\n\n\nA què ens referim quan diem garantir unes mètriques com la disponibilitat, el rendiment, la seguretat i la funcionalitat d’un sistema?\n\nDisponibilitat: La disponibilitat d’un sistema es refereix a la capacitat d’aquest de romandre operatiu i accessible als usuaris en tot moment, minimitzant el temps d’inactivitat. Això implica assegurar que el sistema estigui disponible per a l’ús en qualsevol moment, evitant interrupcions i fallades.\nRendiment: El rendiment d’un sistema es refereix a la mesura de l’eficiència amb què aquest utilitza els recursos disponibles per executar tasques de manera ràpida i efectiva. Això implica garantir que el sistema pugui processar dades i executar tasques de manera eficient, sense retards ni interrupcions.\nSeguretat: La seguretat d’un sistema es refereix a la capacitat d’aquest de protegir les dades i recursos contra accessos no autoritzats, atacs i pèrdues. Això implica implementar mesures de seguretat, com xifrat, autenticació, control d’accés i monitorització, per protegir la informació i els recursos del sistema.\nFuncionalitat: La funcionalitat d’un sistema es refereix al conjunt de característiques i capacitats que aquest ofereix per complir amb els requisits operatius i les necessitats dels usuaris. Això implica garantir que el sistema pugui realitzar les tasques i funcions requerides, oferint una experiència d’usuari satisfactòria i complint amb les expectatives dels usuaris.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Fonaments de l'Administració de Sistemes"
    ]
  },
  {
    "objectID": "slides/01-foundations-of-systems-administration.html#quines-són-les-necessitats-a-satisfer",
    "href": "slides/01-foundations-of-systems-administration.html#quines-són-les-necessitats-a-satisfer",
    "title": "Fonaments de l’Administració de Sistemes",
    "section": "Quines són les necessitats a satisfer?",
    "text": "Quines són les necessitats a satisfer?\n\nNecessitats Operacionals: Requisits i objectius relacionats amb l’execució diària i el funcionament eficient dels sistemes, com ara la disponibilitat, el rendiment i la seguretat.\nNecessitats Estratègiques: Objectius i metes a llarg termini de l’organització, com ara la innovació, la competitivitat i l’adaptabilitat o la escalabilitat dels sistemes.\n\n\nFinalment, la definició de ChatGPT també fa referència a les necessitats operacionals i estratègiques de l’organització. Això implica que l’administració de sistemes no només es centra en garantir el funcionament i la seguretat dels sistemes, sinó que també té en compte els objectius i les metes de l’organització en conjunt. Això significa que els administradors de sistemes han de tenir en compte les necessitats operacionals i estratègiques de l’organització per garantir que els sistemes compleixin amb els requisits i expectatives de l’empresa.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Fonaments de l'Administració de Sistemes"
    ]
  },
  {
    "objectID": "slides/01-foundations-of-systems-administration.html#millorant-la-definició-feta-per-chatgpt",
    "href": "slides/01-foundations-of-systems-administration.html#millorant-la-definició-feta-per-chatgpt",
    "title": "Fonaments de l’Administració de Sistemes",
    "section": "Millorant la definició feta per ChatGPT",
    "text": "Millorant la definició feta per ChatGPT\nL’administració de sistemes és la disciplina tècnica que implica la configuració, gestió, supervisió i manteniment continu d’infraestructures informàtiques (servidors, xarxes, emmagatzematge de dades, programari, seguretat, etc.)\naixí com la coordinació de les persones usuàries, polítiques, procediments i dades associades\nper garantir la disponibilitat, rendiment, seguretat i funcionalitat del sistema, amb l’objectiu de satisfer les necessitats operacionals i estratègiques de l’organització en conjunt.\n\nLa definició de ChatGPT no és incorrecta, però és una mica limitada. Un sistema no només està format per infraestructures (hardware, programari, xarxes, etc.), sinó que també inclou altres elements com les persones, les polítiques, els procediments, les dades que estan relacionades amb les necessitats operacionals i estratègiques. Per tant, la definició millorada inclou aquests elements per proporcionar una visió més completa de l’administració de sistemes.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Fonaments de l'Administració de Sistemes"
    ]
  },
  {
    "objectID": "slides/01-foundations-of-systems-administration.html#analogia-amb-matrix",
    "href": "slides/01-foundations-of-systems-administration.html#analogia-amb-matrix",
    "title": "Fonaments de l’Administració de Sistemes",
    "section": "Analogia amb Matrix",
    "text": "Analogia amb Matrix\n\nQuants de vosaltres heu vist la pel·lícula Matrix? Què té a veure amb l’Administració de Sistemes?\n\n\n\n\n\nIntroducció a System Administration - CBT Nuggets (0:32 fins a 2:16)\n\n\n\n\nL’autor del clip fa una analogia entre l’administració de sistemes i la pel·lícula Matrix. En aquesta pel·lícula, els personatges principals són capaços de controlar i manipular el món virtual de Matrix, canviant la realitat a voluntat. Aquesta analogia reflecteix la capacitat dels administradors de sistemes per controlar i gestionar els sistemes informàtics, configurant-los, supervisant-los i mantenint-los per garantir el seu funcionament i seguretat. Compara matrix amb un super administrador de sistemes que controla tots els aspectes i us permet menjar dos pastilles per canviar la realitat (una de blava i una de vermella). Una us permet ser administrador de sistemes i l’altra us permet ser usuari de sistemes. Aquesta analogia és una manera divertida de visualitzar el paper dels administradors de sistemes i la seva capacitat per controlar i gestionar els sistemes informàtics.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Fonaments de l'Administració de Sistemes"
    ]
  },
  {
    "objectID": "slides/01-foundations-of-systems-administration.html#evolució",
    "href": "slides/01-foundations-of-systems-administration.html#evolució",
    "title": "Fonaments de l’Administració de Sistemes",
    "section": "Evolució",
    "text": "Evolució\n\n\n\n\n\nsequenceDiagram\n    participant Maquinari\n    participant Virtualització\n    participant Contenidors\n    participant DevOps\n    participant IaC as Infraestructura com a Codi\n    participant FaaS as Funcions com a Servei\n\n    rect rgb(255, 255, 204)\n        Note over Maquinari: 1. Configuració Tradicional\n        Maquinari-&gt;&gt;Maquinari: L'administrador es centra en el hardware\n    end\n\n    rect rgb(204, 255, 204)\n        Note over Maquinari,Virtualització: 2. Virtualització\n        Maquinari-&gt;&gt;Virtualització: Aïllament de S.O.\n    end\n\n    rect rgb(204, 255, 255)\n        Note over Maquinari,DevOps: 3. Contenidors i DevOps\n        Virtualització-&gt;&gt;Contenidors: Aïllament d'aplicacions\n        Contenidors-&gt;&gt;DevOps: Faciliten el desplegament continu\n    end\n\n    rect rgb(255, 204, 255)\n        Note over Maquinari,IaC: 4. Infraestructura com a Codi (IaC)\n        DevOps-&gt;&gt;IaC: Automatització total de la infraestructura\n    end\n\n    rect rgb(255, 204, 204)\n        Note over Maquinari,FaaS: 5. Funcions com a Servei (FaaS)\n        IaC-&gt;&gt;FaaS: Abstracció completa de la plataforma\n    end\n\n\n\n\n\n\n\nFa una dècada, el món del software i el hardware era molt diferent del que coneixem avui en dia. Els servidors eren físics, les aplicacions s’executaven en un únic servidor i la infraestructura era estàtica i difícil de modificar. Els administradors de sistemes treballaven en un entorn dominat pel hardware i els cables, dedicant moltes hores a configurar i mantenir els servidors. Al mateix temps, els desenvolupadors de software operaven en un univers separat, on les aplicacions s’executaven en servidors físics i tenien poc control sobre la infraestructura. Aquesta separació va generar una divisió notable entre els dos grups, amb escassa comunicació i col·laboració.\nLa situació va canviar radicalment amb l’arribada de la virtualització. Aquesta tecnologia va permetre als administradors de sistemes crear màquines virtuals i clons de servidors, simplificant enormement la gestió i configuració de la infraestructura. La virtualització va marcar un punt d’inflexió, transformant la manera de gestionar els sistemes i permetent als desenvolupadors provar i desplegar aplicacions en entorns aïllats, millorant així la qualitat i fiabilitat del software i apropant els dos grups.\nL’aparició dels contenidors va suposar un altre gran avanç en l’administració de sistemes. Aquesta tecnologia va permetre als desenvolupadors empaquetar aplicacions i les seves dependències en contenidors lleugers i portàtils, que podien ser executats en qualsevol entorn. Això va impulsar el concepte de DEVOPS, facilitant la col·laboració entre els equips de desenvolupament i operacions per automatitzar i millorar els processos de desplegament, monitorització i gestió de la infraestructura.\nDEVOPS va emergir com a resposta a aquest canvi, promovent la col·laboració, comunicació i integració entre els equips de desenvolupament i operacions, amb l’objectiu de millorar la qualitat del software i accelerar el desplegament d’aplicacions. Aquesta metodologia va permetre als equips treballar conjuntament per automatitzar i perfeccionar els processos relacionats amb la infraestructura.\nLa pràctica de Infrastructure as Code (IAC) va completar aquest procés, permetent gestionar la infraestructura de manera programàtica mitjançant codi. Això va permetre als equips de desenvolupament i operacions tractar la infraestructura com a codi, aplicant les mateixes pràctiques de desenvolupament de software en la seva gestió. Com a resultat, la col·laboració, integració i automatització dels processos van millorar, augmentant la fiabilitat i escalabilitat de la infraestructura.\nFinalment, amb l’aparició dels conceptes serverless i Function as a Service (FAAS), la diferenciació entre desenvolupament i operacions va desaparèixer completament. Aquest nou model (actual) permet als desenvolupadors executar funcions de manera aïllada i eficient, sense preocupar-se de la infraestructura subjacent. Aquesta nova forma de treballar ha millorat la productivitat i flexibilitat dels equips de desenvolupament, facilitant el desenvolupament i desplegament d’aplicacions en entorns dinàmics i escalables. Els administradors de sistemes han evolucionat de tècnics centrats en la infraestructura a enginyers de sistemes i aplicacions, amb un enfocament més ampli i integrat en el desenvolupament de software.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Fonaments de l'Administració de Sistemes"
    ]
  },
  {
    "objectID": "slides/01-foundations-of-systems-administration.html#sortides-professionals",
    "href": "slides/01-foundations-of-systems-administration.html#sortides-professionals",
    "title": "Fonaments de l’Administració de Sistemes",
    "section": "Sortides Professionals",
    "text": "Sortides Professionals\n\n\nL’administració de sistemes és una disciplina àmplia i diversa, que no segueix una única via d’aprenentatge. Aquesta professió inclou una gran varietat de rols i especialitzacions, però no compta amb un itinerari professional clarament establert, fet que dificulta l’ensenyament de tots els seus aspectes en una sola assignatura. Si observeu el pla d’estudis del Grau en Enginyeria Informàtica, veureu que inclou assignatures orientades a la programació, amb sortides professionals com a desenvolupadors de software en diferents àmbits. Alhora, també ofereix formació en computació (xarxes, sistemes operatius, bases de dades), amb possibilitats laborals com a enginyer de xarxes o administrador de bases de dades.\nTradicionalment, l’administració de sistemes ha estat vinculada a les operacions, amb sortides professionals com a tècnic de suport o tècnic de centre de dades, sovint allunyades dels perfils d’un enginyer informàtic. No obstant això, avui en dia, l’administració de sistemes ha evolucionat significativament, donant lloc a perfils més avançats i tècnics com DevOps, SRE (Site Reliability Engineer), i Cloud Engineer, que ofereixen oportunitats laborals molt més atractives i alineades amb les necessitats del mercat actual.\nAquesta assignatura té com a objectiu introduir-vos al món de l’administració de sistemes i aplicacions, així com a la seva gestió i manteniment. Ho farem amb una visió actualitzada, orientada cap a les sortides professionals més demandades en el mercat laboral, preparant-vos per a perfils amb més responsabilitat i especialització dins del camp de les tecnologies de la informació.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Fonaments de l'Administració de Sistemes"
    ]
  },
  {
    "objectID": "slides/01-foundations-of-systems-administration.html#objectius-del-curs",
    "href": "slides/01-foundations-of-systems-administration.html#objectius-del-curs",
    "title": "Fonaments de l’Administració de Sistemes",
    "section": "Objectius del curs",
    "text": "Objectius del curs\n\nIntroduir-vos en el món de l’administració de sistemes i aplicacions, així com en la seva gestió i manteniment.\nRepasar llenguatges de programació i scripting per a l’automatització de tasques. Bash, AWK, YAML, que ens permetran utilitzar eines com Ansible, AWS CloudFormation, Docker, Kubernetes, etc.\nApendre a gestionar, configurar i monitoritzar servidors en entorns físics i virtuals.\nIntroduir-vos en el món del Cloud Computing i les seves principals plataformes (AWS, Azure, Google Cloud).\nDesplegar serveis Web, Bases de Dades, Aplicacions i Infraestructures en diferents entorns.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Fonaments de l'Administració de Sistemes"
    ]
  },
  {
    "objectID": "slides/01-foundations-of-systems-administration.html#metodologia",
    "href": "slides/01-foundations-of-systems-administration.html#metodologia",
    "title": "Fonaments de l’Administració de Sistemes",
    "section": "Metodologia",
    "text": "Metodologia\n\nTeoria: En aquestes sessions, es presentaran els continguts teòrics de l’assignatura, que es complementaran amb exemples il·lustratius. Com a material de suport, s’utilitzaran les diapositives de l’assignatura.\nPràctiques: Aquestes sessions es basen en una metodologia activa i asincrònica que permet a cada estudiant o grup avançar al seu ritme. El contingut és autosuficient, i la funció del professor és fomentar el debat i ajudar a resoldre dubtes.\nTreball autònom: Aquesta part del curs implica la finalització dels laboratoris i l’elaboració d’informes a partir dels reptes proposats. També inclou la lectura i visualització de documentació tècnica; així com la realització d’activitats al cloud AWS.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Fonaments de l'Administració de Sistemes"
    ]
  },
  {
    "objectID": "slides/01-foundations-of-systems-administration.html#planificació-part-i",
    "href": "slides/01-foundations-of-systems-administration.html#planificació-part-i",
    "title": "Fonaments de l’Administració de Sistemes",
    "section": "Planificació Part I",
    "text": "Planificació Part I\n\n\n\n\n\n\n\n\nSet.\nDilluns\nDimecres\n\n\n\n\n1a\n-\nU1: Fonaments de l’Administració\n\n\n2a\nU2: Procés d’Arrencada i Inicialització del Sistema\nU2: Procés d’Arrencada i Inicialització\n\n\n3a\nU2: Procés d’Arrencada i Inicialització del Sistema\nU2: Procés d’Arrencada i Inicialització\n\n\n4a\nU3: Sis. de Fitxers i Emmagatzematge\nU3: Sis. de Fitxers i Emmagatzematge\n\n\n5a\nU3: Sis. de Fitxers i Emmagatzematge\nU3: Sis. de Fitxers i Emmagatzematge\n\n\n6a\nU3: Sis. de Fitxers i Emmagatzematge\nU4: Autenticació i Autorització\n\n\n7a\nU4: Autenticació i Autorització\nU4: Autenticació i Autorització\n\n\n8a\nWorkshop\nWorkshop\n\n\n9a\nPARCIALS",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Fonaments de l'Administració de Sistemes"
    ]
  },
  {
    "objectID": "slides/01-foundations-of-systems-administration.html#planificació-part-ii",
    "href": "slides/01-foundations-of-systems-administration.html#planificació-part-ii",
    "title": "Fonaments de l’Administració de Sistemes",
    "section": "Planificació Part II",
    "text": "Planificació Part II\n\n\n\nSet.\nDilluns\nDimecres\n\n\n\n\n10a\nU5: Virtualització\nU5: Virtualització\n\n\n11a\nU5: Virtualització\nU5: Virtualització\n\n\n12a\nU6: Computació en el Núvol\nU6: Computació en el Núvol\n\n\n13a\nU6: Computació en el Núvol\nU6: Computació en el Núvol\n\n\n14a\n-\nU7: Orquestració i CI/CD\n\n\n15a\nWorkshop\nWorkshop\n\n\n16a\nPARCIALS\n\n\n\n17a\n\n\n\n\n18a\n\n\n\n\n19a\nRECUPERACIONS",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Fonaments de l'Administració de Sistemes"
    ]
  },
  {
    "objectID": "slides/01-foundations-of-systems-administration.html#criteris-davaluació",
    "href": "slides/01-foundations-of-systems-administration.html#criteris-davaluació",
    "title": "Fonaments de l’Administració de Sistemes",
    "section": "Criteris d’Avaluació",
    "text": "Criteris d’Avaluació\n\n\n\n\n\n\n\n\n\n\nActivitat\nPes\nRecuperable?\nNota Mínima?\nGrup?\n\n\n\n\nExamen 1\n35%\nSí\nNo\nNo\n\n\nExamen 2\n35%\nSí\nNo\nNo\n\n\nLaboratori\n20%\nNo\nSí\nSí\n\n\nActivitats Async\n5%\nNo\nNo\nNo\n\n\nSeguiment i participació\n5%\nNo\nNo\nNo",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Fonaments de l'Administració de Sistemes"
    ]
  },
  {
    "objectID": "slides/01-foundations-of-systems-administration.html#exàmens",
    "href": "slides/01-foundations-of-systems-administration.html#exàmens",
    "title": "Fonaments de l’Administració de Sistemes",
    "section": "Exàmens",
    "text": "Exàmens\nEls exàmens parcials (E1 i E2) són proves escrites que avaluen els coneixements teòrics i pràctics adquirits durant el curs.\n\nSón proves individuals i presencials.\nEs realitzaran en les dates establertes al calendari acadèmic.\nNo es permet l’ús de cap dispositiu electrònic (telèfons mòbils, ordinadors portàtils o tauletes).\nSi es permet l’ús d’un resum de continguts, que ha de ser un document escrit a mà i no pot excedir una fulla DIN A4 (per davant i per darrere).",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Fonaments de l'Administració de Sistemes"
    ]
  },
  {
    "objectID": "slides/01-foundations-of-systems-administration.html#recuperació",
    "href": "slides/01-foundations-of-systems-administration.html#recuperació",
    "title": "Fonaments de l’Administració de Sistemes",
    "section": "Recuperació",
    "text": "Recuperació\n\nEls parcials són recuperables mitjançant proves escrites addicionals que es realitzaran durant la setmana de recuperació.\nSi un estudiant necessita recuperar un únic parcial (E1 o E2), podrà fer una prova específica per a aquest parcial. La qualificació obtinguda en aquesta recuperació substituirà la nota del parcial corresponent.\nSi un estudiant necessita recuperar ambdós parcials, haurà de realitzar dues proves separades, una per a cada parcial (E1 i E2). Les qualificacions obtingudes en cadascuna d’aquestes proves de recuperació substituiran les notes originals dels parcials respectius.\nÉs important notar que no hi haurà un model d’examen unificat per a la recuperació; cada prova de recuperació se centrarà exclusivament en els continguts del parcial al qual correspon.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Fonaments de l'Administració de Sistemes"
    ]
  },
  {
    "objectID": "slides/01-foundations-of-systems-administration.html#pràctiques",
    "href": "slides/01-foundations-of-systems-administration.html#pràctiques",
    "title": "Fonaments de l’Administració de Sistemes",
    "section": "Pràctiques",
    "text": "Pràctiques\n\nLes pràctiques de l’assignatura impliquen treball fora de l’aula i s’han de lliurar de forma estricta en les dates establertes.\nLa seva avaluació es farà mitjançant rúbriques de correcció, que estaran disponibles per als estudiants amb antelació.\nEl professorat pot entrevistar els estudiants per verificar l’autoria. Si es detecta que una activitat no ha estat realitzada per l’estudiant la seva qualificació serà 0.\nQualsevol entrega fora del termini establert es considerarà no vàlida i es qualificarà amb un 0.\nCadascuna pot tenir una ponderació específica indicada a la descripció de l’activitat.\nAquestes pràctiques no són recuperables.\nTot i ser activitats en grup, cada estudiant pot obtenir una nota diferent en funció de la seva participació i aportacions individuals al grup.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Fonaments de l'Administració de Sistemes"
    ]
  },
  {
    "objectID": "slides/01-foundations-of-systems-administration.html#activitats-asíncrones-a-aws",
    "href": "slides/01-foundations-of-systems-administration.html#activitats-asíncrones-a-aws",
    "title": "Fonaments de l’Administració de Sistemes",
    "section": "Activitats Asíncrones a AWS",
    "text": "Activitats Asíncrones a AWS\nAquestes activitats asíncrones es realitzaran a la plataforma AWS al llarg del curs. La seva finalitat és que completis totes les activitats i laboratoris proposats, ja que la qualificació es basarà íntegrament en la finalització d’aquests. Completar totes les tasques et donarà el 5% de la nota final. Si en fas només una part, la puntuació serà proporcional a les activitats que hagis realitzat.\n\nNo recuperable: Aquesta activitat no disposa de recuperació.\nData límit: La data màxima per a la presentació i finalització és el dia de l’E2.\nValor afegit: Obtenció d’un certificat oficial AWS.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Fonaments de l'Administració de Sistemes"
    ]
  },
  {
    "objectID": "slides/01-foundations-of-systems-administration.html#seguiment-i-participació",
    "href": "slides/01-foundations-of-systems-administration.html#seguiment-i-participació",
    "title": "Fonaments de l’Administració de Sistemes",
    "section": "Seguiment i Participació",
    "text": "Seguiment i Participació\n\n\n\n\n\n\n\nRúbrica d’Avaluació\n\n\n\n\n\n\n\n\n\n\n\nPunts\nParticipació Presencial\nParticipació en Fòrums\nActivitats Sessió\n\n\n\n\n10\nContribucions excepcionals,enriqueix la discussió.\nLíder en discussions, promou debat.\nQualitat excepcional, supera expectatives.\n\n\n9\nComentaris rellevants, mostra comprensió, escolta activament.\nRespostes significatives.\nAlta qualitat, treball precís.\n\n\n8\nContribucions regulars, interactua amb companys.\nPublicacions rellevants, contribueix constructivament.\nCompleix tots requisits amb precisió.\n\n\n7\nParticipa amb una comprensió bàsica.\nCompleix mínims, contribucions breus.\nQualitat inconsistent però acceptable.\n\n\n5-6\nPoca freqüència, comentaris superficials.\nPublicacions rares, poc profundes.\nAlgunes activitats incompletes.\n\n\n1-4\nNomés participa si se li demana.\nPublicacions irrellevants.\nRarament completa activitats.\n\n\n0\nEvita participar, distret.\nPublicacions fora de tema.\nNo lliura activitats.\n\n\n\n\n\n\n\n\nL’assistència passiva no es puntua.\n\n\nAquest component d’avaluació està dissenyat per fomentar la participació activa i el compromís amb l’assignatura. La participació no es limita només a l’assistència a classe, sinó que també inclou la contribució en discussions, fòrums en línia i activitats relacionades amb les sessions. Tota participació ha de ser rellevant i constructiva per ser valorada positivament. En aquesta rúbrica, es detallen els criteris específics que s’utilitzaran per avaluar la participació dels estudiants en diferents àmbits.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Fonaments de l'Administració de Sistemes"
    ]
  },
  {
    "objectID": "slides/01-foundations-of-systems-administration.html#bonus-1",
    "href": "slides/01-foundations-of-systems-administration.html#bonus-1",
    "title": "Fonaments de l’Administració de Sistemes",
    "section": "Bonus 1",
    "text": "Bonus 1\n\n\n\nObjectiu: Fomentar la reflexió i l’autoavaluació dels continguts treballats a classe.\nMetodologia: Cada setmana, els estudiants han de fer un commit al seu repositori d’apunts amb les notes de les sessions de teoria i pràctiques.\nAvaluació: Es valorarà la qualitat de les notes, la seva coherència i la seva relació amb els continguts treballats, així com les reflexions i opinions personals incloses.\nPer participar cal crear un repositori a Github (públic) i fer-me arribar l’enllaç.\n\n\n\n\nExemple de Notes\n## Setmana X\n\n# Resum teòric\n\n# Exemples pràctics\n\n# Dubtes i preguntes\n\n# Reflexions personals\n\n\n\n\n\n\n\nNo es permet cap altre forma\n\n\nLes notes han de ser escrites en format Markdown i mantingudes en un repositori Git i Github.\n\n\n\n\n\n\nAquest bonus està dissenyat per incentivar els estudiants a mantenir un registre organitzat i reflexiu dels continguts treballats a classe. En fer un commit setmanal amb les seves notes, els estudiants no només reforcen el seu aprenentatge, sinó que també desenvolupen habilitats de documentació i autoavaluació. La qualitat de les notes serà clau en l’avaluació, ja que es valorarà no només la precisió dels continguts, sinó també la capacitat de reflexionar sobre el que s’ha après i com s’ha aplicat aquest coneixement. Es tracta d’una oportinitat per als estudiants per crear el seu diari d’aprenentatge al llarg del curs. Per participar, els estudiants han de crear un repositori públic a Github i compartir l’enllaç amb el professorat.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Fonaments de l'Administració de Sistemes"
    ]
  },
  {
    "objectID": "slides/01-foundations-of-systems-administration.html#bonus-2",
    "href": "slides/01-foundations-of-systems-administration.html#bonus-2",
    "title": "Fonaments de l’Administració de Sistemes",
    "section": "Bonus 2",
    "text": "Bonus 2\n\n\n\nEls materials són Open Source.\nQualsevol estudiant pot detectar errors, millorar els materials o afegir continguts nous.\nS’avaluarà la quantitat i qualitat.\n\n\n\n\n\nUn altre bonus que oferim és la possibilitat de contribuir als materials de l’assignatura seguint la metodologia de Open Source. Això significa que qualsevol estudiant pot detectar errors, suggerir millores o afegir continguts nous als materials proporcionats. Per participar, els estudiants poden fer un fork del repositori de l’assignatura, treballar en una branca separada i després obrir una pull request amb les seves propostes de canvi. La quantitat i qualitat de les contribucions seran avaluades, oferint així una oportunitat per als estudiants de participar activament en la millora dels recursos educatius.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Fonaments de l'Administració de Sistemes"
    ]
  },
  {
    "objectID": "slides/01-foundations-of-systems-administration.html#gestió-del-curs",
    "href": "slides/01-foundations-of-systems-administration.html#gestió-del-curs",
    "title": "Fonaments de l’Administració de Sistemes",
    "section": "Gestió del curs",
    "text": "Gestió del curs\n\nEs demana que els estudiants arribin puntuals a les sessions. L’entrada tardana pot interrompre la dinàmica de la classe i el treball dels companys.\nEs demana que els estudiants respectin les normes de convivència i respecte mutu durant les sessions de classe. Això inclou evitar interrupcions innecessàries, escoltar activament als companys i al professor, i mantenir un ambient de treball positiu i constructiu.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Fonaments de l'Administració de Sistemes"
    ]
  },
  {
    "objectID": "slides/01-foundations-of-systems-administration.html#comunicació-amb-el-professorat",
    "href": "slides/01-foundations-of-systems-administration.html#comunicació-amb-el-professorat",
    "title": "Fonaments de l’Administració de Sistemes",
    "section": "Comunicació amb el professorat",
    "text": "Comunicació amb el professorat\n\nIntenteu comunicar-vos a través del correu electrònic i no per l’eina del campus virtual per assegurar una resposta més ràpida.\nLes sessions de tutoria es realitzaran de manera presencial o virtual, segons les necessitats dels estudiants. És important que els estudiants sol·licitin cita prèvia per a les tutories utilitzant el correu electrònic jordi.mateo@udl.cat indicant el motiu de la consulta i la disponibilitat horària i afegint l’assumpte [AMSA]: Sol·licitud de Tutoria.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Fonaments de l'Administració de Sistemes"
    ]
  },
  {
    "objectID": "slides/01-foundations-of-systems-administration.html#treball-individual",
    "href": "slides/01-foundations-of-systems-administration.html#treball-individual",
    "title": "Fonaments de l’Administració de Sistemes",
    "section": "Treball individual",
    "text": "Treball individual\n\nCada estudiant és responsable de la seva pròpia feina i de com gestiona el seu temps.\nL’assistència a classe no és obligatòria.\nCada alumne ha de presentar evidències pròpies del treball realitzat, encara que es col·labori en grup.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Fonaments de l'Administració de Sistemes"
    ]
  },
  {
    "objectID": "slides/01-foundations-of-systems-administration.html#ús-de-la-iag",
    "href": "slides/01-foundations-of-systems-administration.html#ús-de-la-iag",
    "title": "Fonaments de l’Administració de Sistemes",
    "section": "Ús de la IAG",
    "text": "Ús de la IAG\n\nPots utilitzar eines d’IAG per generar idees, entendre conceptes complexos o esbossar l’estructura inicial del teu codi o projecte. No obstant això, la implementació i la versió final han de ser sempre de la teva autoria.\nEstà estrictament prohibit presentar codi o solucions generades directament per una IAG com a treball propi (és a dir, mitjançant un simple copiar i enganxar).\nSi incorpores material assistit per una IAG, has de declarar-ho explícitament. Això implica identificar clarament les seccions generades per IAG i proporcionar el prompt exacte utilitzat per crear-les.\n\n\nL’incompliment d’aquestes directrius es considerarà una violació de la integritat acadèmica.\n\n\nQualificació de zero en la tasca.\nConseqüències disciplinàries que estableix la Normativa de Convivència de la UdL per frau acadèmic.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Fonaments de l'Administració de Sistemes"
    ]
  },
  {
    "objectID": "slides/01-foundations-of-systems-administration.html#eines",
    "href": "slides/01-foundations-of-systems-administration.html#eines",
    "title": "Fonaments de l’Administració de Sistemes",
    "section": "Eines",
    "text": "Eines\n\nOrdinador portàtil amb connexió a Internet.\n\nEs recomana portar el vostre propi ordinador per cursar l’assignatura.\nSi no disposeu d’ordinador, podreu utilitzar els ordinadors de la classe durant les sessions de laboratori.\n\nDistribucions Linux (Debian i AlmaLinux)\n\nÉs obligatori utilitzar les distribucions indicades als laboratoris. Altres distribucions no rebran suport.\n\nSoftware de virtualització (VMWare i QEMU)\n\nEs recomana utilitzar VMWare i QEMU, però podeu optar per altres opcions de virtualització. Heu de ser capaços d’adaptar el material al vostre programari de virtualització.\n\nCompte a AWS",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Fonaments de l'Administració de Sistemes"
    ]
  },
  {
    "objectID": "slides/01-foundations-of-systems-administration.html#materials-i-recursos",
    "href": "slides/01-foundations-of-systems-administration.html#materials-i-recursos",
    "title": "Fonaments de l’Administració de Sistemes",
    "section": "Materials i Recursos",
    "text": "Materials i Recursos\n\nApunts de l’assignatura i materials proporcionats pel professor.\nDocumentació oficial de les eines i tecnologies utilitzades.\nFòrums tècnics a la xarxa com Stack Overflow, Reddit, etc\nLlibres de referència en administració de sistemes:\n\n“UNIX and Linux System Administration Handbook” de Evi Nemeth, Garth Snyder, Trent R. Hein, Ben Whaley.\n“The Practice of System and Network Administration” de Thomas A. Limoncelli, Christina J. Hogan, Strata R. Chalup.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Fonaments de l'Administració de Sistemes"
    ]
  },
  {
    "objectID": "slides/01-foundations-of-systems-administration.html#el-rol-de-ladministrador-de-sistemes---similituds-amb-un-bomber",
    "href": "slides/01-foundations-of-systems-administration.html#el-rol-de-ladministrador-de-sistemes---similituds-amb-un-bomber",
    "title": "Fonaments de l’Administració de Sistemes",
    "section": "El rol de l’administrador de sistemes - Similituds amb un bomber",
    "text": "El rol de l’administrador de sistemes - Similituds amb un bomber\n\nEls administradors de sistemes han de tenir coneixements tècnics profunds i una actitud proactiva per anticipar problemes i, si cal, resoldre’ls sota pressió, tal com ho faria un bomber en una emergència.\n\n\n\n\n\nEl rol tradicional de l’aministrador de sistemes pot ser semblant al d’un bomber. Ha de treballar per prevenir incendis, però quan hi ha un incendi ha de córrer per apagar-lo i restaurar la situació el més ràpid. No importa l’hora, el lloc o el dia, l’administrador de sistemes ha de ser capaç de respondre a les emergències i solucionar els problemes de manera eficient i efectiva. Això requereix una gran habilitat tècnica, coneixements profunds dels sistemes i una actitud proactiva per anticipar-se als problemes i resoldre’ls ràpidament. Els administradors de sistemes han de ser tant proactius com reactius, prevenint problemes i responent ràpidament davant els imprevistos per garantir la continuïtat del servei. Poden utilitzar eines com Nagios, Zabbix, Prometheus per monitoritzar els sistemes i detectar problemes abans que es converteixin en emergències reals. Però, han d’intervenir i improvisar quan calgui per resoldre els problemes i restaurar la normalitat.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Fonaments de l'Administració de Sistemes"
    ]
  },
  {
    "objectID": "slides/01-foundations-of-systems-administration.html#el-rol-de-ladministrador-de-sistemes---similituds-amb-un-científic",
    "href": "slides/01-foundations-of-systems-administration.html#el-rol-de-ladministrador-de-sistemes---similituds-amb-un-científic",
    "title": "Fonaments de l’Administració de Sistemes",
    "section": "El rol de l’administrador de sistemes - Similituds amb un científic",
    "text": "El rol de l’administrador de sistemes - Similituds amb un científic\n\n\n\n\n\n\n\nEls administradors de sistemes han de ser capaços de resoldre problemes complexos i trobar solucions creatives.\nAixò pot ser semblant al treball d’un científic, que ha de plantejar hipòtesis, realitzar experiments i analitzar dades per arribar a conclusions.\nPer exemple, una empresa pot necessitar donar codis d’accés temporals als usuaris per connectar-se a la xarxa Wifi. En lloc de gestionar-ho manualment, un administrador de sistemes va crear un sistema que generava codis d’accés temporals quan els usuaris tocaven un platan connectada a un Raspberry Pi.\n\n\n\nUn altra característica de l’administrador de sistemes és la seva capacitat per resoldre problemes complexos i trobar solucions creatives. Això pot ser semblant al treball d’un científic, que ha de plantejar hipòtesis, realitzar experiments i analitzar dades per arribar a conclusions.\nPer exemple, una empresa pot necessitar donar codis d’accés temporals als usuaris per connectar-se a la xarxa Wifi. En lloc de gestionar-ho manualment, un administrador de sistemes va crear un sistema que generava codis d’accés temporals quan els usuaris tocaven un platan connectada a un Raspberry Pi. Aquesta solució creativa i inesperada va permetre automatitzar una tasca manual i millorar l’experiència de l’usuari. Això demostra la capacitat de l’administrador de sistemes per trobar solucions innovadores i eficients als problemes que es presenten.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Fonaments de l'Administració de Sistemes"
    ]
  },
  {
    "objectID": "slides/01-foundations-of-systems-administration.html#salari-administrador-de-sistemes",
    "href": "slides/01-foundations-of-systems-administration.html#salari-administrador-de-sistemes",
    "title": "Fonaments de l’Administració de Sistemes",
    "section": "Salari Administrador de Sistemes",
    "text": "Salari Administrador de Sistemes\n\n\n\n\n\nEl salari base segons el portal payscale a Espanya és de mitjana 30k amb un potencial de creixement a futtur de 10k. Aquesta dada és orientativa i pot variar segons la ubicació, l’experiència, les habilitats i la formació del professional. Però, en comparativa amb altres sortides professionals, l’administrador de sistemes igual no és una opció interessant. Analitzem ara sortides professionals més especialitzades.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Fonaments de l'Administració de Sistemes"
    ]
  },
  {
    "objectID": "slides/01-foundations-of-systems-administration.html#especialitzacions-en-administració-de-sistemes",
    "href": "slides/01-foundations-of-systems-administration.html#especialitzacions-en-administració-de-sistemes",
    "title": "Fonaments de l’Administració de Sistemes",
    "section": "Especialitzacions en Administració de Sistemes",
    "text": "Especialitzacions en Administració de Sistemes\n\n\n\nAdministradors de Xarxa, Enmagatzematge, Seguretat\nOperadors de Xarxa\nArquitectes de Sistemes\nTècnics de Suport\nTècnics de Centre de Dades\nEnginyers de Sistemes\nEnginyer DEVOPS\nEnginyer SRE (Site Reliability Engineer)\n\n\n\n\n\nHi ha una gran varietat d’especialitzacions dins l’àmbit de l’administració de sistemes, cada una amb responsabilitats úniques que poden influir en el salari i els rols. A continuació, detallem algunes d’aquestes especialitzacions:\n\nAdministradors de Xarxa: S’encarreguen de la configuració, gestió i manteniment de routers, switches, firewalls i altres dispositius de xarxa en entorns físics i virtuals. La seva tasca és garantir la connectivitat i seguretat de les xarxes de l’empresa.\nAdministradors de Emmagatzematge: Gestionen sistemes de fitxers, solucions de còpies de seguretat i tecnologies d’emmagatzematge de dades com NETAPP o EMC. Són responsables d’assegurar que les dades estiguin segures i accessibles.\nAdministradors de Seguretat: Protegeixen els sistemes informàtics contra amenaces i atacs cibernètics. Implementen polítiques de seguretat, gestionen certificats digitals i realitzen auditories de seguretat per protegir la informació sensible.\nOperadors de Xarxa: Supervisionen el funcionament diari de les xarxes, gestionant el trànsit de dades i resolent problemes de connexió o rendiment. S’asseguren que les xarxes funcionin sense interrupcions.\nArquitectes de Sistemes: Dissenyen i planifiquen la infraestructura tecnològica de l’empresa. Són responsables d’assegurar que els sistemes compleixin els requisits de rendiment, seguretat i escalabilitat.\nTècnics de Suport: Ofereixen assistència tècnica als usuaris, resolent problemes i incidents a través de sistemes de tickets. La seva tasca és garantir que els usuaris puguin utilitzar les tecnologies sense problemes.\n\n-Tècnics de Centre de Dades: Gestionen i mantenen els servidors, xarxes i altres equips físics en els centres de dades. S’asseguren que el centre de dades funcioni amb alta disponibilitat i rendiment.\n\nEnginyers de Sistemes: Són responsables de dissenyar, implementar i mantenir la infraestructura informàtica de l’empresa. La seva tasca és assegurar que els sistemes compleixin els requisits operatius i tècnics.\n\nAra veurem dues especialitzacions més avançades i amb més demanda en el mercat laboral actual: Enginyer DEVOPS i Enginyer SRE (Site Reliability Engineer) amb detall. També us deixo un enllaç a un llibre que parla de les diferents especialitzacions.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Fonaments de l'Administració de Sistemes"
    ]
  },
  {
    "objectID": "slides/01-foundations-of-systems-administration.html#què-és-un-site-reliability-engineer-sre",
    "href": "slides/01-foundations-of-systems-administration.html#què-és-un-site-reliability-engineer-sre",
    "title": "Fonaments de l’Administració de Sistemes",
    "section": "Què és un Site Reliability Engineer (SRE)?",
    "text": "Què és un Site Reliability Engineer (SRE)?\nEls Site Reliability Engineers (SRE) són enginyers de sistemes especialitzats en la fiabilitat i l’escalabilitat dels sistemes informàtics. Estan centrats en les operacions, utilitzant el software com a eina per gestionar els sistemes, solucionar els afers i automatitzar tasques. Les seves missions són crear sistemes escalables i fiables.\n\nFiabilitat del Sistema: Nagios, Zabbix, Prometheus.\nEscalabilitat: Kubernetes, Docker, Terraform.\nMonitorització i Alertes: Grafana, ELK Stack, PagerDuty.\nGestió d’Incidents: Jira, ServiceNow, Slack.\nOptimització de Rendiment: New Relic, Datadog, AppDynamics.\nAutomatització de Processos: Ansible, Puppet, Chef.\n\n\nAmb l’evolució contínua de les tecnologies cloud i l’augment de la demanda de serveis digitals, les pràctiques de Site Reliability Engineering (SRE) s’han convertit en una peça clau per a moltes organitzacions. Un SRE es pot definir com un professional especialitzat en garantir que les empreses compleixin els seus Acords de Nivell de Servei (SLA) pel que fa a disponibilitat, rendiment, experiència de l’usuari i indicadors clau de negoci (KPIs). Això implica centrar-se en la millora de la fiabilitat i l’escalabilitat dels sistemes, així com en la implementació de pràctiques d’integració i lliurament continu (CI/CD), reforçar la seguretat i optimitzar els costos operatius.\nEls SREs aprofiten el programari com una eina per gestionar i automatitzar els sistemes, identificar i resoldre problemes, i automatitzar processos amb l’objectiu final de construir infraestructures escalables i fiables que responguin als objectius de negoci.\nLes funcions principals d’un SRE inclouen la monitorització constant dels sistemes, la gestió d’alertes i resposta a incidents, l’automatització de tasques rutinàries, i l’optimització de l’escala i adaptabilitat dels recursos tecnològics. A més, col·laboren estretament amb els equips de desenvolupament per assegurar la millora contínua de la fiabilitat i el rendiment dels sistemes.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Fonaments de l'Administració de Sistemes"
    ]
  },
  {
    "objectID": "slides/01-foundations-of-systems-administration.html#salari-dun-site-reliability-engineer",
    "href": "slides/01-foundations-of-systems-administration.html#salari-dun-site-reliability-engineer",
    "title": "Fonaments de l’Administració de Sistemes",
    "section": "Salari d’un Site Reliability Engineer",
    "text": "Salari d’un Site Reliability Engineer\n\n\n\n\n\nEls Site Reliability Engineers (SREs) experimenten un increment salarial substancial en comparació amb els administradors de sistemes. Un SRE pot començar guanyant fins a 50.000 € durant el seu primer any, i amb l’experiència, arribar fins als 70.000 € o més en un termini de cinc anys. Aquest diferencial salarial reflecteix la creixent importància i demanda de professionals especialitzats en la fiabilitat i escalabilitat dels sistemes informàtics. A diferència dels administradors de sistemes, els SREs no només es dediquen a mantenir la infraestructura, sinó que també se centren en optimitzar la resiliència i eficiència dels serveis digitals, assegurant que compleixin els Acords de Nivell de Servei (SLA). Per tant, si t’interessa un rol amb responsabilitats més tècniques i un potencial de creixement major, el camí d’SRE pot ser una opció molt atractiva dins del mercat laboral actual. Les seves responsabilitats dins de l’empresa són molt importants i tenen un impacte directe amb els objectius de negoci.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Fonaments de l'Administració de Sistemes"
    ]
  },
  {
    "objectID": "slides/01-foundations-of-systems-administration.html#què-és-un-devops-engineer",
    "href": "slides/01-foundations-of-systems-administration.html#què-és-un-devops-engineer",
    "title": "Fonaments de l’Administració de Sistemes",
    "section": "Què és un DevOps Engineer?",
    "text": "Què és un DevOps Engineer?\nEls DevOps Engineers són professionals clau en la integració i col·laboració entre els equips de desenvolupament (Dev) i operacions (Ops), amb l’objectiu principal de millorar l’eficiència i agilitat dels processos de desenvolupament de software. El seu treball se centra en accelerar el desplegament d’aplicacions, millorar la qualitat del software i optimitzar els fluxos de treball, fent ús intensiu de l’automatització, la integració contínua (CI) i el lliurament continu (CD).\n\nAutomatització: Jenkins, GitLab CI, Bamboo.\nGestió d’infraestructura com a codi (IaC): Terraform, Ansible, CloudFormation.\nContenidors i orquestració: Docker, Kubernetes.\nMonitorització i registre: Prometheus, Grafana, ELK Stack.\nCol·laboració i comunicació: Slack, Jira, Confluence.\n\n\nMentre que els Sysadmins tradicionalment s’ocupen de la gestió i manteniment de la infraestructura, com ara servidors, xarxes i sistemes operatius, els DevOps Engineers van més enllà d’aquestes tasques. El seu rol inclou l’automatització de processos, la implementació de pipelines de CI/CD, la gestió de contenidors (com Docker) i la infraestructura com a codi (IaC), com Terraform o Ansible. En lloc d’enfocar-se només en el manteniment i la disponibilitat dels sistemes, els DevOps Engineers treballen per integrar millor el desenvolupament i les operacions, assegurant que els nous llançaments de software siguin ràpids, segurs i consistents.\nTot i que hi ha solapaments entre DevOps i SRE, les diferències clau radican en l’enfocament i les prioritats. Mentre que els DevOps Engineers se centren en l’optimització dels processos de desenvolupament i operacions a través de la col·laboració i l’automatització, els SREs estan més orientats a la fiabilitat i escalabilitat dels sistemes en producció. El SRE té un enfocament més específic en mantenir els serveis en línia, gestionant incidents, optimitzant el rendiment i assegurant-se que es compleixen els SLA. Tot i que ambdós rols treballen amb eines similars, com CI/CD i contenidors, els SREs tenen més responsabilitats en la resolució d’incidents crítics i en la millora de la resiliència del sistema.\nCom podeu veure les eines tecnològiques que utilitzen els DevOps Engineers són molt similars a les dels SREs, però la seva aplicació i objectius són diferents. Per tant, apunteu-vos aquestes eines i tecnologies, ja que són essencials pel món laboral actual.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Fonaments de l'Administració de Sistemes"
    ]
  },
  {
    "objectID": "slides/01-foundations-of-systems-administration.html#salari-dun-devops-engineer",
    "href": "slides/01-foundations-of-systems-administration.html#salari-dun-devops-engineer",
    "title": "Fonaments de l’Administració de Sistemes",
    "section": "Salari d’un DevOps Engineer",
    "text": "Salari d’un DevOps Engineer\n\n\n\n\n\nEls DevOps Engineers, igual que els SREs, gaudeixen d’un salari més alt i d’un major potencial de creixement professional en comparació amb els administradors de sistemes tradicionals. Si t’apassiona l’administració de sistemes enfocada a l’automatització del desplegament de software, el disseny i la gestió de pipelines de CI/CD, l’ús de contenidors i la implementació d’infraestructura com a codi, el rol de DevOps Engineer pot oferir-te una carrera més atractiva i plena d’oportunitats. En l’actualitat, moltes empreses busquen professionals amb habilitats en DevOps.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Fonaments de l'Administració de Sistemes"
    ]
  },
  {
    "objectID": "slides/01-foundations-of-systems-administration.html#transfomració-del-administrador-de-sistemes-a-sre",
    "href": "slides/01-foundations-of-systems-administration.html#transfomració-del-administrador-de-sistemes-a-sre",
    "title": "Fonaments de l’Administració de Sistemes",
    "section": "Transfomració del Administrador de Sistemes a SRE",
    "text": "Transfomració del Administrador de Sistemes a SRE\n\n\n\n\nDamon Edwards, co-fundador de Rundeck, parla de la transformació d’un administrador de sistemes a un Site Reliability Engineer (SRE) i com aquesta evolució pot ajudar a millorar la fiabilitat dels sistemes i la productivitat dels equips de desenvolupament. Aquesta xerrada va ser presentada a la DevOpsCon 2019.\n\n\nEn aquest curs, veure una pinzellada de les tasques d’un SRE i d’un DevOps Engineer quan introduïm les eines de monitorització, automatització i CI/CD. Però, si voleu aprofundir en la temàtica, us recomano aquesta xerrada de la DevOpsCon, per Damon Edwarks, que parla del tema i explica com un administrador de sistemes es pot transformar en un SRE tenint en compte una responsabilitat compartida entre els SLOs i els errors de pressupost.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Fonaments de l'Administració de Sistemes"
    ]
  },
  {
    "objectID": "slides/01-foundations-of-systems-administration.html#arquitectura-client-servidor",
    "href": "slides/01-foundations-of-systems-administration.html#arquitectura-client-servidor",
    "title": "Fonaments de l’Administració de Sistemes",
    "section": "Arquitectura Client-Servidor",
    "text": "Arquitectura Client-Servidor\nUna arquitectura client-servidor involucra uns sistemes que necessiten serveis i uns servidors que processen i responen a aquestes peticions.\n\n\nClient\nUn ordinador o dispositiu capaç de rebre informació o utilitzar un servei o proveïdor.\nServidor\nUn ordinador o dispositiu remot capaç de proveir accés a un servei o a informació.\n\n\n\n\nUn dels conceptes més importants en l’administració de sistemes és l’arquitectura client-servidor. Aquesta arquitectura implica la interacció entre dos tipus de sistemes: els clients, que sol·liciten serveis o informació, i els servidors, que processen i responen a aquestes peticions. Aquesta arquitectura és àmpliament utilitzada en entorns informàtics, com ara la web, les xarxes d’ordinadors i les aplicacions empresarials.\nPer exemple, quan un usuari accedeix a una pàgina web, el seu navegador actua com a client i sol·licita la pàgina al servidor web. El servidor de DNS consulta la URL i retorna l’adreça IP del servidor web. El navegador envia una petició HTTP o HTTPS al servidor web, que respon amb els fitxers necessaris per mostrar la pàgina al navegador. Aquest procés implica la comunicació entre el client i el servidor per proporcionar la informació sol·licitada a l’usuari.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Fonaments de l'Administració de Sistemes"
    ]
  },
  {
    "objectID": "slides/01-foundations-of-systems-administration.html#característiques-client-servidor",
    "href": "slides/01-foundations-of-systems-administration.html#característiques-client-servidor",
    "title": "Fonaments de l’Administració de Sistemes",
    "section": "Característiques Client-Servidor",
    "text": "Característiques Client-Servidor\n\n\nAvantatges\n\nSistema centralitzat Totes les dades en un lloc.\nPolítiques de recuperació de dades.\nSeparació de la lògica.\n\n\n\n\nInconvenients\n\nAtacs de denegació de serveis.\nMan-in-the-middle.\nPhishing.\nSpoofing.\n\n\n\nAquesta arquitectura té avantatges i inconvenients. Entre els avantatges es troba la centralització de les dades, ja que tota la informació es troba en un únic lloc, el que facilita la gestió i la recuperació de les dades. A més, permet establir polítiques de recuperació de dades i separar la lògica de negoci de la interfície d’usuari, el que facilita la gestió i el manteniment del sistema. D’aquesta manera, els desenvolupadors poden centrar-se en la lògica de negoci sense preocupar-se de la interfície d’usuari. Per exemple, en una aplicació web, la lògica de negoci es pot gestionar al servidor, mentre que la interfície d’usuari es pot gestionar al client.\nEls principals inconvenients d’aquesta arquitectura són els possibles atacs de denegació de serveis, els atacs de l’home al mig, el phishing i l’usurpació d’identitat. Aquests atacs poden comprometre la seguretat del sistema i posar en perill la informació dels usuaris. Per tant, és important implementar mesures de seguretat per protegir el sistema i les dades dels usuaris. Un atac de denegació de servei enviarà moltes peticions al servidor per saturar-lo i fer-lo caure. Un atac de l’home al mig intercepta les comunicacions entre el client i el servidor per obtenir informació sensible. El phishing és un atac en què els atacants envien correus electrònics falsos per enganyar els usuaris i obtenir informació confidencial. L’usurpació d’identitat implica fer-se passar per una altra persona per obtenir accés a informació o recursos sensibles. Per tant, és molt imporant ser conscients d’aquests riscos i implementar mesures de seguretat per protegir el sistema i les dades dels usuaris.\nA la figura s’observa com múltiples clients es comuniquen amb un servidor central per obtenir informació o serveis. I com multiples servidors poden comunicar-se amb altres servidors per obtenir informació o serveis. També 1 client pot comunicar-se amb múltiples servidors. Per exemple, un client pot accedir a un servidor web per obtenir informació i a un servidor de correu per enviar correus electrònics. El servidor web pot comunicar-se amb el servidor de correu per enviar notificacions als usuaris.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Fonaments de l'Administració de Sistemes"
    ]
  },
  {
    "objectID": "slides/01-foundations-of-systems-administration.html#servidors-més-comuns",
    "href": "slides/01-foundations-of-systems-administration.html#servidors-més-comuns",
    "title": "Fonaments de l’Administració de Sistemes",
    "section": "Servidors més comuns",
    "text": "Servidors més comuns\n\n\n\nServidor d’autenticació.\nServidor de fitxers.\nServidor de discos.\nServidor de correu.\nServidor de base de dades.\n\n\n\nServidor SSH.\nServidor Web.\nServidor d’aplicacions.\nServidor de backups.\nServidor de còmput.\n\n\n\nHi ha molts tipus de servidors en funció de l’objectiu que tenen. Alguns dels servidors més comuns són els servidors d’autenticació, que s’encarreguen de gestionar l’accés dels usuaris als sistemes; els servidors de fitxers, que emmagatzemen i gestionen els fitxers i documents de l’empresa; els servidors de discos, que proporcionen emmagatzematge addicional als servidors; els servidors de correu, que gestionen el correu electrònic de l’empresa; els servidors de base de dades, que emmagatzemen i gestionen les dades de l’empresa; els servidors SSH, que permeten l’accés remot als servidors; els servidors web, que allotgen les pàgines web de l’empresa; els servidors d’aplicacions, que executen les aplicacions de l’empresa; els servidors de backups, que realitzen còpies de seguretat de les dades de l’empresa; i els servidors de còmput, que realitzen càlculs i processos computacionals entre altres.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Fonaments de l'Administració de Sistemes"
    ]
  },
  {
    "objectID": "slides/01-foundations-of-systems-administration.html#exemple-darquitectura-escalable",
    "href": "slides/01-foundations-of-systems-administration.html#exemple-darquitectura-escalable",
    "title": "Fonaments de l’Administració de Sistemes",
    "section": "Exemple d’arquitectura escalable",
    "text": "Exemple d’arquitectura escalable\n\n\n\n\nA la figura proporcionada es mostra una arquitectura típicament utilitzada per al desplegament d’una web escalable i fiable. En aquesta arquitectura, el punt d’entrada és un balancejador de càrrega, que distribueix les peticions entre els diversos servidors web. Els servidors web, que poden ser rèpliques, allotgen les pàgines web i gestionen les peticions dels usuaris. Aquestes pàgines web necessiten accedir a un servidor de base de dades per emmagatzemar i gestionar les dades associades. Cada base de dades està protegida per un servidor de backups, que realitza còpies de seguretat per garantir la recuperació en cas de fallades. A més, per millorar la velocitat de càrrega de les pàgines web, es fa servir un dispositiu CDN (Content Delivery Network) que redirigeix les peticions als servidors més propers a l’usuari.\nAquesta arquitectura és àmpliament utilitzada per allotjar llocs webs, ja que ofereix una combinació d’escalabilitat i fiabilitat, assegurant un rendiment òptim i una alta disponibilitat per als usuaris finals.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Fonaments de l'Administració de Sistemes"
    ]
  },
  {
    "objectID": "slides/01-foundations-of-systems-administration.html#problemes-més-comuns-servidors-i",
    "href": "slides/01-foundations-of-systems-administration.html#problemes-més-comuns-servidors-i",
    "title": "Fonaments de l’Administració de Sistemes",
    "section": "Problemes més comuns servidors (I)",
    "text": "Problemes més comuns servidors (I)\n\nQui i com accedeix a la informació?\n\nDeterminar qui (usuari,procés,servei) pot accedir a quins fitxers i directoris i com ho pot fer (lectura, escriptura, execució).\nPermisos, ACLs, polítiques de seguretat.\n\nCom protegeixo la informació?\n\nDeterminar com protegir la informació sensible i confidencial.\nEncriptació, contrasenyes, autenticació, autorització, auditoria, backups.\n\nCom asseguro el sistema?\n\nProtegir el sistema contra atacs i amenaces.\nFirewall, IDS/IPS, antivirus, actualitzacions, patches, hardening.\n\n\n\nUn dels problemes més comuns en els servidors és determinar qui i com accedeix a la informació. Això implica definir qui (usuari, procés, servei) pot accedir a quins fitxers i directoris i com ho pot fer (lectura, escriptura, execució). Per fer-ho, es poden utilitzar permisos, llistes de control d’accés (ACLs) i polítiques de seguretat per garantir que només els usuaris autoritzats puguin accedir a la informació.\nUn altre problema comú és com protegir la informació sensible i confidencial. Això implica determinar com protegir la informació per evitar l’accés no autoritzat. Per fer-ho, es poden utilitzar tècniques com l’encriptació, les contrasenyes, l’autenticació, l’autorització, l’auditoria i els backups per garantir la seguretat i la privacitat de la informació.\nUn altre problema és com assegurar el sistema contra atacs i amenaces. Això implica protegir el sistema contra atacs externs i interns que puguin comprometre la seguretat i la integritat del sistema. Per fer-ho, es poden utilitzar eines com el firewall, els sistemes de detecció i prevenció d’intrusions (IDS/IPS), l’antivirus, les actualitzacions, els patches i el hardening per garantir la seguretat del sistema.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Fonaments de l'Administració de Sistemes"
    ]
  },
  {
    "objectID": "slides/01-foundations-of-systems-administration.html#problemes-més-comuns-servidors-ii",
    "href": "slides/01-foundations-of-systems-administration.html#problemes-més-comuns-servidors-ii",
    "title": "Fonaments de l’Administració de Sistemes",
    "section": "Problemes més comuns servidors (II)",
    "text": "Problemes més comuns servidors (II)\n\nCom puc saber si el client és qui diu ser?\n\nAutenticar els usuaris i els dispositius.\nContrasenyes, certificats digitals, autenticació multifactorial.\n\nQuins avantatges/inconvenients té un disseny respecte a un altre?\n\nDeterminar quin disseny és més adequat per a les necessitats de l’empresa.\nEscalabilitat, rendiment, seguretat, disponibilitat, fiabilitat.\n\nCom asseguro el bon funcionament?\n\nGarantir que el sistema funcioni correctament i sense problemes.\nMonitorització, alertes, backups, redundància, tolerància a fallades.\n\n\n\nUn altre problema és com autenticar els usuaris i els dispositius per garantir que siguin qui diuen ser. Això implica autenticar els usuaris i els dispositius per garantir que només els usuaris autoritzats puguin accedir a la informació. Per fer-ho, es poden utilitzar tècniques com les contrasenyes, els certificats digitals i l’autenticació multifactorial per garantir la seguretat i la privacitat de la informació.\nUn altre problema comú és determinar quins avantatges i inconvenients té un disseny respecte a un altre. Això implica determinar quin disseny és més adequat per a les necessitats de l’empresa en termes d’escalabilitat, rendiment, seguretat, disponibilitat i fiabilitat. Per fer-ho, es poden avaluar els avantatges i inconvenients de cada disseny per garantir que s’adeqüi a les necessitats de l’empresa.\nUn altre problema és com assegurar el bon funcionament del sistema. Això implica garantir que el sistema funcioni correctament i sense problemes. Per fer-ho, es poden utilitzar tècniques com la monitorització, les alertes, els backups, la redundància i la tolerància a fallades per garantir que el sistema funcioni correctament i sense problemes.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Fonaments de l'Administració de Sistemes"
    ]
  },
  {
    "objectID": "slides/01-foundations-of-systems-administration.html#problemes-més-comuns-servidors-iii",
    "href": "slides/01-foundations-of-systems-administration.html#problemes-més-comuns-servidors-iii",
    "title": "Fonaments de l’Administració de Sistemes",
    "section": "Problemes més comuns servidors (III)",
    "text": "Problemes més comuns servidors (III)\n\nCom dissenyo polítiques i plans d’emergència si tot falla?\n\nPreparar-se per a situacions d’emergència i desastres.\nPlans de contingència, plans de recuperació, plans de resposta a incidents.\n\nCom analitzo post-mortem les causes d’un atac?\n\nIdentificar les causes d’un atac i prendre mesures correctives.\nAnàlisi forense, auditoria, millora contínua.\n\n\n\nUn altre problema és com dissenyar polítiques i plans d’emergència si tot falla. Això implica preparar-se per a situacions d’emergència i desastres per garantir la continuïtat del negoci. Per fer-ho, es poden utilitzar plans de contingència, plans de recuperació i plans de resposta a incidents per garantir que l’empresa pugui respondre de manera eficaç a situacions d’emergència i desastres.\nFinalment, un altre problema és com analitzar post-mortem les causes d’un atac per identificar les causes i prendre mesures correctives. Això implica realitzar una anàlisi forense, una auditoria i una millora contínua per identificar les causes d’un atac i prendre mesures correctives per evitar que es repeteixin en el futur.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Fonaments de l'Administració de Sistemes"
    ]
  },
  {
    "objectID": "slides/01-foundations-of-systems-administration.html#què-és-un-centre-de-dades",
    "href": "slides/01-foundations-of-systems-administration.html#què-és-un-centre-de-dades",
    "title": "Fonaments de l’Administració de Sistemes",
    "section": "Què és un centre de dades?",
    "text": "Què és un centre de dades?\nÉs una instal·lació que allotja un conjunt de servidors i equipament de xarxa (recursos heterogenis) per proporcionar recursos informàtics a diverses aplicacions i serveis (càrregues de treball diverses).\n\n\n\n\nEsquema d’un centre dades\n\n\n\n\nUn centre de dades o data center és un espai físic on s’allotgen els servidors, els dispositius de xarxa i altres equips informàtics necessaris per emmagatzemar, processar i distribuir la informació. Aquests centres de dades poden ser propis de l’empresa o externs, i poden ser gestionats per l’empresa o per un proveïdor de serveis. Els centres de dades són essencials per a les empreses que necessiten emmagatzemar i processar grans quantitats de dades, ja que proporcionen l’espai, la infraestructura i els recursos necessaris per garantir el funcionament dels sistemes informàtics.\nUn exemple notable de reutilització d’estructures per a centres de dades és l’ús d’edificis històrics com esglésies i mines abandonades. Aquests espais, amb les seves condicions úniques i sovint amb una infraestructura sòlida, són adaptats per allotjar servidors i equips. Per exemple, l’antiga església de Saint-Ouen a França ha estat convertida en un centre de dades, aprofitant la seva estructura i espai per complir amb els requisits tecnològics moderns. D’altra banda, la mina de carboni de Pionen a Suècia ha estat transformada en un centre de dades subterrani, oferint una protecció física addicional contra desastres naturals i atacs.\nGoogle disposa de servidors al fons del mar, aprofitant l’energia de les ones per refredar els servidors i reduir el consum energètic. Aquesta innovadora solució aprofita els recursos naturals per millorar l’eficiència energètica dels centres de dades i reduir l’impacte ambiental. Aquestes iniciatives mostren la diversitat de solucions i enfoques per a la gestió de centres de dades, adaptant-se a les necessitats i condicions específiques de cada empresa.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Fonaments de l'Administració de Sistemes"
    ]
  },
  {
    "objectID": "slides/01-foundations-of-systems-administration.html#què-és-un-rack",
    "href": "slides/01-foundations-of-systems-administration.html#què-és-un-rack",
    "title": "Fonaments de l’Administració de Sistemes",
    "section": "Què és un rack?",
    "text": "Què és un rack?\nUn rack és una estructura metàl·lica que allotja servidors, switches, routers i altres equips informàtics en un centre de dades.\n\n\n\n\nRacks del CPD de la UdL\n\n\n\n\nUn rack és una estructura metàl·lica que allotja servidors, switches, routers i altres equips informàtics en un centre de dades. Aquests racks permeten organitzar i protegir els equips informàtics, així com facilitar la gestió dels cables i la refrigeració dels equips. Cada rack pot contenir diversos servidors, switches i altres equips, i es pot apilar verticalment per aprofitar l’espai disponible al centre de dades. A més, els racks disposen de panells laterals i portes per protegir els equips i garantir la seguretat dels servidors i altres equips informàtics.\nPer exemple, a la imatge us mostro els racks d’un passadís del centre de dades de la Universitat de Lleida, on es poden aquests armaris, penseu que cada rack pot contenir diversos servidors, switches i altres equips informàtics, i únciament es veu un dels múltiples passadissos del centre de dades. En aquest centre de dades és on tenim el Campus Virtual, les eines i dades dels estudiants i professors, així com els servidors de recerca dels grups de recerca de la UdL, entre d’altres.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Fonaments de l'Administració de Sistemes"
    ]
  },
  {
    "objectID": "slides/01-foundations-of-systems-administration.html#exemple-de-racks",
    "href": "slides/01-foundations-of-systems-administration.html#exemple-de-racks",
    "title": "Fonaments de l’Administració de Sistemes",
    "section": "Exemple de racks",
    "text": "Exemple de racks\n\n\n\n\n\n\nRack 1 - GCD - Davant\n\n\n\n\n\n\n\n\n\n\nRack 1 - GCD - Darrera\n\n\n\n\n\nAra us mostro un rack, en concret els servidors són del grup de recerca en computació distribuïda. A la part de dalt es pot veure un switch, i la resta só servidors. A la part de davant es poden veure els servidors i a la part de darrera els cables de xarxa i alimentació. En aquest cas, hi ha diferents colors de cables per identificar la xarxa a la qual pertanyen i la seva funció.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Fonaments de l'Administració de Sistemes"
    ]
  },
  {
    "objectID": "slides/01-foundations-of-systems-administration.html#exemple-de-servidor",
    "href": "slides/01-foundations-of-systems-administration.html#exemple-de-servidor",
    "title": "Fonaments de l’Administració de Sistemes",
    "section": "Exemple de servidor",
    "text": "Exemple de servidor\n\n\n\n\n\n\nExterior d’un servidor\n\n\n\n\n\n\n\n\n\n\nInterior d’un servidor\n\n\n\n\n\nEn aquestes imatges podem fer zoom i veure els components exteriors i interiors d’un servidor. A la imatge 8 es pot veure com cada disc té un indicador de color per identificar el disc en cas de fallada. A la imatge 9 es pot veure la placa base, els discos durs, la font d’alimentació, la memòria RAM i el processador.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Fonaments de l'Administració de Sistemes"
    ]
  },
  {
    "objectID": "slides/01-foundations-of-systems-administration.html#què-és-un-switch",
    "href": "slides/01-foundations-of-systems-administration.html#què-és-un-switch",
    "title": "Fonaments de l’Administració de Sistemes",
    "section": "Què és un switch?",
    "text": "Què és un switch?\nUn switch és un dispositiu de xarxa que connecta diversos equips informàtics per permetre la comunicació entre ells.\n\n\n\n\nSwitch\n\n\n\n\nUn switch és un dispositiu de xarxa que connecta diversos equips per facilitar la comunicació entre ells. Cada switch utilitza una taula de comutació per dirigir les dades cap al destinatari correcte. Aquesta taula permet al switch conèixer quins equips estan connectats a quins ports i escollir la millor ruta per enviar les dades. Els ports del switch es poden configurar per assignar-los a VLANs (Xarxes Locals Virtuals), la qual cosa permet segmentar la xarxa en diverses sub-xarxes, millorant així la seguretat i el rendiment global de la xarxa.\nNo confondre un switch amb un router. Un switch connecta diversos equips dins de la mateixa xarxa local, mentre que un router connecta diverses xarxes locals o xarxes WAN (Xarxes d’Àrea Ampliada). Els routers utilitzen taula de rutes per determinar la millor ruta per enviar les dades entre xarxes, mentre que els switches utilitzen taula de comutació per enviar les dades entre equips dins de la mateixa xarxa local.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Fonaments de l'Administració de Sistemes"
    ]
  },
  {
    "objectID": "slides/01-foundations-of-systems-administration.html#característiques-dun-sistema",
    "href": "slides/01-foundations-of-systems-administration.html#característiques-dun-sistema",
    "title": "Fonaments de l’Administració de Sistemes",
    "section": "Característiques d’un sistema",
    "text": "Característiques d’un sistema\n\nSimplicitat\nEscalabilitat\nSeguretat\nFiabilitat\nDisponibilitat\nRendiment\nFacilitat d’ús\n\n\nEn el disseny de sistemes informàtics, és important tenir en compte diverses característiques per garantir que el sistema sigui eficient, segur i fiable. Algunes de les característiques més importants d’un sistema són la simplicitat, l’escalabilitat, la seguretat, la fiabilitat, la disponibilitat, el rendiment i la facilitat d’ús. Ara bé, sovint intentem dotar sistemes amb característiques que no es poden afegir després de la seva construcció. Per exemple, intentar aplicar “seguretat” després que les interfícies del sistema hagin estat definides produeix restriccions i limitacions; intentar fer un sistema amb limitacions intrínseques funcionar en circumstàncies per les quals no va ser dissenyat produeix “hacks” i “workarounds” i el resultat final sovint essembla més una casa de cartes fràgil que una estructura sòlida i fiable.\nPer tant, quan discutim sobre el disseny de sistemes informàtics, és important tenir en compte aquestes característiques i assegurar-nos que el sistema compleixi els objectius de l’empresa i sigui capaç de respondre a les necessitats dels usuaris",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Fonaments de l'Administració de Sistemes"
    ]
  },
  {
    "objectID": "slides/01-foundations-of-systems-administration.html#què-és-lescalabilitat",
    "href": "slides/01-foundations-of-systems-administration.html#què-és-lescalabilitat",
    "title": "Fonaments de l’Administració de Sistemes",
    "section": "Què és l’escalabilitat?",
    "text": "Què és l’escalabilitat?\n\n\nL’escalabilitat és la capacitat d’un sistema per gestionar un augment de la càrrega de treball sense afectar el rendiment.\n\nVertical: augmentar la capacitat d’un servidor afegint més recursos (CPU, memòria, disc).\nHoritzontal: augmentar la capacitat d’un sistema afegint més servidors.\n\n\n\n\n\nEscalabilitat\n\n\n\n\n\n\n\n\n\n\n\n\nExemple\n\n\nEl serveis al núvol permeten pagar només pel que s’utilitza, permetent augmentar o disminuir la capacitat segons les necessitats. Et permet estirar els recursos tecnològics com un globus d’aire calent, augmentant la capacitat quan és necessari i reduint-la quan ja no és necessari.\n\n\n\n\n\nEscalabilitat es refereix a la capacitat d’un sistema per gestionar un augment en la càrrega de treball sense que el seu rendiment es vegi afectat. És un concepte clau en el disseny de sistemes informàtics, especialment en entorns amb variacions en la demanda. Aquesta capacitat s’aconsegueix mitjançant dues estratègies principals:\n\nEscalabilitat Vertical: Consisteix en millorar la capacitat d’un servidor afegint més recursos com CPU, memòria o disc. Això permet que un servidor maneje una càrrega de treball més gran sense necessitat d’addicional hardware.\nEscalabilitat Horitzontal: Consisteix en augmentar la capacitat del sistema afegint més servidors. Això distribueix la càrrega de treball entre diversos servidors, millorant la capacitat global del sistema.\n\nEn l’entorn de cloud computing, aquest concepte es relaciona sovint amb elasticitat, que és la capacitat d’un sistema per adaptar-se de manera dinàmica a les fluctuacions de la càrrega de treball. Per exemple, una botiga en línia podria experimentar un augment significatiu de trànsit durant el Black Friday. Un sistema escalable i elàstic podria gestionar aquest augment de demanda sense perdre rendiment, i després reduir la capacitat quan la demanda torna a nivells normals.\nL’objectiu és garantir que el sistema pugui mantenir un rendiment òptim i evitar problemes com temps d’espera llargs, errors o caigudes, que podrien afectar negativament l’experiència de l’usuari i els resultats comercials.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Fonaments de l'Administració de Sistemes"
    ]
  },
  {
    "objectID": "slides/01-foundations-of-systems-administration.html#què-és-la-fiabilitat",
    "href": "slides/01-foundations-of-systems-administration.html#què-és-la-fiabilitat",
    "title": "Fonaments de l’Administració de Sistemes",
    "section": "Què és la fiabilitat?",
    "text": "Què és la fiabilitat?\nLa fiabilitat d’un sistema es refereix a la seva capacitat per operar sense interrupcions durant un període determinat. La fiabilitat es mesura habitualment mitjançant el MTBF (Mean Time Between Failures), que indica el temps mitjà que un sistema pot funcionar abans de fallar. Per exemple, si un sistema té un MTBF de 1000 hores, això vol dir que, de mitjana, es pot esperar que el sistema falli cada 1000 hores d’ús.\n\n\\[ MTBF = \\frac{Temps\\ total\\ de\\ funcionament}{Nombre\\ de\\ fallades} \\]\n\n\nPer millorar la fiabilitat i minimitzar les interrupcions, es poden implementar tècniques com la redundància. Un exemple comú és l’ús de servidors en configuració de calent i fred:\n\nServidor en calent: És el servidor principal que està en funcionament i gestionant les operacions actuals.\nServidor en fred: És un servidor de reserva que es manté en espera i es posa en marxa només quan el servidor en calent falla.\n\n\n\nLa fiabilitat és la capacitat d’un sistema per mantenir-se operatiu durant un període de temps determinat sense fallar. Es mesura en MTBF (Mean Time Between Failures). Per exemple, un sistema amb un MTBF de 1000 hores es pot esperar que falli cada 1000 hores d’ús.\nUna forma d’evitar fallades és la redundància, imagineu que tenim un servidor en calent (actual) i un servidor en fred (reserva) que es posa en marxa en cas de fallada del servidor actual. En aquest cas, el sistema és més fiable perquè si falla el servidor actual, el servidor de reserva pot prendre el relleu sense afectar el servei. La contrapartida és que aquesta redundància implica un cost addicional.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Fonaments de l'Administració de Sistemes"
    ]
  },
  {
    "objectID": "slides/01-foundations-of-systems-administration.html#què-és-la-disponibilitat",
    "href": "slides/01-foundations-of-systems-administration.html#què-és-la-disponibilitat",
    "title": "Fonaments de l’Administració de Sistemes",
    "section": "Què és la disponibilitat?",
    "text": "Què és la disponibilitat?\nLa disponibilitat d’un sistema es refereix a la seva capacitat per estar operatiu i accessible per als usuaris durant un període de temps determinat.\n\nLa disponibilitat es mesura habitualment mitjançant el MTTR (Mean Time To Repair), que indica el temps mitjà que es triga a reparar un sistema després d’una fallada. Per exemple, si un sistema té un MTTR de 2 hores, això vol dir que, de mitjana, es triga 2 hores a reparar el sistema després d’una fallada.\n\n\n\\[ Disponibilitat = \\frac{Temps\\ de\\ funcionament}{Temps\\ de\\ funcionament + Temps\\ de\\ reparar} \\]\n\n\n\n\n\n\n\n\nExemple\n\n\nAmazon Web Services (AWS) ofereix un SLA (Service Level Agreement) del 99,99%, el que significa que el servei estarà disponible el 99,99% del temps. Si el servei no compleix aquest SLA, AWS ha de compensar els clients amb crèdits de servei.\n\n\n\n\n\nLa disponibilitat d’un sistema es refereix a la seva capacitat per estar operatiu i accessible per als usuaris durant un període de temps determinat. Es mesura en MTTR (Mean Time To Repair), que indica el temps mitjà que es triga a reparar un sistema després d’una fallada. Per exemple, si un sistema té un MTTR de 2 hores, això vol dir que, de mitjana, es triga 2 hores a reparar el sistema després d’una fallada. No confondre amb fiabilitat, que es refereix a la capacitat d’un sistema per operar sense interrupcions durant un període determinat.\nPer exemple, un sistema pot tenir una alta fiabilitat, però una baixa disponibilitat si el temps de reparació després d’una fallada és llarg. D’altra banda, un sistema pot tenir una baixa fiabilitat, però una alta disponibilitat si es pot reparar ràpidament després d’una fallada. La disponibilitat es mesura en percentatge i es pot garantir mitjançant acords de nivell de servei (SLA) que estipulen el temps de disponibilitat del sistema i les compensacions en cas de fallada.\nUn exemple comú d’alta disponibilitat és Amazon Web Services (AWS), que ofereix un SLA del 99,99%, el que significa que el servei estarà disponible el 99,99% del temps.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Fonaments de l'Administració de Sistemes"
    ]
  },
  {
    "objectID": "slides/01-foundations-of-systems-administration.html#kiss-keep-it-simple-stupid",
    "href": "slides/01-foundations-of-systems-administration.html#kiss-keep-it-simple-stupid",
    "title": "Fonaments de l’Administració de Sistemes",
    "section": "KISS: Keep It Simple, Stupid",
    "text": "KISS: Keep It Simple, Stupid\nUn sistema simple és més fàcil de mantenir, gestionar i entendre. Per dissenyar un sistema simple, es poden seguir les següents pautes:\n\nDivideix i venceràs: Divideix el sistema en components més petits i senzills\nMinimitza la complexitat: Evita la complexitat innecessària i mantén el sistema senzill\nUtilitza estàndards: Utilitza estàndards i pràctiques comunes per simplificar el disseny\nDocumenta el sistema: Documenta el sistema per facilitar la comprensió i el manteniment\nAutomatitza les tasques repetitives: Utilitza la automatització per simplificar les tasques repetitives i reduir els errors humans\n\n\n\n\n\n\n\n\nExemple\n\n\nUn sistema LEGO és un exemple de simplicitat, ja que es pot construir gairebé qualsevol cosa convinant peces senzilles. Aquesta simplicitat permet als usuaris crear i modificar les seves pròpies creacions sense necessitat de coneixements tècnics avançats.\n\n\n\n\n\nKISS és una directriu de disseny que destaca la importància de la simplicitat. Aplicant aquest principi, els sistemes resulten ser més robustos i fàcils de gestionar, cosa que millora la seva eficàcia i la satisfacció de l’usuari.\nAlgunes pautes per aplicar el principi KISS en el disseny de sistemes són:\n\nDivideix i venceràs: Divideix el sistema en components més petits i senzills, per exemple, en lloc de tenir un gran monòlit, divideix el sistema en microserveis.\nMinimitza la complexitat: Evita la complexitat innecessària i mantén el sistema senzill, per exemple, evita l’ús de tecnologies i funcionalitats que no són necessàries.\nUtilitza estàndards: Utilitza estàndards i pràctiques comunes per simplificar el disseny, per exemple, segueix les pràctiques de codificació i disseny recomanades per la comunitat.\nDocumenta el sistema: Documenta el sistema per facilitar la comprensió i el manteniment, per exemple, crea documentació clara i concisa per als desenvolupadors i els usuaris.\nAutomatitza les tasques repetitives: Utilitza la automatització per simplificar les tasques repetitives i reduir els errors humans, per exemple, automatitza les tasques de desplegament i proves per millorar l’eficiència i la fiabilitat del sistema.\n\nUn exemple de simplicitat és un sistema LEGO, que permet als usuaris construir gairebé qualsevol cosa combinant peces senzilles. Aquesta simplicitat permet als usuaris crear i modificar les seves pròpies creacions sense necessitat de coneixements tècnics avançats.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Fonaments de l'Administració de Sistemes"
    ]
  },
  {
    "objectID": "slides/01-foundations-of-systems-administration.html#eines-i-tecnologies-més-comuns",
    "href": "slides/01-foundations-of-systems-administration.html#eines-i-tecnologies-més-comuns",
    "title": "Fonaments de l’Administració de Sistemes",
    "section": "Eines i tecnologies més comuns?",
    "text": "Eines i tecnologies més comuns?\n\nVirtualització: Màquines Virtuals, Contenidors\nCloud Computing: Infraestructura com a Servei (IaaS), Plataforma com a Servei (PaaS), Software com a Servei (SaaS)\nAutomatització: Ansible, Puppet, Chef\nInfraestructura com a Codi: Terraform, CloudFormation\nMonitorització: Nagios, Zabbix, Prometheus\nCI/CD: Jenkins, GitLab CI\nSeguretat: PfSense, Suricata, Snort\nBases de Dades: MySQL, PostgreSQL, MongoDB\nServeis Web: Apache, Nginx, Tomcat\nOrquestació de Contenidors: Kubernetes, Docker Swarm\n\n\nEn el món de l’administració de sistemes, hi ha una gran varietat d’eines i tecnologies que es poden utilitzar per gestionar i mantenir els sistemes informàtics. Algunes de les eines i tecnologies més comuns són:\n\nVirtualització: La virtualització permet crear màquines virtuals i contenidors per aïllar i gestionar els recursos del sistema. Això permet millorar l’eficiència i la flexibilitat dels sistemes, ja que es poden crear múltiples entorns virtuals en un sol servidor físic.\nCloud Computing: El cloud computing ofereix serveis informàtics a través d’Internet, permetent als usuaris accedir a recursos informàtics a la demanda. Això inclou Infraestructura com a Servei (IaaS), Plataforma com a Servei (PaaS) i Software com a Servei (SaaS).\nAutomatització: L’automatització permet automatitzar tasques repetitives i reduir els errors humans. Algunes eines d’automatització com Ansible, Puppet i Chef permeten gestionar la configuració dels servidors de manera eficient.\nInfraestructura com a Codi: L’infraestructura com a codi permet gestionar la infraestructura de manera programàtica, utilitzant codi per definir i gestionar els recursos del sistema. Eines com Terraform i CloudFormation permeten gestionar la infraestructura com a codi.\nMonitorització: La monitorització permet supervisar l’estat dels sistemes i identificar problemes abans que afectin el rendiment. Algunes eines de monitorització com Nagios, Zabbix i Prometheus permeten supervisar els sistemes en temps real.\nCI/CD: La integració contínua (CI) i el desplegament contínu (CD) permeten automatitzar el procés de desenvolupament i desplegament de codi. Eines com Jenkins i GitLab CI permeten implementar pràctiques de CI/CD.\nSeguretat: La seguretat dels sistemes és una preocupació important en l’administració de sistemes. Algunes eines de seguretat com PfSense, Suricata i Snort permeten protegir els sistemes contra atacs i amenaces.\nBases de Dades: Les bases de dades són essencials per emmagatzemar i gestionar la informació dels sistemes. Algunes bases de dades com MySQL, PostgreSQL i MongoDB són àmpliament utilitzades en l’administració de sistemes.\nServeis Web: Els serveis web són essencials per proporcionar serveis i aplicacions a través d’Internet. Algunes eines com Apache, Nginx i Tomcat permeten gestionar i desplegar serveis web.\nOrquestació de Contenidors: L’orquestació de contenidors permet gestionar i coordinar els contenidors en un entorn de contenidors. Eines com Kubernetes i Docker Swarm permeten gestionar i escalar els contenidors de manera eficient.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Fonaments de l'Administració de Sistemes"
    ]
  },
  {
    "objectID": "slides/01-foundations-of-systems-administration.html#virtualització-màquines-virtuals",
    "href": "slides/01-foundations-of-systems-administration.html#virtualització-màquines-virtuals",
    "title": "Fonaments de l’Administració de Sistemes",
    "section": "Virtualització (Màquines Virtuals)",
    "text": "Virtualització (Màquines Virtuals)\n\n\n\n\nEsquema de tipus de virtualització de màquines virtuals\n\n\n\n\nLa virtualització és una tecnologia clau que permet aprofitar millor els recursos d’un servidor físic, creant múltiples màquines virtuals (VMs) que funcionen com a entitats independents, cadascuna amb el seu propi sistema operatiu i aplicacions. Aquest enfocament permet millorar l’eficiència, ja que múltiples màquines virtuals poden compartir un únic servidor físic, maximitzant l’ús dels recursos disponibles i oferint més flexibilitat a l’hora de gestionar sistemes. Per exemple, si voleu executar tant Windows com Linux al vostre ordinador per fer proves, podeu crear màquines virtuals per a cada sistema operatiu utilitzant programes com VirtualBox o VMware. Això us permet treballar amb diferents entorns sense necessitat de tenir diversos ordinadors físics. A nivell de servidors, aquesta mateixa idea es porta a gran escala: un sol servidor físic pot tenir múltiples màquines virtuals aïllades, cada una amb la seva funció específica. Això permet consolidar serveis i maximitzar l’ús de recursos. Per exemple, en una empresa, un sol servidor físic podria allotjar VMs per a bases de dades, aplicacions web, i sistemes de correu, cadascun funcionant de manera independent.\n\nVirtualització Nativa: També coneguda com a “bare-metal”, en aquest tipus, l’hipervisor s’executa directament sobre el maquinari físic sense cap sistema operatiu intermedi. Exemples d’aquesta tecnologia inclouen VMware ESXi o Microsoft Hyper-V. Això ofereix un rendiment molt elevat, ja que no hi ha cap capa addicional entre el maquinari i l’hipervisor, ideal per a entorns de producció.\nVirtualització Allotjada: Aquí, l’hipervisor s’executa sobre un sistema operatiu ja existent. Per exemple, en KVM (Kernel-based Virtual Machine), s’utilitza Linux com a sistema operatiu base, i sobre aquest es creen les màquines virtuals. Aquest enfocament és més fàcil d’implementar però pot sacrificar una mica de rendiment en comparació amb la virtualització nativa.\nParavirtualització: En aquest model, el sistema operatiu convidat sap que està sent virtualitzat i coopera amb l’hipervisor per millorar el rendiment. Un exemple destacat és Xen, que és molt utilitzat en entorns cloud per la seva eficiència. Aquest tipus de virtualització pot oferir un rendiment proper al de la virtualització nativa, però amb més flexibilitat.\nVirtualització Assistida per Hardware: Aquest model aprofita les capacitats del processador per accelerar el procés de virtualització. Processadors moderns com els d’Intel (VT-x) o AMD (AMD-V) ofereixen suport per a aquest tipus de virtualització, que és utilitzat per tecnologies com VMware o Hyper-V.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Fonaments de l'Administració de Sistemes"
    ]
  },
  {
    "objectID": "slides/01-foundations-of-systems-administration.html#ansible",
    "href": "slides/01-foundations-of-systems-administration.html#ansible",
    "title": "Fonaments de l’Administració de Sistemes",
    "section": "Ansible",
    "text": "Ansible\nAnsible és una eina d’automatització de la configuració i gestió de sistemes. Utilitza un llenguatge senzill basat en YAML per definir les tasques i la configuració dels sistemes, i utilitza SSH per connectar-se als servidors i executar les tasques.\n\n\n- hosts: webservers\n  tasks:\n    - name: Install Apache\n      apt:\n        name: apache2\n        state: present\n    - name: Start Apache\n      service:\n        name: apache2\n        state: started\n\nhosts:\n  webservers:\n    - web1.example.com\n    - web2.example.com\n    - web3.example.com\n\n\nAnsible és una eina d’automatització que ens permet gestionar la configuració dels servidors de manera eficient i fiable. Per exemple, si necessitem instal·lar un servidor web a 10.000 servidors, en lloc de fer-ho manualment en cada servidor, podem utilitzar Ansible per automatitzar aquesta tasca. Amb aquest script indiquem les tasques ha realitzar instal·lar apache i aixecar el servei. I en el fitxer de hosts indiquem els servidors on volem realitzar aquestes tasques.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Fonaments de l'Administració de Sistemes"
    ]
  },
  {
    "objectID": "slides/01-foundations-of-systems-administration.html#què-és-el-cloud-computing",
    "href": "slides/01-foundations-of-systems-administration.html#què-és-el-cloud-computing",
    "title": "Fonaments de l’Administració de Sistemes",
    "section": "Què és el Cloud Computing?",
    "text": "Què és el Cloud Computing?\nLliurament de recursos sota demanda, incloent servidors, emmagatzematge, bases de dades, programari, analítica, i més, a través d’internet amb un model de pagament per ús.\n\n\n\n\nPizza as a service\n\n\n\n\nEl cloud computing es refereix al lliurament sota demanda de serveis informàtics, incloent servidors, emmagatzematge, bases de dades, programari, analítica, i molt més, a través d’internet amb un model de pagament per ús.\nAquests recursos s’executen en servidors ubicats en grans centres de dades arreu del món. Els usuaris poden accedir-hi de manera remota des de qualsevol lloc amb connexió a internet. En lloc de posseir i mantenir la seva pròpia infraestructura, els usuaris i empreses poden llogar serveis des d’aplicacions fins a emmagatzematge d’un proveïdor de serveis al núvol. Els recursos es poden combinar com peces de LEGO per crear solucions a mida de les necessitats.\nAquest model ha permès l’evolució de l’administració de sistemes a un nivell superior, permetent als usuaris centrar-se en el desenvolupament d’aplicacions i serveis sense haver de preocupar-se de la infraestructura subjacents.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Fonaments de l'Administració de Sistemes"
    ]
  },
  {
    "objectID": "slides/01-foundations-of-systems-administration.html#amazon-web-services",
    "href": "slides/01-foundations-of-systems-administration.html#amazon-web-services",
    "title": "Fonaments de l’Administració de Sistemes",
    "section": "Amazon Web Services",
    "text": "Amazon Web Services\n\n\n\n\nAmazon Web Services (AWS) és un proveïdor de serveis de computació en núvol que ofereix una àmplia gamma de serveis, incloent servidors virtuals, emmagatzematge, bases de dades, analítica, seguretat, i molt més. AWS permet als usuaris i empreses llogar recursos informàtics a través d’internet, oferint una plataforma flexible i escalable per a la implementació d’aplicacions en núvol. Altres proveïdors de serveis en núvol inclouen Microsoft Azure, Google Cloud Platform, IBM Cloud, i Oracle Cloud, però en aquest curs utilitzarem AWS per raons de popularitat i disponibilitat de recursos.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Fonaments de l'Administració de Sistemes"
    ]
  },
  {
    "objectID": "slides/01-foundations-of-systems-administration.html#cloudformation",
    "href": "slides/01-foundations-of-systems-administration.html#cloudformation",
    "title": "Fonaments de l’Administració de Sistemes",
    "section": "CloudFormation",
    "text": "CloudFormation\nCloudFormation és un servei d’AWS que permet als desenvolupadors definir i desplegar la infraestructura de manera programàtica mitjançant codi.\nResources:\n  MyInstance:\n    Type: AWS::EC2::Instance\n    Properties:\n      ImageId: ami-0c55b159cbfafe1f0\n      InstanceType: t2.micro\n      KeyName: my-key-pair\n      SecurityGroups:\n        - my-security-group\n\nAWS CloudFormation és un servei que permet als desenvolupadors definir i desplegar la infraestructura de manera programàtica mitjançant codi. Aquest codi es defineix en plantilles de CloudFormation, que descriuen els recursos necessaris per a la infraestructura, com ara instàncies EC2, grups de seguretat, taules de rutes, …, En aquest exemple, es defineix una instància EC2 amb una imatge AMI, un tipus d’instància, una clau SSH, i un grup de seguretat. Un cop es defineix la plantilla, es pot desplegar la infraestructura amb un sol clic o una sola comanda, automatitzant així el procés de desplegament i garantint la consistència de la infraestructura.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Fonaments de l'Administració de Sistemes"
    ]
  },
  {
    "objectID": "slides/01-foundations-of-systems-administration.html#virtualització-contenidors",
    "href": "slides/01-foundations-of-systems-administration.html#virtualització-contenidors",
    "title": "Fonaments de l’Administració de Sistemes",
    "section": "Virtualització (Contenidors)",
    "text": "Virtualització (Contenidors)\n\n\n\n\nEsquema de tipus de virtualització de contenidors (Docker)\n\n\n\n\nLa virtualització de contenidors és una tecnologia que permet als desenvolupadors empaquetar aplicacions i les seves dependències en un contenidor lleuger i portàtil que pot ser executat en qualsevol sistema que tingui un motor de contenidors. Aquest enfocament permet als desenvolupadors crear, distribuir i executar aplicacions de manera eficient i fiable, ja que els contenidors són autosuficients i aïllats de l’entorn d’execució. A més, els contenidors són lleugers i portàtils, el que facilita la seva distribució i execució en entorns diversos.\nPer exemple, Docker o containerd són motors de contenidors que permeten als desenvolupadors crear i executar contenidors lleugers i portàtils. Aquests contenidors poden contenir aplicacions, serveis o microserveis, i es poden executar en qualsevol sistema que tingui un motor de contenidors instal·lat. Això permet als desenvolupadors crear, distribuir i executar aplicacions de manera eficient i fiable, ja que els contenidors són autosuficients i aïllats de l’entorn d’execució.\nLa principal diferència entre la virtualització de màquines virtuals i la virtualització de contenidors és el nivell d’abstracció. Mentre que les màquines virtuals virtualitzen tota una màquina física, incloent el sistema operatiu, els contenidors virtualitzen només l’aplicació i les seves dependències, compartint el mateix nucli del sistema operatiu hoste. Això fa que els contenidors siguin més lleugers i portàtils que les màquines virtuals, i permet als desenvolupadors crear i executar aplicacions de manera més eficient i fiable.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Fonaments de l'Administració de Sistemes"
    ]
  },
  {
    "objectID": "slides/01-foundations-of-systems-administration.html#kubernetes",
    "href": "slides/01-foundations-of-systems-administration.html#kubernetes",
    "title": "Fonaments de l’Administració de Sistemes",
    "section": "Kubernetes",
    "text": "Kubernetes\n\n\n\n\nKubernetes\n\n\n\n\nKubernetes és una plataforma de codi obert per a la gestió d’aplicacions en contenidors. Permet als desenvolupadors automatitzar el desplegament, l’escalat i la gestió d’aplicacions en contenidors, oferint una plataforma flexible i escalable per a la implementació d’aplicacions en entorns de producció. Es basa en una arquitectura de màster i nodes, on el màster és responsable de la gestió i control del clúster, mentre que els nodes són els servidors on s’executen les aplicacions en contenidors. Requereix de diferents xarxes (com xarxa de control, xarxa de pod, xarxa de servei) per a la comunicació entre els components del clúster, a més necessita serveis de descobriment de serveis (com etcd) per a la gestió de la configuració i l’estat del clúster, controladors de xarxa (com Flannel) per a la comunicació entre els nodes, i controladors de volums (com Rook) per a la gestió de l’emmagatzematge persistent, un planificador (com kube-scheduler) per a la programació de les tasques, i un controlador de replicació (com kube-controller-manager) per a la gestió de la replicació de les aplicacions i sobretot el kubelet, que és l’agent que s’executa en cada node i és responsable de la gestió dels contenidors en el node. Com veieu, Kubernetes és una plataforma complexa que requereix una configuració i gestió adequades per a garantir el seu funcionament correcte.",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Fonaments de l'Administració de Sistemes"
    ]
  },
  {
    "objectID": "slides/01-foundations-of-systems-administration.html#thats-all",
    "href": "slides/01-foundations-of-systems-administration.html#thats-all",
    "title": "Fonaments de l’Administració de Sistemes",
    "section": "That’s all",
    "text": "That’s all\n\n\n\n\n\n\n\n\n\nTake Home Message\n\n\nUn administrador de sistemes combina habilitats de bomber i investigador: ha de solucionar problemes de manera ràpida i efectiva, però també anticipar-se i prevenir-ne de futurs abans que esdevinguin crítics. Aquesta tasca és complexa i diversa, abastant des de la gestió de cables i servidors físics fins a l’administració de pods i sistemes automàtics sense servidor (serverless).",
    "crumbs": [
      "Diapositives",
      "Unitat 01 · Fonaments de l'Administració de Sistemes"
    ]
  },
  {
    "objectID": "slides/02-booting.html#etapes-de-larrancada",
    "href": "slides/02-booting.html#etapes-de-larrancada",
    "title": "Arrencada del sistema (Part 1)",
    "section": "Etapes de l’arrancada",
    "text": "Etapes de l’arrancada",
    "crumbs": [
      "Diapositives",
      "Unitat 02 · Arrencada del sistema"
    ]
  },
  {
    "objectID": "slides/02-booting.html#fase-1-màquinaria",
    "href": "slides/02-booting.html#fase-1-màquinaria",
    "title": "Arrencada del sistema (Part 1)",
    "section": "Fase 1: Màquinaria",
    "text": "Fase 1: Màquinaria\n\nEn prémer el botó d’encesa, la placa base envia un senyal a la PSU (Power Supply Unit).\nLa PSU proporciona tensió estable a tots els components i activa la CPU.\nLa CPU inicialitza registres interns i col·loca el Puntador d’Instrucció (EIP) a la direcció de reset 0xFFFFFFF0.\n\n\n\nAquesta adreça conté una instrucció de salt (jmp) que redirigeix la CPU al Firmware (BIOS/UEFI) per iniciar el procés de diagnòstic i arrencada del sistema (POST).",
    "crumbs": [
      "Diapositives",
      "Unitat 02 · Arrencada del sistema"
    ]
  },
  {
    "objectID": "slides/02-booting.html#fase-2-firmware",
    "href": "slides/02-booting.html#fase-2-firmware",
    "title": "Arrencada del sistema (Part 1)",
    "section": "Fase 2: Firmware",
    "text": "Fase 2: Firmware\nEl teu ordinador necessita un firmware per: provar, detectar, configurar i inicialitzar dispositius. Aquest firmware en sistemes moderns és l’UEFI i en sistemes antics el BIOS (normalment compatibles amb IBM PC).\n\n\nYou’ve probably read a lot of stuff on the internet about UEFI. Here is something important you should understand: 95% of it was probably garbage. — Adam Williamson",
    "crumbs": [
      "Diapositives",
      "Unitat 02 · Arrencada del sistema"
    ]
  },
  {
    "objectID": "slides/02-booting.html#fase-2-etapes",
    "href": "slides/02-booting.html#fase-2-etapes",
    "title": "Arrencada del sistema (Part 1)",
    "section": "Fase 2: Etapes",
    "text": "Fase 2: Etapes\n\nInicialització del firmware\n\nCarrega i execució del codi de firmware (BIOS/UEFI).\nLectura de la configuració de la NVRAM.\nVerificació de la integritat del firmware.\n\nDiagnòstic i detecció\n\nPower-On Self Test (POST): comprovació de CPU, RAM, gràfics bàsics…\nDetecció i inicialització dels dispositius connectats.\nAplicació de la configuració als dispositius.\n\nArrencada del sistema\n\nSelecció del dispositiu d’arrencada.\nCàrrega del bootloader de primera etapa.\nTransferència del control al bootloader.",
    "crumbs": [
      "Diapositives",
      "Unitat 02 · Arrencada del sistema"
    ]
  },
  {
    "objectID": "slides/02-booting.html#actualització-del-firmware",
    "href": "slides/02-booting.html#actualització-del-firmware",
    "title": "Arrencada del sistema (Part 1)",
    "section": "Actualització del firmware",
    "text": "Actualització del firmware\nEl firmware està emmagatzemat en un xip de memòria flash a la placa base. L’actualització (flashing) substitueix el contingut d’aquest xip per una versió nova.\n\n\n🚀 Objectius\n\nCorregir errades de microcodi de la CPU.\nAfegir suport per a nou maquinari (CPU, RAM, targetes).\nAplicar parches de seguretat (ex.: vulnerabilitats Spectre/Meltdown.\nMillorar funcions de gestió d’energia i arrencada segura (Secure Boot).\n\n\n⚠️ Riscos\n\nUn error en el procés (tall de corrent, imatge corrupta, versió incorrecta) pot deixar el xip inservible (brick).\nAlguns fabricants ofereixen mecanismes de recuperació (dual BIOS, BIOS flashback, càpsules UEFI).\nEn entorns de producció, és recomanable validar la nova versió en un entorn de test abans de desplegar-la.",
    "crumbs": [
      "Diapositives",
      "Unitat 02 · Arrencada del sistema"
    ]
  },
  {
    "objectID": "slides/02-booting.html#diferències-entre-bios-i-uefi-i",
    "href": "slides/02-booting.html#diferències-entre-bios-i-uefi-i",
    "title": "Arrencada del sistema (Part 1)",
    "section": "Diferències entre BIOS i UEFI (I)",
    "text": "Diferències entre BIOS i UEFI (I)\n\n\n\n\n\n\n\n\nCaracterística\nBIOS\nUEFI\n\n\n\n\nEmmagatzematge\nTradicionalment en ROM (avui dia flash EEPROM)\nFlash SPI a la placa base + EFI System Partition (ESP) al disc\n\n\nCapacitat de disc\nFins a 2,2 TB (per limitació 32-bit LBA, sectors 512 B)\nFins a 9,4 ZB (GPT)\n\n\nInterfície\nText\nGràfica, amb suport per ratolí i resolucions altes\n\n\nSeguretat\nSense proteccions avançades\nSecure Boot, verificació de signatures i protecció contra codi maliciós\n\n\nCompatibilitat\nPrincipalment IBM PC compatibles antics\nCompatible amb sistemes moderns, amb suport per Legacy BIOS via CSM",
    "crumbs": [
      "Diapositives",
      "Unitat 02 · Arrencada del sistema"
    ]
  },
  {
    "objectID": "slides/02-booting.html#diferències-entre-bios-i-uefi-ii",
    "href": "slides/02-booting.html#diferències-entre-bios-i-uefi-ii",
    "title": "Arrencada del sistema (Part 1)",
    "section": "Diferències entre BIOS i UEFI (II)",
    "text": "Diferències entre BIOS i UEFI (II)\n\n\n\n\n\n\n\n\nCaracterística\nBIOS\nUEFI\n\n\n\n\nVelocitat d’arrencada\nMés lenta\nMés ràpida gràcies a inicialització paral·lela de drivers i fast boot\n\n\nTaula de particions\nMBR\nGPT\n\n\nNombre màxim de particions\n4 primàries (amb lògiques dins d’estesa)\nFins a 128 entrades de particions\n\n\nModularitat\nMonolítica\nModular, permet afegir drivers, aplicacions i extensions UEFI",
    "crumbs": [
      "Diapositives",
      "Unitat 02 · Arrencada del sistema"
    ]
  },
  {
    "objectID": "slides/02-booting.html#taula-de-particions-mbr",
    "href": "slides/02-booting.html#taula-de-particions-mbr",
    "title": "Arrencada del sistema (Part 1)",
    "section": "Taula de particions MBR",
    "text": "Taula de particions MBR\n\n\nEstructura\n\nBootloader de primera etapa (446 bytes): Conté el codi d’arrencada.\nTaula de particions (64 bytes): Conté la informació de les particions. Pot contenir fins a 4 entrades.\nSignatura (2 bytes): Marca de final de la taula de particions. Permet identificar la taula de particions com a vàlida.\n\n\n\n\n\n\n\n\nLímitació\n\n\n\nCom MBR utiltiza entrades de 32 bits per blocs lògics (LBA) → \\(2^{32}\\) sectors × \\(512 B = 2 TB\\) aproximadament.\nNomés suporta 4 particions primàries.",
    "crumbs": [
      "Diapositives",
      "Unitat 02 · Arrencada del sistema"
    ]
  },
  {
    "objectID": "slides/02-booting.html#particions-mbr-i",
    "href": "slides/02-booting.html#particions-mbr-i",
    "title": "Arrencada del sistema (Part 1)",
    "section": "Particions MBR (I)",
    "text": "Particions MBR (I)\n\nParticions primàries\n\nFins a 4 per disc.\nContenen directament un sistema de fitxers (ext4, NTFS, FAT32).\nPot tenir un Volume Boot Record (VBR) que carrega el sistema operatiu de la partició.\n\nPartició estesa\n\nUna partició primària especial per superar la limitació de 4 primàries.\nNo conté sistema de fitxers ni VBR; actua com a contenidor de particions lògiques.\n\nParticions lògiques\n\nResideixen dins de la partició estesa.\nCada partició lògica té un Extended Boot Record (EBR) amb la seva taula de particions.\nLa linked list d’EBRs permet afegir dinàmicament més particions lògiques.\nPot contenir un VBR per carregar el sistema operatiu",
    "crumbs": [
      "Diapositives",
      "Unitat 02 · Arrencada del sistema"
    ]
  },
  {
    "objectID": "slides/02-booting.html#particions-mbr-ii",
    "href": "slides/02-booting.html#particions-mbr-ii",
    "title": "Arrencada del sistema (Part 1)",
    "section": "Particions MBR (II)",
    "text": "Particions MBR (II)",
    "crumbs": [
      "Diapositives",
      "Unitat 02 · Arrencada del sistema"
    ]
  },
  {
    "objectID": "slides/02-booting.html#taula-de-particions-gpt-i",
    "href": "slides/02-booting.html#taula-de-particions-gpt-i",
    "title": "Arrencada del sistema (Part 1)",
    "section": "Taula de particions GPT (I)",
    "text": "Taula de particions GPT (I)\n\nCompatibilitat i protecció\n\nBloqueja utilitats basades en MBR per no sobreescriure un disc GPT.\nConté una única partició especial que identifica el disc com GPT.\nOS i eines que no suporten GPT reconeixen el disc, però normalment no el modifiquen.\n\nGPT Header Primari\n\nSituat al segon sector del disc (LBA 1).\nDefineix els blocs utilitzables del disc.\nConté la taula de particions (mínim 128 entrades, 128 B cadascuna).\n\nGPT Header Secundari\n\nCòpia de seguretat del Primary GPT Header.\nSituat als últims sectors del disc.\nPermet recuperar la informació si el Primary Header està corrupte.",
    "crumbs": [
      "Diapositives",
      "Unitat 02 · Arrencada del sistema"
    ]
  },
  {
    "objectID": "slides/02-booting.html#taula-de-particions-gpt",
    "href": "slides/02-booting.html#taula-de-particions-gpt",
    "title": "Arrencada del sistema (Part 1)",
    "section": "Taula de particions GPT",
    "text": "Taula de particions GPT",
    "crumbs": [
      "Diapositives",
      "Unitat 02 · Arrencada del sistema"
    ]
  },
  {
    "objectID": "slides/02-booting.html#què-és-uefi-i",
    "href": "slides/02-booting.html#què-és-uefi-i",
    "title": "Arrencada del sistema (Part 1)",
    "section": "Què és UEFI? (I)",
    "text": "Què és UEFI? (I)\n\nSistema de fitxers propi\n\nUEFI no utilitza MBR tradicional de 512 B ni codi de boot limitat.\nDisposa d’un filesystem propi (FAT32, 100 a 550 MB) anomenat EFI System Partition (ESP).\nLa partició EFI és marcada amb boot flag, però mai conté OS partitions.\n\nEstructura de la partició EFI\n\nCada OS té la seva carpeta dins de la ESP.\nConté tots els fitxers necessaris per carregar el sistema operatiu.\nEn Linux, la ESP sovint es munta sota /boot/efi.\n\n\n\n/\n├── boot\n│   ├── efi\n│   │   ├── EFI\n│   │   │   ├── BOOT\n│   │   │   │   ├── BOOTX64.EFI",
    "crumbs": [
      "Diapositives",
      "Unitat 02 · Arrencada del sistema"
    ]
  },
  {
    "objectID": "slides/02-booting.html#què-és-uefi-ii",
    "href": "slides/02-booting.html#què-és-uefi-ii",
    "title": "Arrencada del sistema (Part 1)",
    "section": "Què és UEFI? (II)",
    "text": "Què és UEFI? (II)\n\nMini sistema operatiu\n\nUEFI és com un mini sistema operatiu.\n\nExecuta fitxers en format EFI executable.\nPermet drivers i aplicacions independents del SO.\n\nQuan escrius un bootloader natiu UEFI, has de respectar aquest format.\n\nUEFI Boot Manager\n\nMotor de política del firmware per arrencada.\nConfigurable via variables globals a NVRAM.\nCarrega drivers UEFI i aplicacions UEFI (incloent OS bootloaders) en l’ordre definit per les variables.\nLinux disposa de l’eina efibootmgr per modificar la configuració del boot manager.",
    "crumbs": [
      "Diapositives",
      "Unitat 02 · Arrencada del sistema"
    ]
  },
  {
    "objectID": "slides/02-booting.html#mòduls-de-la-uefi",
    "href": "slides/02-booting.html#mòduls-de-la-uefi",
    "title": "Arrencada del sistema (Part 1)",
    "section": "Mòduls de la UEFI",
    "text": "Mòduls de la UEFI",
    "crumbs": [
      "Diapositives",
      "Unitat 02 · Arrencada del sistema"
    ]
  },
  {
    "objectID": "slides/02-booting.html#efibootmgr",
    "href": "slides/02-booting.html#efibootmgr",
    "title": "Arrencada del sistema (Part 1)",
    "section": "efibootmgr",
    "text": "efibootmgr\n# efibootmgr -v\nBootCurrent: 0002\nTimeout: 3 seconds\nBootOrder: 0003,0002,0000,0004\nBoot0000* CD/DVD Drive  BIOS(3,0,00)\nBoot0001* Hard Drive    HD(2,0,00)\nBoot0002* Fedora        HD(1,800,61800,6d98f360-cb3e-4727-8fed-5ce0c040365d)File(\\EFI\\fedora\\grubx64.efi)\nBoot0003* opensuse      HD(1,800,61800,6d98f360-cb3e-4727-8fed-5ce0c040365d)File(\\EFI\\opensuse\\grubx64.efi)\nBoot0004* Hard Drive    BIOS(2,0,00)P0: ST1500DM003-9YN16G \n\nLes entrades Boot0000 i Boot0004 corresponen a modes de compatibilitat BIOS (CSM), no són natives- d’UEFI.\nGenerades automàticament pel firmware, sense intervenció externa.\nS’afegeixen directament a les variables NVRAM del sistema.\nEntrades UEFI natives (Boot0002, Boot0003) apunten directament als fitxers EFI dels OS:\n\nFedora : \\EFI\\fedora\\grubx64.efi\nopenSUSE: \\EFI\\opensuse\\grubx64.efi\n\nL’ordre d’arrencada es defineix a la variable BootOrder.",
    "crumbs": [
      "Diapositives",
      "Unitat 02 · Arrencada del sistema"
    ]
  },
  {
    "objectID": "slides/02-booting.html#què-és-la-consola-de-la-uefi",
    "href": "slides/02-booting.html#què-és-la-consola-de-la-uefi",
    "title": "Arrencada del sistema (Part 1)",
    "section": "Què és la consola de la UEFI?",
    "text": "Què és la consola de la UEFI?\nLa consola de la UEFI és una interfície de línia de comandes que permet interactuar directament amb el firmware UEFI per realitzar tasques avançades de diagnòstic, configuració i manteniment del sistema.\n\n\nFuncions\n\nConfiguració del maquinari i perifèrics (CPU, memòria, dispositius PCIe).\nComprovació del funcionament dels dispositius i diagnòstic de fallades.\nAccés als sistemes de fitxers EFI i gestió de fitxers de boot.\nInstal·lació, reparació o actualització de bootloaders i OS.\nExecució de aplicacions UEFI natives (mini-aplicacions tipus OS).\n\n\nAccés\n\nPrement una tecla durant l’engegada del sistema, segons el fabricant: F2, F10, F12, ESC o Supr.\nDes de sistemes operatius:\n\nLinux: efibootmgr o systemctl reboot --firmware-setup.\nWindows: Opció Advanced Startup i UEFI Firmware Settings.\nmacOS: Reboot amb Option/Alt.",
    "crumbs": [
      "Diapositives",
      "Unitat 02 · Arrencada del sistema"
    ]
  },
  {
    "objectID": "slides/02-booting.html#comandes-de-la-consola-de-la-uefi",
    "href": "slides/02-booting.html#comandes-de-la-consola-de-la-uefi",
    "title": "Arrencada del sistema (Part 1)",
    "section": "Comandes de la consola de la UEFI",
    "text": "Comandes de la consola de la UEFI\n\n\n\n\n\n\n\n\nComanda\nFunció\nExemple\n\n\n\n\nmap\nMostra els dispositius detectats i les unitats lògiques associades\nmap fs* → llista tots els sistemes de fitxers detectats\n\n\nmem\nMostra l’ús de memòria i mapa físic de la RAM\nmemmap → mapa detallat de la memòria física\n\n\nls\nLlista fitxers i directoris dins un FS accessible\nls fs0:\\EFI\\Boot → mostra fitxers de la partició EFI\n\n\ncd\nNavegar entre carpetes dins del FS\ncd EFI\\Boot → mou a la carpeta d’arrencada EFI\n\n\ncp\nCopiar fitxers entre unitats o directoris\ncp fs0:\\EFI\\Boot\\bootx64.efi fs1:\\EFI\\Backup\\\n\n\nedit\nEditar fitxers, útil per configurar scripts d’arrencada\nedit fs0:\\EFI\\Boot\\bootx64.efi",
    "crumbs": [
      "Diapositives",
      "Unitat 02 · Arrencada del sistema"
    ]
  },
  {
    "objectID": "slides/02-booting.html#importància-de-la-partició-efi",
    "href": "slides/02-booting.html#importància-de-la-partició-efi",
    "title": "Arrencada del sistema (Part 1)",
    "section": "Importància de la partició EFI",
    "text": "Importància de la partició EFI\n\nPunt de partida per a l’arrencada del sistema operatiu.\nEssencial per a l’arrencada dels sistemes UEFI.\nConté fitxers crítics per carregar el bootloader de segona etapa, com:\n\nGRUB (Linux)\nGestor d’arrencada de Windows\n\nPermet tenir múltiples sistemes operatius en el mateix disc.\nFacilita la gestió i actualització de bootloaders sense afectar les particions del sistema operatiu.",
    "crumbs": [
      "Diapositives",
      "Unitat 02 · Arrencada del sistema"
    ]
  },
  {
    "objectID": "slides/02-booting.html#arrencar-sense-partició-efi",
    "href": "slides/02-booting.html#arrencar-sense-partició-efi",
    "title": "Arrencada del sistema (Part 1)",
    "section": "Arrencar sense partició EFI",
    "text": "Arrencar sense partició EFI\n\nTeòricament possible: configurar UEFI per carregar el bootloader directament des del disc dur.\nPoc comú i no recomanat, ja que:\n\nComplica la gestió dels sistemes operatius.\nImpedeix actualitzacions i reparacions automàtiques dels bootloaders.\n\nLa partició EFI proporciona un punt centralitzat i estàndard per a tots els fitxers d’arrencada.",
    "crumbs": [
      "Diapositives",
      "Unitat 02 · Arrencada del sistema"
    ]
  },
  {
    "objectID": "slides/02-booting.html#tipus-de-bootloaders",
    "href": "slides/02-booting.html#tipus-de-bootloaders",
    "title": "Arrencada del sistema (Part 1)",
    "section": "Tipus de bootloaders",
    "text": "Tipus de bootloaders\n\nBootloader de primera etapa: Carregat directament pel firmware (BIOS/UEFI). S’encarrega de carregar el bootloader de segona etapa.\nBootloader de segona etapa: Carregat pel bootloader de primera etapa. S’encarrega de carregar el sistema operatiu.\n\n\nEn sistemes UEFI, el bootloader de primera etapa és un fitxer executable en format EFI (per exemple, grubx64.efi per a GRUB). Mentre que en sistemes BIOS, el bootloader de primera etapa es troba en el MBR del disc.",
    "crumbs": [
      "Diapositives",
      "Unitat 02 · Arrencada del sistema"
    ]
  },
  {
    "objectID": "slides/02-booting.html#funcions-del-bootloader",
    "href": "slides/02-booting.html#funcions-del-bootloader",
    "title": "Arrencada del sistema (Part 1)",
    "section": "Funcions del bootloader",
    "text": "Funcions del bootloader\nUn bootloader és el programa encarregat de:\n\nMostrar un menú amb les diverses opcions d’arrencada disponibles.\nCarregar el nucli (kernel) i l’Initrd (si s’escau) a la memòria principal.\nEl kernel de linux té una convenció d’arrencada on el bootloader ha de preparar el mapa de memòria i els registres de la CPU abans de transferir el control al nucli.",
    "crumbs": [
      "Diapositives",
      "Unitat 02 · Arrencada del sistema"
    ]
  },
  {
    "objectID": "slides/02-booting.html#diferents-gestors-darrencada",
    "href": "slides/02-booting.html#diferents-gestors-darrencada",
    "title": "Arrencada del sistema (Part 1)",
    "section": "Diferents gestors d’arrencada",
    "text": "Diferents gestors d’arrencada\n\n\n\n\n\n\n\n\nBootloader\nCompatibilitat\nCaracterístiques principals\n\n\n\n\nLILO\nBIOS\nAntic bootloader Linux, obsolet.\n\n\nGRUB\nBIOS/UEFI\nPopular en Linux; menú configurable; suport multiboot.\n\n\nGRUB2\nBIOS/UEFI\nVersió moderna; suport FAT, NTFS, ext4; millor multiboot i scripting.\n\n\nrEFInd\nUEFI\nPermet arrencar múltiples OS; interfície gràfica amigable.\n\n\nsystemd-boot\nUEFI\nSimple i ràpid; integració amb systemd; no recomanat per multiboot.\n\n\nWindows Boot Manager\nUEFI\nGestiona arrencada de Windows i altres OS compatibles; integració amb BCD.",
    "crumbs": [
      "Diapositives",
      "Unitat 02 · Arrencada del sistema"
    ]
  },
  {
    "objectID": "slides/02-booting.html#exercicis-propostas",
    "href": "slides/02-booting.html#exercicis-propostas",
    "title": "Arrencada del sistema (Part 1)",
    "section": "Exercicis Propostas",
    "text": "Exercicis Propostas\n\nBooting amb MBR i BIOS\nBooting amb UEFI\nDual Boot amb UEFI",
    "crumbs": [
      "Diapositives",
      "Unitat 02 · Arrencada del sistema"
    ]
  },
  {
    "objectID": "slides/02-booting.html#thats-all",
    "href": "slides/02-booting.html#thats-all",
    "title": "Arrencada del sistema (Part 1)",
    "section": "That’s all",
    "text": "That’s all\n\n\n\n\n\n\n\n\n\nTake Home Message\n\n\nEl procés d’arrencada és un procés complex. Els administradors de sistemes han de conèixer aquest procés per poder gestionar i solucionar problemes durant l’arrencada del sistema i garantir un sistema segur, estable i eficient.",
    "crumbs": [
      "Diapositives",
      "Unitat 02 · Arrencada del sistema"
    ]
  },
  {
    "objectID": "slides/02-booting-part2.html#etapes-de-larrancada",
    "href": "slides/02-booting-part2.html#etapes-de-larrancada",
    "title": "Arrencada del sistema (Part 2)",
    "section": "Etapes de l’arrancada",
    "text": "Etapes de l’arrancada",
    "crumbs": [
      "Diapositives",
      "Unitat 02 · Arrencada del sistema (Part 2)"
    ]
  },
  {
    "objectID": "slides/02-booting-part2.html#què-és-el-grubgrub2",
    "href": "slides/02-booting-part2.html#què-és-el-grubgrub2",
    "title": "Arrencada del sistema (Part 2)",
    "section": "Què és el GRUB/GRUB2?",
    "text": "Què és el GRUB/GRUB2?\nGRUB (GRand Unified Bootloader) és un gestor d’arrencada molt utilitzat en sistemes operatius Linux i altres sistemes Unix-like. La seva funció principal és carregar un kernel del sistema operatiu a la memòria i iniciar el procés d’arrencada.\n\nFuncions principals:\n\nPermet seleccionar entre múltiples sistemes operatius instal·lats en un mateix ordinador (multi-boot).\nProporciona una interfície per configurar opcions d’arrencada, com ara paràmetres del kernel.\nSuporta diferents sistemes de fitxers, permetent accedir a particions amb formats com ext4, Btrfs, XFS, entre altres.\nOfereix una consola interactiva per a la resolució de problemes i la configuració avançada.",
    "crumbs": [
      "Diapositives",
      "Unitat 02 · Arrencada del sistema (Part 2)"
    ]
  },
  {
    "objectID": "slides/02-booting-part2.html#etapes-dexecució-del-grub",
    "href": "slides/02-booting-part2.html#etapes-dexecució-del-grub",
    "title": "Arrencada del sistema (Part 2)",
    "section": "Etapes d’execució del GRUB",
    "text": "Etapes d’execució del GRUB\n\nStage 1:\n\nEn sistemes BIOS: efectivament és el codi al MBR (o VBR) → molt petit (≤ 446 bytes).\nEn sistemes UEFI: és un fitxer executable EFI (normalment a /boot/efi/EFI/grub/grubx64.efi).\n\nStage 1.5 (només en BIOS, opcional):\n\nProporciona suport bàsic per a sistemes de fitxers.\nNormalment es troba en sectors buits després del MBR (espai entre MBR i primera partició). core.img.\n\nStage 2:\n\nConté el GRUB complet amb el menú d’arrencada.\nPot carregar mòduls addicionals (drivers de FS, vídeo, xarxa, criptografia…).\nTransfereix el control al kernel per iniciar el sistema operatiu.",
    "crumbs": [
      "Diapositives",
      "Unitat 02 · Arrencada del sistema (Part 2)"
    ]
  },
  {
    "objectID": "slides/02-booting-part2.html#diagrama-darrencada-del-grub",
    "href": "slides/02-booting-part2.html#diagrama-darrencada-del-grub",
    "title": "Arrencada del sistema (Part 2)",
    "section": "Diagrama d’arrencada del GRUB",
    "text": "Diagrama d’arrencada del GRUB\n\n\nset root=‘hd0,msdos1’: Indica la partició arrel on es troba el sistema operatiu que es vol arrencar.\nlinux /vmlinuz root=/dev/sda1: Indica la ruta del kernel i la partició arrel.\ninitrd /initramfs.img: Indica la ruta de l’initramfs.\nboot: Inicia el sistema operatiu.",
    "crumbs": [
      "Diapositives",
      "Unitat 02 · Arrencada del sistema (Part 2)"
    ]
  },
  {
    "objectID": "slides/02-booting-part2.html#configuració-del-grub-i",
    "href": "slides/02-booting-part2.html#configuració-del-grub-i",
    "title": "Arrencada del sistema (Part 2)",
    "section": "Configuració del GRUB (I)",
    "text": "Configuració del GRUB (I)\nEl fitxer principal de configuració de GRUB2 és:\n- /boot/grub/grub.cfg (o /boot/grub2/grub.cfg en algunes distribucions).\n\n\n\n\n\n\n\nImportant\n\n\nNo s’ha d’editar directament, ja que es regenera automàticament.\n\n\n\n\nFitxers i directoris\n\n/etc/default/grub : Opcions generals de configuració i variables d’entorn.\n/etc/grub.d/\nDirectori amb scripts que generen grub.cfg:\n\n00_header → configuració inicial\n\n10_linux → detecta kernels Linux\n\n30_os-prober → detecta altres SO\n\n40_custom → entrades personalitzades",
    "crumbs": [
      "Diapositives",
      "Unitat 02 · Arrencada del sistema (Part 2)"
    ]
  },
  {
    "objectID": "slides/02-booting-part2.html#configuració-del-grub-ii",
    "href": "slides/02-booting-part2.html#configuració-del-grub-ii",
    "title": "Arrencada del sistema (Part 2)",
    "section": "Configuració del GRUB (II)",
    "text": "Configuració del GRUB (II)\nUn cop modificats els fitxers anteriors, cal regenerar grub.cfg:\n# Distribucions Debian/Ubuntu\nsudo update-grub\n\n# Distribucions Arch, Fedora, openSUSE...\nsudo grub-mkconfig -o /boot/grub/grub.cfg",
    "crumbs": [
      "Diapositives",
      "Unitat 02 · Arrencada del sistema (Part 2)"
    ]
  },
  {
    "objectID": "slides/02-booting-part2.html#variables-etcdefaultgrub",
    "href": "slides/02-booting-part2.html#variables-etcdefaultgrub",
    "title": "Arrencada del sistema (Part 2)",
    "section": "Variables /etc/default/grub",
    "text": "Variables /etc/default/grub\n\n\n\n\n\n\n\nVariable\nDescripció\n\n\n\n\nGRUB_BACKGROUND\nImatge de fons que es mostrarà al menú d’arrencada.\n\n\nGRUB_TIMEOUT\nTemps en segons abans de carregar l’entrada predeterminada.\n\n\nGRUB_DEFAULT\nEntrada per defecte que es carregarà (index o nom)\n\n\nGRUB_CMDLINE_LINUX\nOpcions de línia de comandes que es passen al nucli en arrencar el sistema.\n\n\nGRUB_DISABLE_RECOVERY\nSi true, desactiva les opcions de mode de recuperació.\n\n\nGRUB_DISABLE_OS_PROBER\nSi true, impedeix que GRUB busqui altres sistemes operatius instal·lats.\n\n\nGRUB_PRELOAD_MODULES\nLlista de mòduls GRUB que es carregaran abans de mostrar el menú d’arrencada.",
    "crumbs": [
      "Diapositives",
      "Unitat 02 · Arrencada del sistema (Part 2)"
    ]
  },
  {
    "objectID": "slides/02-booting-part2.html#paràmetres-del-kernel-més-comuns",
    "href": "slides/02-booting-part2.html#paràmetres-del-kernel-més-comuns",
    "title": "Arrencada del sistema (Part 2)",
    "section": "Paràmetres del kernel més comuns",
    "text": "Paràmetres del kernel més comuns\n\n\n\n\n\n\n\nParàmetre\nDescripció\n\n\n\n\nquiet\nSuprimeix els missatges del nucli durant l’arrencada.\n\n\nsingle\nInicia el sistema en mode d’usuari únic (single-user mode) per a tasques de manteniment.\n\n\nnomodeset\nDesactiva la detecció de modes de vídeo, útil per a solucions de problemes amb gràfics.\n\n\nroot=\nEspecifica la partició arrel del sistema de fitxers.\n\n\ninit=\nEspecifica un fitxer d’init alternatiu.\n\n\nro\nMuntatge de la partició arrel en mode de només lectura durant l’arrencada.\n\n\nrw\nMuntatge de la partició arrel en mode de lectura i escriptura durant l’arrencada.\n\n\nsystemd.unit =\nEspecifica el target de systemd a iniciar (ex: multi-user.target, graphical.target).",
    "crumbs": [
      "Diapositives",
      "Unitat 02 · Arrencada del sistema (Part 2)"
    ]
  },
  {
    "objectID": "slides/02-booting-part2.html#consideracions-addicionals",
    "href": "slides/02-booting-part2.html#consideracions-addicionals",
    "title": "Arrencada del sistema (Part 2)",
    "section": "Consideracions addicionals",
    "text": "Consideracions addicionals\n\nEn UEFI, GRUB2 és un fitxer EFI a /boot/efi/EFI//grubx64.efi.\nEs poden protegir entrades amb contrasenya a /etc/grub.d/40_custom.\nAl menú, amb e es poden passar paràmetres temporals al kernel.\nGRUB permet chainloading per arrencar altres SO (Windows, BSD).\nAmb UEFI Secure Boot, GRUB pot ser signat digitalment.",
    "crumbs": [
      "Diapositives",
      "Unitat 02 · Arrencada del sistema (Part 2)"
    ]
  },
  {
    "objectID": "slides/02-booting-part2.html#secure-boot",
    "href": "slides/02-booting-part2.html#secure-boot",
    "title": "Arrencada del sistema (Part 2)",
    "section": "Secure Boot",
    "text": "Secure Boot\nSecure Boot és una característica de seguretat del firmware UEFI que assegura que només es carregui i s’executi programari de confiança durant el procés d’arrencada del sistema.\n\nUEFI comprova la signatura digital del bootloader EFI (per exemple, grubx64.efi) abans de carregar-lo.\nLa signatura és comparada amb les claus de confiança emmagatzemades en la DB (Database of allowed signatures) del firmware.\nSi la signatura és vàlida, UEFI carrega i executa el bootloader. Sinó, impedeix l’execució del bootloader i mostra un missatge d’error.\nPot carregar mòduls addicionals signats, que també poden ser verificats pel mateix GRUB (opcional).\nEl kernel Linux també pot estar signat (opcional, si s’utilitza Linux Kernel Signing).\nSi s’utilitza Shim, aquest actua com a intermediari: el firmware UEFI confia en Shim, i Shim verifica després GRUB i el kernel.",
    "crumbs": [
      "Diapositives",
      "Unitat 02 · Arrencada del sistema (Part 2)"
    ]
  },
  {
    "objectID": "slides/02-booting-part2.html#problemes-de-secure-boot",
    "href": "slides/02-booting-part2.html#problemes-de-secure-boot",
    "title": "Arrencada del sistema (Part 2)",
    "section": "Problemes de Secure Boot",
    "text": "Problemes de Secure Boot\n\nCompatibilitat: No tots els sistemes operatius o distribucions Linux suporten Secure Boot de manera nativa.\nClaus de confiança: La gestió de claus pot ser complexa, especialment en entorns corporatius.\nActualitzacions: Les actualitzacions del bootloader o del kernel poden requerir la re-signatura dels components.\nRestriccions: Algunes funcionalitats avançades poden estar limitades per les polítiques de Secure Boot.\n\nMalgrat Secure Boot, s’han detectat vulnerabilitats que permeten carregar bootloaders no autoritzats en alguns dispositius (ArsTechnica, 2024).",
    "crumbs": [
      "Diapositives",
      "Unitat 02 · Arrencada del sistema (Part 2)"
    ]
  },
  {
    "objectID": "slides/02-booting-part2.html#què-és-el-kernel",
    "href": "slides/02-booting-part2.html#què-és-el-kernel",
    "title": "Arrencada del sistema (Part 2)",
    "section": "Què és el kernel?",
    "text": "Què és el kernel?\nEl kernel és el nucli del sistema operatiu, responsable de gestionar els recursos del sistema, com la memòria, el processador, els dispositius d’entrada/sortida, la xarxa i els processos d’usuari.\n\n\n\n\n\n\n\nEl kernel es carrega a la memòria RAM durant el procés d’arrencada i es troba normalment a la partició arrel del sistema de fitxers (generalment en /boot).\nEl kernel és un programa binari que es compila específicament per a l’arquitectura de maquinari del sistema (per exemple, x86, ARM, etc.)\nPot ser personalitzat amb diferents mòduls i controladors segons les necessitats del sistema.",
    "crumbs": [
      "Diapositives",
      "Unitat 02 · Arrencada del sistema (Part 2)"
    ]
  },
  {
    "objectID": "slides/02-booting-part2.html#carregar-el-kernel",
    "href": "slides/02-booting-part2.html#carregar-el-kernel",
    "title": "Arrencada del sistema (Part 2)",
    "section": "Carregar el kernel",
    "text": "Carregar el kernel\nPer carregar el kernel, el bootloader necessita:\n\nRuta del kernel\n\nNormalment un fitxer com vmlinuz-version dins de /boot.\n\nPartició arrel\n\nLa partició on es troba el sistema de fitxers del sistema operatiu.\n\nFitxer de configuració del bootloader\n\nCom grub.cfg en el cas de GRUB, que indica ruta del kernel, paràmetres i initramfs.\n\nCàrrega de l’initramfs\n\nInitramfs (initial RAM filesystem) és un sistema de fitxers temporal a RAM.\n\nPermet inicialitzar controladors bàsics i muntar la partició arrel real abans de transferir el control al kernel complet.\n\n\n\nL’initramfs facilita la portabilitat i modularitat del kernel, permetent arrencar diferents configuracions de maquinari sense necessitat de recompilar el kernel cada cop.",
    "crumbs": [
      "Diapositives",
      "Unitat 02 · Arrencada del sistema (Part 2)"
    ]
  },
  {
    "objectID": "slides/02-booting-part2.html#què-és-linitramfs",
    "href": "slides/02-booting-part2.html#què-és-linitramfs",
    "title": "Arrencada del sistema (Part 2)",
    "section": "Què és l’Initramfs?",
    "text": "Què és l’Initramfs?\nL’Initramfs (Initial RAM Filesystem) és un petit sistema de fitxers integrat dins la imatge del nucli Linux.\n\nPermet que el kernel pugui muntar la partició arrel durant l’arrencada.\n\nA diferència de l’antic initrd, que residia en un disc, l’initramfs es carrega completament a RAM com a imatge comprimida.\n\n\nObjectius\n\nProporcionar un sistema de fitxers temporal i mínim.\n\nCarregar mòduls essencials del kernel necessaris per accedir a maquinari i sistemes de fitxers.\n\nExecutar scripts d’inicialització abans de transferir el control al sistema complet.",
    "crumbs": [
      "Diapositives",
      "Unitat 02 · Arrencada del sistema (Part 2)"
    ]
  },
  {
    "objectID": "slides/02-booting-part2.html#etapes-de-linitramfs-i",
    "href": "slides/02-booting-part2.html#etapes-de-linitramfs-i",
    "title": "Arrencada del sistema (Part 2)",
    "section": "Etapes de l’Initramfs (I)",
    "text": "Etapes de l’Initramfs (I)\n\nDescompressió a la RAM\n\nEl fitxer CPIO de l’initramfs es descomprimeix a un sistema de fitxers temporal a RAM (tmpfs), creant l’entorn mínim necessari per iniciar el kernel.\n\n\nExecució de l’script /init\n\n/init és l’entrypoint principal de l’initramfs.\n\nExecuta la seqüència d’inicialització: muntatge de sistemes virtuals, càrrega de mòduls i preparació de l’entorn.\n\n\nCreació del sistema de fitxers temporal\n\nMuntatge de /proc, /sys i /dev.\n\nCreació de directoris temporals (/tmp, /run) per permetre que els scripts i utilitats funcionin.",
    "crumbs": [
      "Diapositives",
      "Unitat 02 · Arrencada del sistema (Part 2)"
    ]
  },
  {
    "objectID": "slides/02-booting-part2.html#etapes-de-linitramfs-ii",
    "href": "slides/02-booting-part2.html#etapes-de-linitramfs-ii",
    "title": "Arrencada del sistema (Part 2)",
    "section": "Etapes de l’Initramfs (II)",
    "text": "Etapes de l’Initramfs (II)\n\nCarregar mòduls del kernel\n\nCarrega controladors necessaris per accedir a maquinari (discos, controladors de xarxa, LVM, RAID, xifrat).\n\nSi els mòduls estan integrats al kernel, aquesta etapa pot ser mínima o nul·la.\n\nMuntatge de la partició arrel real\n\nLocalitza la partició arrel (per exemple /dev/sda1 o UUID=...).\n\nMuntatge en un punt temporal (/mnt/root o similar).\n\n\nTransició al sistema complet (switch_root)\n\nSubstitueix l’entorn temporal de l’initramfs pel sistema de fitxers real.\n\nExecuta el binari init del sistema complet (normalment /sbin/init o systemd).",
    "crumbs": [
      "Diapositives",
      "Unitat 02 · Arrencada del sistema (Part 2)"
    ]
  },
  {
    "objectID": "slides/02-booting-part2.html#etapes-de-linitramfs-iii",
    "href": "slides/02-booting-part2.html#etapes-de-linitramfs-iii",
    "title": "Arrencada del sistema (Part 2)",
    "section": "Etapes de l’Initramfs (III)",
    "text": "Etapes de l’Initramfs (III)\n\nAlliberament de l’initramfs\n\nDestruir l’entorn temporal a RAM.\n\nAlliberar la memòria utilitzada pel sistema de fitxers temporal, deixant el control complet al sistema operatiu.",
    "crumbs": [
      "Diapositives",
      "Unitat 02 · Arrencada del sistema (Part 2)"
    ]
  },
  {
    "objectID": "slides/02-booting-part2.html#característiques-de-linitramfs",
    "href": "slides/02-booting-part2.html#característiques-de-linitramfs",
    "title": "Arrencada del sistema (Part 2)",
    "section": "Característiques de l’Initramfs",
    "text": "Característiques de l’Initramfs\n\nFacilita la portabilitat i modularitat del kernel, permetent arrencar diferents configuracions de maquinari sense necessitat de recompilar el kernel cada cop.\nNo sempre està present, pot estar buit o omès si el sistema no necessita un espai RAM inicial (per exemple, en sistemes simples o compilacions estàtiques del nucli).\nEs configura durant la compilació del nucli make menuconfig i es pot definir el contingut de l’initramfs amb un fitxer de configuració, s’utiltizen variables:\n\nCONFIG_BLK_DEV_INITRD: Activa la creació de l’initramfs.\nCONFIG_INITRAMFS_SOURCE: Especifica el fitxer CPIO, un directori o un fitxer d’especificació.\n\nTambé es pot personalitzar segons les necessitats del sistema, permetent afegir mòduls del kernel, scripts personalitzats o utilitats addicionals.",
    "crumbs": [
      "Diapositives",
      "Unitat 02 · Arrencada del sistema (Part 2)"
    ]
  },
  {
    "objectID": "slides/02-booting-part2.html#contingut-de-linitramfs",
    "href": "slides/02-booting-part2.html#contingut-de-linitramfs",
    "title": "Arrencada del sistema (Part 2)",
    "section": "Contingut de l’initramfs",
    "text": "Contingut de l’initramfs\n\nFitxers executables\n\nEx: BusyBox, que encapsula moltes utilitats Unix (ls, cp, mount, shell, etc.).\n\nPoden incloure altres programes compilats estàticament.\n\nMòduls del kernel\n\nControladors per discos, xarxes, sistemes RAID o LVM.\n\nSón carregats si no estan integrats dins del nucli.\n\nFitxers de dispositiu i sistemes especials\n\n/dev conté dispositius com tty o null.\n\nGestionats per utilitats com mdev o udev.\n\n\n\nTots aquests elements es troben comprimits en un fitxer CPIO, descomprimits a RAM durant l’arrencada i executats per l’script /init.",
    "crumbs": [
      "Diapositives",
      "Unitat 02 · Arrencada del sistema (Part 2)"
    ]
  },
  {
    "objectID": "slides/02-booting-part2.html#configuració-de-linitramfs",
    "href": "slides/02-booting-part2.html#configuració-de-linitramfs",
    "title": "Arrencada del sistema (Part 2)",
    "section": "Configuració de l’initramfs",
    "text": "Configuració de l’initramfs\nL’initramfs es pot personalitzar segons les necessitats del sistema, permetent afegir mòduls del kernel, scripts personalitzats o utilitats addicionals. La configuració depèn de la distribució:\nDebian/Ubuntu\nupdate-initramfs -u -k &lt;versió&gt;\n# -u actualitza l'initramfs\n# -k especifica la versió del nucli\n\nFedora/Red Hat\ndracut -f /boot/initramfs-&lt;versió&gt;.img &lt;versió&gt;\n# -f força la regeneració\n# El primer argument és la ruta on es vol guardar l'initramfs generat\n# El segon argument és la versió del nucli",
    "crumbs": [
      "Diapositives",
      "Unitat 02 · Arrencada del sistema (Part 2)"
    ]
  },
  {
    "objectID": "slides/02-booting-part2.html#initramfs-tools-debian-i",
    "href": "slides/02-booting-part2.html#initramfs-tools-debian-i",
    "title": "Arrencada del sistema (Part 2)",
    "section": "initramfs-tools (Debian) (I)",
    "text": "initramfs-tools (Debian) (I)\n\n/etc/initramfs-tools/modules\nLlista de mòduls addicionals del kernel a incloure a l’initramfs, per exemple controladors de xarxa o discos RAID.\n\n/etc/initramfs-tools/hooks/\nScripts que s’executen durant la creació de l’initramfs, útils per afegir fitxers o directoris personalitzats.\n\n/etc/initramfs-tools/conf.d/\nFitxers de configuració addicionals per modificar paràmetres específics de l’initramfs.\n\n/etc/initramfs-tools/initramfs.conf\nConfiguració principal, inclou opcions com compressió, ús de scripts, paràmetres de muntatge.\n\n/usr/share/initramfs-tools/\nScripts i fitxers estàndard utilitzats per initramfs-tools, no modificats normalment.",
    "crumbs": [
      "Diapositives",
      "Unitat 02 · Arrencada del sistema (Part 2)"
    ]
  },
  {
    "objectID": "slides/02-booting-part2.html#initramfs-tools-debian-ii",
    "href": "slides/02-booting-part2.html#initramfs-tools-debian-ii",
    "title": "Arrencada del sistema (Part 2)",
    "section": "initramfs-tools (Debian) (II)",
    "text": "initramfs-tools (Debian) (II)\n\n/etc/initramfs-tools/scripts/\nScripts que s’executen durant l’arrencada:\n\ninit-top/ → scripts executats just després de descomprimir l’initramfs i abans de muntar /proc, /sys i /dev. Ideal per inicialitzar serveis crítics o preparar dispositius especials.\n\ninit-bottom/ → scripts executats just abans de fer switch_root al sistema complet. Útil per passos finals com muntar la partició arrel, desbloquejar LUKS o activar LVM.\n\nlocal-bottom/ → scripts addicionals definits per l’administrador.\nlocal-top/ → scripts addicionals definits per l’administrador.",
    "crumbs": [
      "Diapositives",
      "Unitat 02 · Arrencada del sistema (Part 2)"
    ]
  },
  {
    "objectID": "slides/02-booting-part2.html#initramfs-tools-debian-ii-1",
    "href": "slides/02-booting-part2.html#initramfs-tools-debian-ii-1",
    "title": "Arrencada del sistema (Part 2)",
    "section": "initramfs-tools (Debian) (II)",
    "text": "initramfs-tools (Debian) (II)\n\npremount/ → scripts executats abans de muntar la partició arrel. Ideal per preparar dispositius o sistemes de fitxers especials.\nmount/ → scripts executats durant el muntatge de la partició arrel. Útil per passos específics relacionats amb el muntatge.\ncleanup/ → scripts executats després de fer switch_root al sistema complet. Ideal per netejar recursos temporals o realitzar tasques posteriors a l’arrencada.",
    "crumbs": [
      "Diapositives",
      "Unitat 02 · Arrencada del sistema (Part 2)"
    ]
  },
  {
    "objectID": "slides/02-booting-part2.html#dracut-fedorared-hat",
    "href": "slides/02-booting-part2.html#dracut-fedorared-hat",
    "title": "Arrencada del sistema (Part 2)",
    "section": "dracut (Fedora/Red Hat)",
    "text": "dracut (Fedora/Red Hat)\n\n/etc/dracut.conf\nFitxer de configuració principal de Dracut, on es poden definir opcions generals: compressió, tipus de fitxer d’initramfs, paràmetres del kernel, etc.\n\n/etc/dracut.conf.d/\nFitxers de configuració addicionals, útils per a configuracions específiques de mòduls o projectes.\n\n/usr/lib/dracut/modules.d/\nConté mòduls estàndard de Dracut (ex: mòduls de xarxa, lvm, cryptsetup), carregats automàticament segons la configuració.\n\n/etc/dracut/modules.d/\nMòduls personalitzats creats per l’administrador, per afegir scripts o fitxers específics.\n\n/usr/share/dracut/\nConté scripts i fitxers estàndard utilitzats durant la generació de l’initramfs, igual que a initramfs-tools.",
    "crumbs": [
      "Diapositives",
      "Unitat 02 · Arrencada del sistema (Part 2)"
    ]
  },
  {
    "objectID": "slides/02-booting-part2.html#quan-regenerar-linitramfs",
    "href": "slides/02-booting-part2.html#quan-regenerar-linitramfs",
    "title": "Arrencada del sistema (Part 2)",
    "section": "Quan regenerar l’initramfs?",
    "text": "Quan regenerar l’initramfs?\n\nActualització del nucli: Quan es compila o instal·la un nou kernel, l’initramfs associat ha de ser regenerat per garantir que carrega correctament els mòduls i el maquinari necessari.\nConfiguració RAID: Si es modifiquen o s’afegeixen sistemes RAID, l’initramfs ha de reflectir aquests canvis per assegurar un arrencada correcta.\nXifrat de discos: Per a sistemes amb particions xifrades (LUKS), cal actualitzar l’initramfs després de canvis en la configuració de xifrat per poder accedir a les particions durant l’arrencada.\nConfiguració de xarxa: Si es canvien components de xarxa que s’utilitzen en el procés d’arrencada (sistemes amb arrencada PXE).",
    "crumbs": [
      "Diapositives",
      "Unitat 02 · Arrencada del sistema (Part 2)"
    ]
  },
  {
    "objectID": "slides/02-booting-part2.html#cas-dus-usb-amb-clau-de-desxifrat",
    "href": "slides/02-booting-part2.html#cas-dus-usb-amb-clau-de-desxifrat",
    "title": "Arrencada del sistema (Part 2)",
    "section": "Cas d’us: USB amb clau de desxifrat",
    "text": "Cas d’us: USB amb clau de desxifrat\nUn cas d’ús comú de l’initramfs és en sistemes amb particions xifrades amb LUKS que utilitzen una clau emmagatzemada en un dispositiu USB per desxifrar la partició arrel durant l’arrencada.\n\n\n\nMunti els sistemes virtuals necessaris (/proc, /sys).\n\nMunti la unitat USB que conté la clau.\n\nLlegeixi la clau i desxifri la partició LUKS.\n\nActivar volums LVM si cal.\n\nMuntar la partició arrel i transferir el control amb switch_root.\n\n\n#!/bin/busybox sh\nmount -t proc proc /proc\nmount -t sysfs sys /sys\nmount /dev/sdb1 /mnt\nKEYFILE=/mnt/keyfile\ncryptsetup luksOpen /dev/sda1 crypted --key-file $KEYFILE\necho \"Retira el dispositiu USB i prem Enter per continuar.\"\nread\nvgchange -a y\nmount /dev/mapper/vg-root /mnt\nexec switch_root /mnt /sbin/init",
    "crumbs": [
      "Diapositives",
      "Unitat 02 · Arrencada del sistema (Part 2)"
    ]
  },
  {
    "objectID": "slides/02-booting-part2.html#exercicis-propostas",
    "href": "slides/02-booting-part2.html#exercicis-propostas",
    "title": "Arrencada del sistema (Part 2)",
    "section": "Exercicis Propostas",
    "text": "Exercicis Propostas\n\nModificant la contrasenya de l’usuari root a través del GRUB\nDesxifrat automàtic mitjançant clau en disc secundari (USB emulat)\nDiscussió: Secure Boot és realment segur?: Cerca notícies recents sobre Secure Boot i comparteix-les al fòrum del curs. Debatiu sobre avantatges, desavantatges, vulnerabilitats conegudes i experiències personals.",
    "crumbs": [
      "Diapositives",
      "Unitat 02 · Arrencada del sistema (Part 2)"
    ]
  },
  {
    "objectID": "slides/02-booting-part2.html#thats-all",
    "href": "slides/02-booting-part2.html#thats-all",
    "title": "Arrencada del sistema (Part 2)",
    "section": "That’s all",
    "text": "That’s all\n\n\n\n\n\n\n\n\n\nTake Home Message\n\n\nEl procés d’arrencada és un procés complex. Els administradors de sistemes han de conèixer aquest procés per poder gestionar i solucionar problemes durant l’arrencada del sistema i garantir un sistema segur, estable i eficient.",
    "crumbs": [
      "Diapositives",
      "Unitat 02 · Arrencada del sistema (Part 2)"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "AMSA 105013: Administració de Sistemes",
    "section": "",
    "text": "Benvinguts al curs d’Administració de sistemes i aplicacions (AMSA). Aquest curs està dissenyat per proporcionar als estudiants els coneixements i habilitats necessaris per gestionar i mantenir sistemes informàtics en entorns professionals.\n\n\n\nCourse Title\nSystems and Applications Administration and Management\n\n\nSemester\n1st Semester of the Bachelor’s Degree in Computer Engineering\n\n\nCourse Year\nThird Year\n\n\nProfessor\nJordi Mateo\n\n\nSchedule\n📅\n\n\nCourse Guide\n📚\n\n\nSchool\n\n\n\nUniversity\n\n\n\nDepartment"
  },
  {
    "objectID": "projects/01-project/01-project.html",
    "href": "projects/01-project/01-project.html",
    "title": "Pràctica 01: Snapshots i restauració amb systemd i initramfs",
    "section": "",
    "text": "Comprendre el procés d’arrencada en Linux (GRUB → initramfs → systemd).\nConfigurar i gestionar serveis systemd.\nCrear snapshots de l’estat del sistema i restaurar-los.\nIntroduir-se a la personalització d’initramfs i opcionalment GRUB.",
    "crumbs": [
      "Projectes",
      "Projecte 1 · Snapshots i Backups amb systemd i initramfs"
    ]
  },
  {
    "objectID": "projects/01-project/01-project.html#objectius",
    "href": "projects/01-project/01-project.html#objectius",
    "title": "Pràctica 01: Snapshots i restauració amb systemd i initramfs",
    "section": "",
    "text": "Comprendre el procés d’arrencada en Linux (GRUB → initramfs → systemd).\nConfigurar i gestionar serveis systemd.\nCrear snapshots de l’estat del sistema i restaurar-los.\nIntroduir-se a la personalització d’initramfs i opcionalment GRUB.",
    "crumbs": [
      "Projectes",
      "Projecte 1 · Snapshots i Backups amb systemd i initramfs"
    ]
  },
  {
    "objectID": "projects/01-project/01-project.html#context",
    "href": "projects/01-project/01-project.html#context",
    "title": "Pràctica 01: Snapshots i restauració amb systemd i initramfs",
    "section": "Context",
    "text": "Context\nEn entorns reals, és freqüent necessitar tornar a un estat anterior del sistema després d’una fallada o una actualització incorrecta. Aquesta pràctica simula aquest escenari: configurarem un mecanisme de snapshots i un procés per restaurar-los en arrencar la màquina.",
    "crumbs": [
      "Projectes",
      "Projecte 1 · Snapshots i Backups amb systemd i initramfs"
    ]
  },
  {
    "objectID": "projects/01-project/01-project.html#entorn-de-treball",
    "href": "projects/01-project/01-project.html#entorn-de-treball",
    "title": "Pràctica 01: Snapshots i restauració amb systemd i initramfs",
    "section": "Entorn de treball",
    "text": "Entorn de treball\n\nMàquina virtual amb Debian 12 i amb UEFI amb 20 GB de disc.\nDisc virtual addicional de 20 GB per emmagatzemar els snapshots.",
    "crumbs": [
      "Projectes",
      "Projecte 1 · Snapshots i Backups amb systemd i initramfs"
    ]
  },
  {
    "objectID": "projects/01-project/01-project.html#preparació-de-la-màquina-virtual",
    "href": "projects/01-project/01-project.html#preparació-de-la-màquina-virtual",
    "title": "Pràctica 01: Snapshots i restauració amb systemd i initramfs",
    "section": "Preparació de la màquina virtual",
    "text": "Preparació de la màquina virtual\nUn cop arrencada la màquina virtual, afegiu un disc dur addicional de 20 GB. Aquest disc serà utilitzat per emmagatzemar els snapshots. Per exemple, si el disc principal és /dev/nvme0n1, el nou disc podria ser /dev/nvme0n2. Un cop afegit el disc, inicieu la màquina virtual i comproveu que el nou disc és visible amb lsblk.\nUn cop identificat el nou disc, cal crear-hi un sistema de fitxers i muntar-lo. Per exemple, si el nou disc és /dev/nvme0n2, podeu fer-ho així:\n# Com a root o amb sudo\nmkfs.ext4 /dev/nvme0n2\nmount /dev/nvme0n2 /mnt\nmkdir -p /mnt/snapshots\nPer evitar haver de muntar el disc manualment cada cop, afegiu una entrada a /etc/fstab. Per exemple, afegiu aquesta línia al final del fitxer:\n/dev/nvme0n2  /mnt  ext4  defaults  0  2\n\n\n\n\n\n\nAlertaAdvertència\n\n\n\nAssegureu-vos d’indicar el disc correcte que pot ser nvme0n2, sdb, vdb,… No utilitzeu el disc principal on està instal·lat el sistema operatiu.\n\n\nUn cop muntat el disc, instal·leu rsync si no està instal·lat:\n# Com a root o amb sudo\napt update\napt install rsync\nEn cas de problemes amb el update, igual necessitareu fer un apt upgrade abans.",
    "crumbs": [
      "Projectes",
      "Projecte 1 · Snapshots i Backups amb systemd i initramfs"
    ]
  },
  {
    "objectID": "projects/01-project/01-project.html#tasques",
    "href": "projects/01-project/01-project.html#tasques",
    "title": "Pràctica 01: Snapshots i restauració amb systemd i initramfs",
    "section": "Tasques",
    "text": "Tasques\n\nCrear snapshots amb rsync (2 punts) 📝\n\nEscriure un script que creï snapshots dels directoris /home, /opt, /bin, /usr a /mnt/snapshots utilitzant rsync.\nCrea un primer snapshot manualment per tenir una base de dades inicial i anomeneu-lo snapshot_00000000_000000, feu servir script com a root.\nProvar l’script manualment i assegurar-se que es poden crear diversos snapshots.\nUtilitzar un format de nom com snapshot_YYYYMMDD_HHMMSS per al directori.\nEls snapshots han de ser còpies completes: /home, /opt, /bin, /usr . No cal comprimir aquests snapshots. Poden ser carpetes independents utilitzant la nomenclatura indicada.\nImplementar una política per mantenir el snapshot inicial i els 3 snapshots més recents, eliminant els més antics.\n\nAutomatitzar la creació de snapshots amb systemd (3 punts) ⚙️\n\nCrear un servei systemd que executi l’script de creació de snapshots a cada apagada de la màquina.\nValidar que cada vegada que s’aturi la màquina es crea un nou snapshot.\n\nRestaurar snapshots en arrencada amb systemd (3 punts) 🔄\n\nEscriure un script que mostri un llistat de snapshots disponibles i permeti seleccionar-ne un per restaurar.\nCrear un servei systemd que s’executi abans de multi-user.target i cridi aquest script.\nComprovar que en arrencar la màquina es mostra el menú de snapshots.\nValidar que es pot restaurar un snapshot seleccionat.\n\nRestaurar snapshots des d’initramfs (1/2 punts) 🚀\n\nAfegir un parametre al kernel per indicar el fitxer de snapshot a restaurar. Aquest paràmetres’anomenarà snapshot= i rebrrà el nom de la snapshot a restaurar, per exemple snapshot=snapshot_20240101_120000. En cas de no rebre cap paràmetre, no es restaurarà cap snapshot.\nAfegir un script a initramfs que carregui el disc secundari, llegeixi el paràmetre i restauri el snapshot abans de muntar /.\n\nSimple: Utilitzant comandes integrades a initramfs. (1 punt)\nAvançat: Afegint programari compilat estaticament a initramfs. (2 punts)\n\nReconstruir l’initramfs i validar que s’ha restaurat el snapshot correcte.",
    "crumbs": [
      "Projectes",
      "Projecte 1 · Snapshots i Backups amb systemd i initramfs"
    ]
  },
  {
    "objectID": "projects/01-project/01-project.html#organització-i-lliurament",
    "href": "projects/01-project/01-project.html#organització-i-lliurament",
    "title": "Pràctica 01: Snapshots i restauració amb systemd i initramfs",
    "section": "Organització i lliurament",
    "text": "Organització i lliurament\nAccediu a l’activitat a través de l’enllaç al Github Classroom. Un cop acceptada l’activitat, clonareu el repositori a la vostra màquina local i començareu a treballar. Podeu treballar amb grups de fins a 3 persones.\n📂 practica01/\n├── SOLUCIÓ.md               \n├── scripts/\n│   ├── create_snapshot.sh    \n│   ├── restore_snapshot.sh   \n│   └── helpers.sh            \n├── systemd/\n│   ├── snapshot.service      \n│   └── restore.service       \n├── initramfs/\n│   └── snapshot_menu        \n└── grub/\n    └── 40_custom_snapshot    \nEl document SOLUCIÓ.md ha d’incloure:\n\nExplicació de cada part de la pràctica i comandes utilitzades.\nDiferències entre les comandes cp, rsync i tar per fer còpies de seguretat.\nConjunt de proves realitzades per validar cada part.\nEnregistrament en format vídeo de la consola on es demostri el funcionament correcte de les diferents parts de la pràctica, o bé captures de pantalla on es mostri el procés i els resultats.\nDocumentació o prompts consultats.",
    "crumbs": [
      "Projectes",
      "Projecte 1 · Snapshots i Backups amb systemd i initramfs"
    ]
  },
  {
    "objectID": "laboratories/02-network/01-aws-wordpress.html",
    "href": "laboratories/02-network/01-aws-wordpress.html",
    "title": "Desplegament d’una aplicació web amb alta disponibilitat amb AWS",
    "section": "",
    "text": "En aquest laboratori intensiu, dissenyarem i implementarem una arquitectura de xarxa robusta i segura per allotjar una aplicació de WordPress. L’arquitectura es basa en la separació de capes (pública, aplicació, dades) i l’ús de Zones de Disponibilitat (AZ) per garantir que el nostre WordPress sigui altament disponible i resistent a fallades.",
    "crumbs": [
      "Laboratoris",
      "Networking",
      "Laboratori 03 · Desplegament d'una aplicació web amb alta disponibilitat amb AWS"
    ]
  },
  {
    "objectID": "laboratories/02-network/01-aws-wordpress.html#diagrama-de-larquitectura",
    "href": "laboratories/02-network/01-aws-wordpress.html#diagrama-de-larquitectura",
    "title": "Desplegament d’una aplicació web amb alta disponibilitat amb AWS",
    "section": "Diagrama de l’Arquitectura",
    "text": "Diagrama de l’Arquitectura\n\n\n\nEsquema de components, conexions i elements de l’arquitectura\n\n\nLa imatge mostra com a través d’internet, els usuaris accedeixen al Load Balancer, que distribueix el tràfic a les instàncies EC2 que allotgen WordPress. Aquestes instàncies es connecten a la base de dades RDS per gestionar el contingut de WordPress. La instància EC2 en la DMZ permet l’accés segur per a l’administració dels recursos privats.",
    "crumbs": [
      "Laboratoris",
      "Networking",
      "Laboratori 03 · Desplegament d'una aplicació web amb alta disponibilitat amb AWS"
    ]
  },
  {
    "objectID": "laboratories/02-network/01-aws-wordpress.html#objectius",
    "href": "laboratories/02-network/01-aws-wordpress.html#objectius",
    "title": "Desplegament d’una aplicació web amb alta disponibilitat amb AWS",
    "section": "Objectius",
    "text": "Objectius\n\nDissenyar i implementar una arquitectura de xarxa segura i altament disponible a AWS.\nConfigurar VPCs, subxarxes, taules de rutes i grups de seguretat.\nConfigurar una VPN segura per a l’accés administratiu.\nConfigurar un load balancer per distribuir el tràfic a les instàncies EC2.",
    "crumbs": [
      "Laboratoris",
      "Networking",
      "Laboratori 03 · Desplegament d'una aplicació web amb alta disponibilitat amb AWS"
    ]
  },
  {
    "objectID": "laboratories/02-network/01-aws-wordpress.html#requeriments-prèvis",
    "href": "laboratories/02-network/01-aws-wordpress.html#requeriments-prèvis",
    "title": "Desplegament d’una aplicació web amb alta disponibilitat amb AWS",
    "section": "Requeriments Prèvis",
    "text": "Requeriments Prèvis\n\nAccés al curs AWS Academy Learner Lab.\nCompletar el laboratori Desplegament d’una aplicació web amb AWS per entendre els conceptes bàsics d’AWS i la configuració inicial de WordPress.",
    "crumbs": [
      "Laboratoris",
      "Networking",
      "Laboratori 03 · Desplegament d'una aplicació web amb alta disponibilitat amb AWS"
    ]
  },
  {
    "objectID": "laboratories/02-network/01-aws-wordpress.html#vpc-i-subxarxes",
    "href": "laboratories/02-network/01-aws-wordpress.html#vpc-i-subxarxes",
    "title": "Desplegament d’una aplicació web amb alta disponibilitat amb AWS",
    "section": "VPC i Subxarxes",
    "text": "VPC i Subxarxes\nEl primer pas en la nostra arquitectura és definir una VPC (Virtual Private Cloud) i les subxarxes necessàries per aïllar els diferents components de l’aplicació. La VPC proporcionarà un entorn de xarxa virtualitzat on podrem desplegar els nostres recursos d’AWS. La configurarem amb la xarxa 10.0.0.0/16, la qual ens proporciona fins a 65.536 adreces IP, més que suficients per al nostre cas d’ús.\n\n\n\n\n\n\nNotaCIDR, Hosts i Adreces Reservades 🧠\n\n\n\nLa màscara de subxarxa determina el nombre d’adreces IP disponibles dins d’una xarxa o subxarxa. Això s’expressa mitjançant la Notació CIDR (Classless Inter-Domain Routing), on el valor (/n) indica la quantitat de bits reservats per a la part de Xarxa. Una màscara de subxarxa de /16 significa que els primers 16 bits de l’adreça IP estan reservats per a la identificació de la xarxa, deixant els altres 16 bits per a la identificació dels hosts. Això permet tenir fins a 65.536 adreces IP (\\(2^{32-16}\\)) dins d’aquesta xarxa.\nQuan feu el Subnetting per crear subxarxes dins de la vostra VPC, esteu augmentant el valor CIDR (per exemple, de /16 a /24), per tal de reduir la mida de les subxarxes i aïllar millor el tràfic. Per exemple, una subxarxa amb CIDR /24 té 256 adreces IP (\\(2^{32-24}\\)).\nRecordeu que el total d’adreces calculat no és el total d’adreces útils per als vostres servidors (hosts). Algunes adreces es reserven per a usos especials, com identificar la xarxa i la difusió (broadcast).\n\n\nPodem definir la VPC a través de la interfície web d’AWS, utilitzant els formularis disponibles:\n\n\n\nDefinició de la VPC utilitzant AWS\n\n\n\nCreació de les subxarxes\nA continuació, afegirem les subxarxes necessàries per a la nostra arquitectura. Aneu a VPC → Subnets → Create subnet. Seleccioneu la VPC que acabem de crear i afegiu les subxarxes següents:\n\nAMSA-DMZ-01: Subxarxa pública a la zona us-east-1a. Aquesta subxarxa allotjarà la instància EC2 que farà de pont segur d’accés (mitjançant túnel SSH) per a la gestió de tots els recursos privats. (10.0.1.0/24).\n\n\n\n\nAMSA-DMZ-01\n\n\n\nAMSA-DMZ-02: Subxarxa pública a la zona us-east-1b. Aquesta subxarxa allotjarà la instància EC2 que farà de pont segur d’accés (mitjançant túnel SSH) per a la gestió de tots els recursos privats. (10.0.2.0/24).\n\n\n\n\nAMSA-DMZ-02\n\n\n\nAMSA-Private01: Subxarxa privada per a les instàncies de WordPress a la zona de disponibilitat us-east-1a. (10.0.3.0/24).\n\n\n\n\nAMSA-Private01\n\n\n\nAMSA-Private02: Subxarxa privada per a les instàncies de WordPress a la zona de disponibilitat us-east-1b. (10.0.4.0/24)\n\n\n\n\nAMSA-Private02\n\n\n\nAMSA-Data: Subxarxa privada per a dades a la zona de disponibilitat us-east-1c. (10.0.5.0/24)\n\n\n\n\nAMSA-Data",
    "crumbs": [
      "Laboratoris",
      "Networking",
      "Laboratori 03 · Desplegament d'una aplicació web amb alta disponibilitat amb AWS"
    ]
  },
  {
    "objectID": "laboratories/02-network/01-aws-wordpress.html#taules-denrutament-i-associacions",
    "href": "laboratories/02-network/01-aws-wordpress.html#taules-denrutament-i-associacions",
    "title": "Desplegament d’una aplicació web amb alta disponibilitat amb AWS",
    "section": "Taules d’Enrutament i Associacions",
    "text": "Taules d’Enrutament i Associacions\nPer gestionar les rutes del tràfic i determinar com es distribueix entre les subxarxes, crearem taules de rutes i les associem a les subxarxes corresponents.\n\nConfiguració del Gateway d’Internet\nUtilitzarem un Gateway d’Internet (IGW) per permetre que les subxarxes públiques (AMSA-DMZ-01 i AMSA-DMZ-02) tinguin accés a Internet tant per a tràfic entrant com sortint. Per fer-ho, primer crearem el IGW i després l’associarem a la nostra VPC.\nEl primer pas és crear el Gateway d’Internet. Aneu a VPC → Internet Gateways → Create internet gateway. Un cop creat, l’anomeneu AMSA-IG.\n\n\n\nGateway d’Internet per a la VPC\n\n\nEl segon pas és associar el Gateway d’Internet amb la VPC. Seleccioneu el Gateway d’Internet que acabem de crear i feu clic a Actions → Attach to VPC. Seleccioneu la VPC AMSA-VPC i feu clic a Attach internet gateway.\n\n\n\nAssociació del Gateway d’Internet amb la VPC\n\n\n\n\n\nAssociació del Gateway d’Internet amb la VPC\n\n\n\n\n\n\n\n\nAlertaAttached IGW 🛑\n\n\n\nAssegureu-vos que el Gateway d’Internet estigui correctament associat a la VPC. Si no està associat, les subxarxes públiques no podran accedir a Internet.\n\n\n\n\nCreació de les taules de rutes\nCada subxarxa necessita una taula de rutes per definir com es dirigeix el tràfic sortint i entrant. Crearem taules de rutes específiques per a cada tipus de subxarxa (pública i privada) i les associem a les subxarxes corresponents.\n\nEnrutament per a les subxarxes públiques (DMZ)\nEl primer pas és crear la taula de rutes per a les subxarxes públiques. Aneu a VPC → Route Tables → Create route table. Seleccioneu la VPC AMSA-VPC i anomeneu la taula de rutes AMSA-DMZ01-RT.\n\n\n\nTaula de rutes per a la subxarxa AMSA-DMZ01-RT\n\n\nEl segon pas és associar la taula de rutes (AMSA-DMZ01-RT) amb la subxarxa AMSA-DMZ-01 i permetre el tràfic de sortida a Internet a través del Gateway d’Internet que hem creat anteriorment.\n\n\n\nAssociació de la taula de rutes amb la subxarxa AMSA-DMZ-01\n\n\nEl tercer pas és permetre el tràfic de sortida a Internet a través del Gateway d’Internet que hem creat anteriorment. Per fer-ho aneu a la secció Routes i clicareu a Edit routes. A continuació, Add route i editareu (Destination: 0.0.0.0/0; Target:Seleccionar el AMSA-IG).\n\n\n\nPermetem el tràfic amb l’exterior a través del IG\n\n\n\n\n\n\n\n\nAlertaAMSA-DMZ-02 🛑\n\n\n\nRealitzeu els mateixos passos per a la subxarxa AMSA-DMZ-02, modificant només el nom de la taula de rutes i l’associació amb la subxarxa.\n\n\n\n\nEnrutament per a les subxarxes privades\nLes subxarxes privades no tenen accés directe a Internet per motius de seguretat. Per tant, necessitem configurar les taules de rutes per a aquestes subxarxes de manera que puguin accedir a Internet a través d’un NAT Gateway (Network Address Translation Gateway). Això permetrà que les instàncies dins de les subxarxes privades puguin iniciar connexions cap a l’exterior, però impedirà que l’exterior iniciï connexions cap a elles.\n\n\n\n\n\n\nNotaNAT Gateway 🧠\n\n\n\nUn NAT Gateway és un servei gestionat per AWS que permet a les instàncies en una subxarxa privada accedir a Internet per a actualitzacions de programari, descàrregues de paquets, etc., sense exposar aquestes instàncies directament a Internet. El NAT Gateway tradueix les adreces IP privades de les instàncies a una adreça IP pública quan aquestes instàncies fan peticions a Internet.\n\n\nPer crear el NAT Gateway, necessitem una IP elàstica (Elastic IP). Per tant, primer crearem una IP elàstica i després la utilitzarem per crear el NAT Gateway. L’anomeneu AMSA-NAT-EIP.\n\n\n\nCreació de la IP elàstica\n\n\n\n\n\nActualitzar el nom de la IP elàstica\n\n\nUn cop tenim la IP elàstica, podem crear el NAT Gateway. L’anomeneu AMSA-NG i l’associeu a la subxarxa AMSA-DMZ-01.\n\n\n\nCreació del NAT Gateway\n\n\nCrearem la taula de rutes (AMSA-Private01-RT) per a la subxarxa AMSA-Private01 i l’associarem a la subxarxa. Aquesta taula de rutes permetrà que les instàncies dins d’aquesta subxarxa accedeixin a Internet a través del NAT Gateway.\n\n\n\nTaula de rutes per a la subxarxa AMSA-Private01\n\n\nEl segon pas és associar la taula de rutes (AMSA-Private01-RT) amb la subxarxa AMSA-Private01 i permetre el tràfic de sortida a Internet a través del NAT Gateway que hem creat anteriorment.\n\n\n\nCreació de la taula de rutes per a la subxarxa AMSA-Private01\n\n\nEl tercer pas és permetre el tràfic de sortida a Internet a través del NAT Gateway que hem creat anteriorment. Per fer-ho aneu a la secció Routes i clicareu a Edit routes. A continuació, Add route i editareu (Destination: 0.0.0.0/0; Target:Seleccionar el AMSA-NG).\n\n\n\n\n\n\nAlertaAMSA-Private02 🛑\n\n\n\nRepetiu els mateixos passos per a la subxarxa AMSA-Private02, modificant només el nom de la taula de rutes i l’associació amb la subxarxa.\n\n\n\n\nEnrutament per a la subxarxa de dades (AMSA-Data)\nLa subxarxa AMSA-Data no allotjarà instàncies que necessitin accés a Internet. Per tant, no necessitem configurar cap ruta per a aquesta subxarxa. Crearem una taula de rutes buida i l’associarem a la subxarxa AMSA-Data. Aquesta xarxa serà completament aïllada i només permetrà la comunicació interna dins de la VPC.",
    "crumbs": [
      "Laboratoris",
      "Networking",
      "Laboratori 03 · Desplegament d'una aplicació web amb alta disponibilitat amb AWS"
    ]
  },
  {
    "objectID": "laboratories/02-network/01-aws-wordpress.html#grups-de-seguretat",
    "href": "laboratories/02-network/01-aws-wordpress.html#grups-de-seguretat",
    "title": "Desplegament d’una aplicació web amb alta disponibilitat amb AWS",
    "section": "Grups de Seguretat",
    "text": "Grups de Seguretat\nEls grups de seguretat (Security Groups) són una eina per controlar el tràfic de xarxa de les instàncies i altres recursos d’AWS, actuant com un tallafocs virtual. Permeten definir regles que especifiquen quines connexions estan permeses tant d’entrada (inbound) com de sortida (outbound).\n\nTrafic inbound: Permet decidir quins tipus de connexions entrants (cap al recurs) són permeses.\nTrafic outbound: Controla quines connexions sortints (des del recurs cap a altres destinacions) estan autoritzades.\n\n\nGrup de Seguretat per a les instàncies EC2\n\nConnexions entrants (inbound) per als serveis web HTTP (port 80) i HTTPS (port 443), accessibles des de qualsevol origen.\nConnexions SSH (port 22) per a administració remota, també accessibles des de qualsevol origen (inicialment, però més endavant es restringiran).\nTotes les connexions sortints (outbound), que per defecte estan permeses a AWS, cosa que permet a les instàncies EC2 comunicar-se amb altres recursos com ara RDS.\n\nPer fer-ho, navegarem a la consola de VPC d’AWS, seleccionarem la secció Security Groups i clicarem a Create security group. A continuació, omplirem els camps amb la informació necessària i clicarem a Create security group. El podeu anomenar AMSA-WP-SG.\n\n\n\nGrup de Seguretat per a les instàncies EC2\n\n\n\n\n\n\n\n\nNotaNota sobre la seguretat 🔐\n\n\n\nEn aquest moment, estem permetent tot el tràfic de xarxa per als serveis web i SSH. Quan ho tinguem tot configurat, restringirem aquest accés únicament al trafic entrant provinent del balancejador de càrrega pels serveis web i a la nostra xarxa interna per a SSH.\n\n\n\n\nGrup de Seguretat per a la base de dades RDS\n\nConnexions inbound: Només permetrà tràfic al port 3306 (MySQL) i exclusivament des de les instàncies EC2 que pertanyin al grup de seguretat AMSA-WP-SG.\nConnexions outbound: Per defecte, AWS permetrà totes les connexions sortints, cosa que garanteix que la base de dades pugui comunicar-se amb altres recursos si és necessari.\n\nPer fer-ho, navegarem a la consola de VPC d’AWS, seleccionarem la secció Security Groups i clicarem a Create security group. A continuació, omplirem els camps amb la informació necessària i clicarem a Create security group.\n\n\n\nGrup de Seguretat per a la base de dades RDS\n\n\n\n\nResum\n\n\n\n\n\n\n\n\nGrup de Seguretat\nInbound\nOutbound\n\n\n\n\nAMSA-WP-SG\nHTTP (80) i HTTPS (443) des de 0.0.0.0/0; SSH (22) des de 0.0.0.0/0\nTotes permeses\n\n\nAMSA-DB-SG\nMySQL (3306) des de AMSA-Web-SG\nTotes permeses",
    "crumbs": [
      "Laboratoris",
      "Networking",
      "Laboratori 03 · Desplegament d'una aplicació web amb alta disponibilitat amb AWS"
    ]
  },
  {
    "objectID": "laboratories/02-network/01-aws-wordpress.html#creació-de-la-base-de-dades-rds",
    "href": "laboratories/02-network/01-aws-wordpress.html#creació-de-la-base-de-dades-rds",
    "title": "Desplegament d’una aplicació web amb alta disponibilitat amb AWS",
    "section": "Creació de la Base de Dades RDS",
    "text": "Creació de la Base de Dades RDS\nLa base de dades ja la vam configurar en el laboratori anterior Desplegament d’una aplicació web amb AWS. La única diferència és que ara la base de dades es troba en una subxarxa privada i només és accessible des de les instàncies EC2 que pertanyen al grup de seguretat AMSA-Web-SG.\n\nCompute resources: Don’t connect to an EC2 compute resource\nVPC: AMSA-VPC\nSubnet Group: Create new DB Subnet Group\nPublic accessibility: No\nVPC security group: AMSA-DB-SG\nAvailability Zone: us-east-1d",
    "crumbs": [
      "Laboratoris",
      "Networking",
      "Laboratori 03 · Desplegament d'una aplicació web amb alta disponibilitat amb AWS"
    ]
  },
  {
    "objectID": "laboratories/02-network/01-aws-wordpress.html#creació-de-les-instàncies-ec2",
    "href": "laboratories/02-network/01-aws-wordpress.html#creació-de-les-instàncies-ec2",
    "title": "Desplegament d’una aplicació web amb alta disponibilitat amb AWS",
    "section": "Creació de les instàncies EC2",
    "text": "Creació de les instàncies EC2\nLes instàncies EC2 que allotjaran WordPress es desplegaran en les subxarxes privades, recordeu que vam configurar ansible en el laboratori anterior Desplegament d’una aplicació web amb AWS. AWS ens permet crear plantilles d’instàncies (Launch Templates) que faciliten la creació d’instàncies amb una configuració predefinida. Per tant, crearem una plantilla d’instància que inclogui la configuració necessària per a les nostres instàncies EC2 de WordPress, enlloc d’utiltizar el mètode amb ansible que vam utilitzar en el laboratori anterior.",
    "crumbs": [
      "Laboratoris",
      "Networking",
      "Laboratori 03 · Desplegament d'una aplicació web amb alta disponibilitat amb AWS"
    ]
  },
  {
    "objectID": "laboratories/02-network/01-aws-wordpress.html#configuració-del-balancejador-de-càrrega",
    "href": "laboratories/02-network/01-aws-wordpress.html#configuració-del-balancejador-de-càrrega",
    "title": "Desplegament d’una aplicació web amb alta disponibilitat amb AWS",
    "section": "Configuració del Balancejador de Càrrega",
    "text": "Configuració del Balancejador de Càrrega\nEn aquest punt, crearem un balancejador de càrrega per a les nostres instàncies EC2. Aquest balancejador de càrrega serà responsable de distribuir uniformement el tràfic entre les instàncies EC2 que allotgen WordPress.\nExisteixen 3 tipus de balancejadors de càrrega a AWS: Application Load Balancer (ALB), Network Load Balancer (NLB) i Gateway Load Balancer (GWLB). En aquest cas, utilitzarem un Application Load Balancer (ALB), ja que és el recomanat per a aplicacions web que utiltizen HTTP i HTTPS.\nNavegueu a la consola de AWS i seleccioneu el servei EC2. A la barra lateral, seleccioneu Load Balancers i després Create Load Balancer. Seleccioneu Application Load Balancer i feu clic a Create.\n\nNom del balancejador de càrrega: AMSA-ALB\nScheme: Internet-facing\nIP Address Type: IPv4\n\n\n\n\nConfiguració del balancejador de càrrega\n\n\n\nVPC: AMSA-VPC\nAvailability Zones: Seleccionar les zones de disponibilitat on tenim la subxarxa pública AMSA-DMZ-01 (us-east-1a) i les AMSA-DMZ-02 (us-east-1b).\nGrups de Seguretat: Nou grup de seguretat (AMSA-ALB-SG), aquest grup de seguretat permetrà el tràfic d’entrada per als ports 80 (HTTP) i 443 (HTTPS) des de qualsevol origen però restringirà el tràfic de sortida a les instàncies EC2 (grup de seguretat AMSA-WP-SG).\n\n\n\nGrup de Seguretat per al balancejador de càrrega\n\n\n\n\n\nConfiguració del balancejador de càrrega\n\n\nListeners: Crearem un listener per al port 80 (HTTP), que redirigirà el tràfic al port 80 de les instàncies EC2. Al port 443 (HTTPS) de moment no configurarem cap redirecció. Per fer-ho, primer haureu de crear un Target Group. Aquest grup es necessari per indicar al balancejador de càrrega on enviar el tràfic.\n\nTarget Group:\n\nTarget Type: Instances\nNom: AMSA-WP-TG\nProtocol: HTTP\nPort: 80\nVPC: AMSA-VPC\nHealth checks: HTTP, ruta /\n\n\n\n\nConfiguració del target group\n\n\n\n\n\n\n\n\n\n\nNotaHealth Check 🎯\n\n\n\nEl balancejador de càrrega comprova ltg-04a salut de les instàncies EC2 a través del port 80 i la ruta /. Això significa que el balancejador de càrrega enviarà tràfic a les instàncies EC2 que responguin correctament a les peticions HTTP a la ruta /. Com que les nostres instàncies EC2 tenen WordPress instal·lat, aquestes instàncies respondran correctament a les peticions HTTP a la ruta /. Podem deixar la configuració per defecte.\n\n\n\nSeleccionarem les dos instàncies EC2 que allotgen WordPress (AMSA-WP-01 i AMSA-WP-02) i les afegirem al target group. Utilitzant el botó Include as pending below i després Add to registered.\n\n\n\nConfiguració del target group\n\n\nUn cop creat el target group, el seleccionarem com a target del listener del balancejador de càrrega.\n\n\n\nConfiguració del balancejador de càrrega\n\n\nUn cop creat el balancejador de càrrega, heu d’esperar uns minuts fins que el seu estat passi de Provisioning a Active. Un cop l’estat sigui Active, podeu accedir al balancejador de càrrega a través de la seva adreça DNS.\n\n\n\n\nBalancejador de càrrega actiu\n\n\n\nAra ja podem accedir al balancejador de càrrega a través de la seva adreça DNS i veure la pàgina d’instal·lació de WordPress:\n\n\n\n\nInstal·lació de WordPress a través del balancejador de càrrega\n\n\nProcedirem a instal·lar WordPress a través del balancejador de càrrega. Seguiu els passos de la instal·lació i configureu l’usuari administrador i la contrasenya. Ara ja teniu el servidor web configurat amb WordPress i el balancejador de càrrega per distribuir el tràfic entre les instàncies EC2.",
    "crumbs": [
      "Laboratoris",
      "Networking",
      "Laboratori 03 · Desplegament d'una aplicació web amb alta disponibilitat amb AWS"
    ]
  },
  {
    "objectID": "laboratories/02-network/01-aws-wordpress.html#configuració-vpn",
    "href": "laboratories/02-network/01-aws-wordpress.html#configuració-vpn",
    "title": "Desplegament d’una aplicació web amb alta disponibilitat amb AWS",
    "section": "Configuració VPN",
    "text": "Configuració VPN\n\nEC2 per desplegar el servidor VPN\nPer desplegar el servidor VPN, crearem una nova instància EC2 que actuarà com a servidor VPN. Aquesta instància EC2 haurà d’estar en una subxarxa pública connectada a interent. Anomenarem aquesta instància AMSA-VPN i la situarem a la subxarxa pública AMSA-DMZ-01. Aquesta instància EC2 utilitzarà el grup de seguretat AMSA-VPN-SG que permetrà el tràfic necessari per al funcionament del servidor VPN.\n\nNavegueu a la consola de AWS i seleccioneu el servei EC2. A la barra lateral, seleccioneu Instances i després Launch Instances.\nSeleccioneu la imatge Ubuntu Server 22.04 LTS.\nSeleccioneu la instància t2.micro.\nConfigureu la instància:\n\nNetwork: AMSA-VPC\nSubnet: Front-01\nAuto-assign Public IP: Enable\n\n\n\n\nConfiguració de la instància EC2 per al servidor VPN\n\n\nConfigureu el grup de seguretat: AMSA-VPN-SG.\nSi reviseu la documentació d’instal·lació del servidor OpenVPN: OpenVPN Access Server System Administrator Guide. Veure que necessitem els següents ports oberts: TCP 443, TCP 943, UDP 1194.\n\n\n\nConfiguració del grup de seguretat per al servidor VPN\n\n\nConnecteu-vos a la instància EC2 a través de la consola online de AWS o amb una connexió SSH i executeu la següent comanda per instal·lar el servidor OpenVPN:\nsudo apt update -y\nsudo apt install ca-certificates gnupg wget net-tools -y\nsudo wget https://as-repository.openvpn.net/as-repo-public.asc -qO /etc/apt/trusted.gpg.d/as-repo-public.asc\nsudo echo \"deb [arch=amd64 signed-by=/etc/apt/trusted.gpg.d/as-repo-public.asc] http://as-repository.openvpn.net/as/debian jammy main\" | sudo tee /etc/apt/sources.list.d/openvpn-as-repo.list\nsudo apt update && sudo apt install openvpn-as -y\n\n\n\nInstal·lació del servidor OpenVPN\n\n\nAmb aquestes credencials, podreu accedir a la interfície web del servidor OpenVPN a través del vostre navegador web. Navegueu a la IP pública de la instància EC2 (en el meu cas https://44.199.196.242:943/admin), com no tenim el certificat SSL configurat, ens sortirà un missatge d’advertència, ignoreu-lo i continueu. Inicieu sessió amb les credencials que heu configurat anteriorment.\n\nNota: Si heu perdut les credencials de l’usuari openvpn, les podeu recuperar consultat el fitxer de logs del servidor OpenVPN. Per exemple, podeu consultar el fitxer de logs amb la següent comanda:\nsudo less /usr/local/openvpn_as/init.log \n\n\n\n\nInterfície web del servidor OpenVPN\n\n\n\nAccepteu els termes de llicència.\n\n\n\n\nAcceptació dels termes de llicència\n\n\n\nAneu a VPN Server/Network Settings i configureu el Hostname or IP Address amb la IP pública de la instància EC2 on teniu el servidor OpenVPN. Un cop fet, clicareu a Save.\n\n\n\nConfiguració de la IP pública del servidor VPN\n\n\nAneu a Access Controls/Internet Access and DNS i seleccioneu l’opció Split Tunnel per evitar que tot el tràfic del client sigui redirigit a través de la VPN. Únicament el tràfic dirigit a les subxarxes de la VPC serà redirigit a través de la VPN.\n\n\n\nConfiguració de Split Tunnel\n\n\nAneu a Access Controls/Global Access Rules i afegiu una regla per permetre el tràfic de la VPN a les subxarxes de la VPC:\n\n\n\nConfiguració de les regles d’accés global\n\n\nAneu a User i creu-vos un usuari i una contrasenya per connectar-vos al servidor VPN.\n\n\n\nCreació d’un usuari per al servidor VPN\n\n\nUn cop tinguem el fitxer de configuració, ja podeu fer un Restart del servei OpenVPN per aplicar tots els canvis. Torneu a accedir a la interfície web del servidor OpenVPN.\nAneu a User/user/Connection Profiles i creeu un perfil de connexió per defecte. Un cop creat us baixarà un fitxer de configuració que després utilitzarem per connectar-nos al servidor VPN.\n\n\n\nDescàrrega del fitxer de configuració del client VPN\n\n\nInstalleu l’aplicació OpenVPN Connect al vostre ordinador. Aquesta aplicació és el client VPN que utilitzarem per connectar-nos al servidor VPN.\nUn cop instal·lat, obriu l’aplicació i importeu el fitxer de configuració que heu descarregat anteriorment.\n\nUn cop tot configurat, actualitzarem el grup de seguretat de les instàncies EC2 per permetre el tràfic al port 22 únicament provinent del servidor VPN. Això significa que les instàncies EC2 només acceptaran tràfic SSH del servidor VPN i no de qualsevol altre origen.\n\n\n\nConfiguració tràfic SSH a Ec2 del servidor VPN\n\n\n\nEn aquest punt, ja no podreu accedir a les instàncies EC2 on teniu el servei de WordPress a través de SSH, ja que el tràfic SSH només es permet des del servidor VPN. Per accedir a les instàncies EC2, primer heu de connectar-vos al servidor VPN i després connectar-vos a les instàncies EC2. Per fer-ho:\n\nImporteu el fitxer de configuració del client OpenVPN Connect a l’aplicació i connecteu-vos al servidor VPN.\n\n\n\nConnexió al servidor VPN\n\n\n\nTroubleShooting: Si en el fitxer de configuració veieu (Server Hostname) una ip del rang 10.0.X.X, això vol dir que la VPN no s’ha configurat correctament. Assegureu-vos de reiniciar el servidor i tornar a descarregar el fitxer de configuració del client, ha de tenir la ip pública del servidor VPN.\n\nUtilitzeu la mateixa contrasenya del usuari openvpn per connectar-vos al servidor VPN.\n\n\n\nConnexió al servidor VPN\n\n\nSi tot ha anat bé, veureu que esteu connectats al servidor VPN.\n\n\n\nConnexió al servidor VPN\n\n\n\nFinalment, connecteu-vos a les instàncies EC2:\n\n\n\nAccés a les instàncies EC2 a través del servidor VPN\n\n\n\nConsideracions importants: El servidor VPN ens permet accedir a les instàncies EC2 a través de SSH, però a partir de l’adreça interna (10.0.X.X) de la instància EC2. No podrem accedir a les instàncies EC2 a través de la seva adreça pública ja que hem configurat la VPN per accedir a les subxarxes de la VPC.",
    "crumbs": [
      "Laboratoris",
      "Networking",
      "Laboratori 03 · Desplegament d'una aplicació web amb alta disponibilitat amb AWS"
    ]
  },
  {
    "objectID": "laboratories/02-network/01-aws-wordpress.html#neteja-els-recursos-creats",
    "href": "laboratories/02-network/01-aws-wordpress.html#neteja-els-recursos-creats",
    "title": "Desplegament d’una aplicació web amb alta disponibilitat amb AWS",
    "section": "Neteja els recursos creats",
    "text": "Neteja els recursos creats\nUn cop finalitzat podeu eliminar totes les instàncies EC2 i la base de dades RDS per evitar càrrecs innecessaris al vostre compte d’AWS.",
    "crumbs": [
      "Laboratoris",
      "Networking",
      "Laboratori 03 · Desplegament d'una aplicació web amb alta disponibilitat amb AWS"
    ]
  },
  {
    "objectID": "laboratories/02-network/01-aws-wordpress.html#exercics-adicionals",
    "href": "laboratories/02-network/01-aws-wordpress.html#exercics-adicionals",
    "title": "Desplegament d’una aplicació web amb alta disponibilitat amb AWS",
    "section": "Exercics Adicionals",
    "text": "Exercics Adicionals\n\nCom milloraríeu els grups de seguretat, quins canvis faríeu?\nQuè caldria fer per connectar un client MySQL des de casa a la base de dades RDS? Expliqueu els passos.\nPrepara un script que faci una prova de càrrega al balancejador de càrrega i mostri com es distribueix el tràfic entre les instàncies EC2.",
    "crumbs": [
      "Laboratoris",
      "Networking",
      "Laboratori 03 · Desplegament d'una aplicació web amb alta disponibilitat amb AWS"
    ]
  },
  {
    "objectID": "laboratories/01-foundations/01-aws-introduction.html",
    "href": "laboratories/01-foundations/01-aws-introduction.html",
    "title": "Unitat 1 · Laboratori de preparació i comandes bàsiques d’administració",
    "section": "",
    "text": "Per preparar l’entorn de treball a AWS, seguirem els següents passos:\n\nCrear un compte d’AWS Academy\nAccedir al tauler d’AWS\nCrear un parell de claus SSH\nLlançar una instància EC2\nConnectar-se a la instància EC2 mitjançant SSH\n\n\n\nReviseu el vostre correu electrònic per veure si heu rebut un correu electrònic d’AWS Academy amb l’assumpte Invitació al curs. Si no l’heu rebut, feu-m’ho saber. El correu electrònic contindrà un botó amb el text Get Started. Feu clic en aquest botó per iniciar el procés de registre.\n\nDesprés de fer clic al botó Get Started, sereu redirigits a la pàgina d’inici de sessió d’AWS Academy. Ara heu de fer clic al botó Create my account per iniciar el procés de registre, com es mostra a continuació:\n\nSeleccioneu una contrasenya i completeu el procés de registre. Un cop hàgiu completat el procés de registre, sereu redirigits al tauler d’AWS Academy. Enhorabona! Heu creat amb èxit el vostre compte d’AWS Academy.\n\n\n\nAra que heu creat el vostre compte d’AWS Academy, podeu accedir al tauler d’AWS. El primer que heu de fer és fer clic a la pestanya Courses (1) a la part esquerra de la pantalla. Veureu una llista de cursos disponibles per a vosaltres. Feu clic al curs AWS Academy Learner Lab (2), com es mostra a la captura de pantalla següent:\n\n\n\n\n\n\n\nNota\n\n\n\nEl curs AWS Academy Learner Lab és el curs que utilitzareu per completar els laboratoris pràctics, si recordeu a la primera sessió vam parlar del curs AWS Academy Cloud Foundations, que no és obligatori però és altament recomanat per a aquells que vulguin tenir una base més sòlida i obtenir el 5% de l’apartat (Async Activities AWS).\n\n\n\n\n\n\n\n\nAlerta\n\n\n\nTingueu en compte que només hi ha un curs a la captura de pantalla següent, no és el que hauríeu de veure, hauríeu de veure dos cursos, un per al AWS Academy Cloud Foundations i un per al AWS Academy Learner Lab. Si no veieu el curs AWS Academy Cloud Foundations i voleu tenir accés a ell, feu-m’ho saber.\n\n\nAra hem de buscar la pestanya Modules (1) a la part esquerra de la pantalla. Feu clic en ella i veureu una llista de mòduls disponibles per a vosaltres. Feu clic en el mòdul AWS Academy Learner Lab (2), com es mostra a continuació:\n\nAra se us demanarà que accepteu els termes i condicions del curs. Feu-ho desplaçant-vos fins al final de la pàgina i fent clic al botó I Agree.\n\nDesprés d’acceptar els termes i condicions, ara només heu de fer clic al botó Start Lab.\n\nAra doneu-li uns minuts per carregar. Veureu aquesta animació mentre el laboratori s’està preparant per a vosaltres:\n\nFinalment, quan el laboratori estigui llest, veureu que el punt al costat de AWS és verd. També veureu un temporitzador que compta enrere des de 4 hores. Aquest és el temps que teniu per treballar al laboratori. A l’esquerra del temporitzador veureu com va el vostre pressupost. Teniu un pressupost de 50 dòlars per gastar en serveis d’AWS. Feu clic a AWS per accedir al tauler d’AWS, com es mostra a continuació:\n\n\n\n\n\n\n\nImportantConsideracions sobre els laboratoris\n\n\n\n\nEls laboratoris són un entorn real d’AWS, per tant, és important que tingueu cura dels recursos i de les vostres accions.\nSi superes el pressupost de 50 dòlars, ja no tindràs accés al tauler d’AWS i perdràs la teva feina. Assegureu-vos de vigilar el pressupost, és responsabilitat de cada estudiant mantenir-se dins del pressupost.\nEls laboratoris tenen una durada de 4 hores. Un cop passades les 4 hores, la sessió expirarà i no podreu accedir al tauler d’AWS. No obstant això, això no vol dir que perdràs el teu treball automàticament. Les tasques i recursos que has creat (com ara instàncies EC2, buckets de S3, etc.) es mantindran accessibles entre sessions, sempre que no els eliminis manualment. Podeu tornar a iniciar el laboratori de forma il·limitada, però és una bona pràctica aturar o tancar manualment els serveis que ja no necessiteu per evitar que consumeixin recursos innecessàriament.\n\nPer tant, si comences un laboratori i el deixes a mig fer, podràs reprendre’l en una sessió posterior.\n\n\nGenial! Ara heu accedit al tauler d’AWS. Veureu una pantalla similar a la següent:\n\n\n\n\nLa clau SSH és un mecanisme de seguretat que permet l’autenticació segura entre dos sistemes. El servidor d’Amazon EC2 té la clau pública i el client (el vostre ordinador local) té la clau privada. Quan el client es connecta al servidor, el servidor comprova si la clau pública del client coincideix amb la clau privada del servidor. Si les claus coincideixen, el client es connecta al servidor. Per tant, la clau privada no s’ha de compartir amb ningú. Mentre que la clau pública es pot compartir amb qualsevol i la podeu fer servir en múltiples servidors. A dia d’avui, no hi ha cap mecanisme per obtenir la clau privada a partir de la clau pública.\nPer crear un parell de claus SSH, utilitzarem la comanda ssh-keygen. Aquesta comanda està disponible a la majoria dels sistemes operatius, inclosos Linux, MacOS i Windows (a través de PowerShell o Windows Subsystem for Linux - WSL). Si utilitzeu Windows i no teniu accés a ssh-keygen, podeu utilitzar eines com PuTTYgen per generar les claus SSH.\nAquesta comanda té diversos paràmetres que permeten personalitzar la clau SSH. Els paràmetres més comuns són:\n\n-t: Especifica el tipus de xifratge de la clau. Els tipus més comuns són rsa, dsa, ecdsa i ed25519.\n-f: Especifica el nom del fitxer on es guardarà la clau.\n-b: Especifica la longitud de la clau en bits.\n\n\n\n\n\n\n\nNota\n\n\n\nÉs molt important entendre quan estem treballant al nostre ordinador local i quan estem treballant a la màquina remota. El primer pas sempre serà obrir un terminal al nostre propi ordinador, però un cop ens connectem a la màquina remota mitjançant l’ordre SSH, encara que sembli que res no ha canviat, el terminal ara està connectat a la màquina remota. Això vol dir que a partir d’ara les ordres que escrivim s’executaran a la màquina remota, no al nostre ordinador local. Si no esteu segurs si esteu treballant al vostre ordinador local o a la màquina remota, només heu d’escriure pwd i veure quin és el resultat. Si és el vostre ordinador local, veureu la ruta al directori en què esteu al vostre ordinador local, si és la màquina remota, veureu la ruta al directori en què esteu a la màquina remota. pwd significa print working directory.\n\n\nEl primer pas per crear el parell de claus SSH serà assegurar-nos que el directori .ssh existeix. Per fer-ho, obriu un terminal al vostre ordinador local i escriviu la següent ordre:\nmkdir .ssh\n\n\n\n\n\n\nAlerta\n\n\n\nSi el directori .ssh ja existeix, obtindreu un error indicant que el directori ja existeix. Això és normal, només vol dir que el directori ja estava allà.\n\n\nAra crearem el parell de claus SSH. Escriviu la següent ordre:\nssh-keygen -t rsa -f .ssh/aws-keypair\nSe us demanarà que introduïu una contrasenya. Podeu deixar-la buida prement Enter dues vegades (us recomano fer-ho per simplicitat, si no, cada vegada que us connecteu a la màquina remota haureu d’introduir la contrasenya). Hauríeu de veure una sortida similar a la següent:\nGenerating public/private rsa key pair.\nEnter passphrase (empty for no passphrase):\nEnter same passphrase again:\nYour identification has been saved in .ssh/aws-keypair\nYour public key has been saved in .ssh/aws-keypair.pub\nThe key fingerprint is:\nSHA256:uhINFvYaJh6MbwFQCXdZyrW7W46jFGHUhLglDgQ5OYE ferran@DESKTOP-0841\n+---[RSA 3072]----+\n|XBooo*+          |\n|E.++*o..         |\n| O ==o.          |\n|. B.=...         |     \n| o *.=. S        |\n|  + o..o         |\n| .  ..o .        |\n|   .. .*         |\n|    .o+..        |\n+----[SHA256]-----+\nAquí, ssh-keygen és l’ordre per generar el parell de claus, -t rsa especifica el tipus de clau a crear, en aquest cas una clau RSA, i -f .ssh/aws-keypair especifica el nom del fitxer per al parell de claus. Podeu anomenar el fitxer com vulgueu, però és important recordar el nom que li heu donat. En aquest cas, l’estem anomenant aws-keypair. Us recomano que el nomeu igual que jo per no confondre-us més endavant.\n\n\n\n\n\n\nConsellEntendre les claus SSH - Veure video\n\n\n\nEs clau entendre com funcionen les claus públiques i privades i com s’utilitzen per establir una connexió SSH, heu de veure aquest vídeo.\n\n\nUna altra vegada, podem comprovar el contingut del directori .ssh escrivint la següent ordre:\nls .ssh\nHauríem de veure ara dos fitxers, aws-keypair i aws-keypair.pub. El primer és la clau privada i el segon és la clau pública. La clau privada mai s’ha de compartir amb ningú, mentre que la clau pública és la que s’ha de compartir amb la màquina remota. Una ordre útil per inspeccionar el contingut d’un fitxer és cat. Per exemple, per veure el contingut de la clau pública, escriviu la següent ordre:\ncat .ssh/aws-keypair.pub\n\n\n\n\n\n\nNota\n\n\n\nTambé podeu inspeccionar el contingut de la carpeta .ssh i dels fitxers que hi ha dins utilitzant l’Explorador de fitxers (o Finder en dispositius Mac). Però tingueu cura, per defecte, les carpetes i fitxers que comencen amb un . (com .ssh) estan ocults en la majoria d’exploradors de fitxers i si voleu poder veure’ls, haureu d’habilitar l’opció per mostrar fitxers ocults. Consulteu aquest tutorial per veure com fer-ho al vostre sistema operatiu. Una altra cosa a tenir en compte és que les extensions de fitxer (és a dir, la part del nom del fitxer que ve després del darrer .) també solen estar ocultes, això vol dir que a l’Explorador de fitxers potser veieu dos fitxers anomenats aws-keypair quan en realitat un és aws-keypair i l’altre és aws-keypair.pub. Aquí teniu un tutorial sobre com mostrar les extensions de fitxer al vostre sistema operatiu.\nNo cal que us preocupeu per res d’això si esteu utilitzant el terminal, el terminal us mostrarà els fitxers i les seves extensions tal com són. Però per veure fitxers i carpetes ocults (aquells que comencen amb un .) haureu d’utilitzar l’ordre ls -a.\nls -a .ssh\n\n\nHem creat un parell de claus SSH que podem utilitzar per connectar-nos a màquines remotes. A continuació, importarem la nostra clau pública a AWS.\n\n\n\nAra que hem creat el nostre parell de claus SSH, hem d’importar la clau pública a AWS per poder utilitzar-la per connectar-nos a les instàncies EC2 que crearem més endavant. Per fer-ho, hem de tornar al tauler d’AWS, que és on vam acabar després de completar el Pas 2.\nAra anirem a la barra de cerca i buscarem el servei EC2. Escriviu EC2 a la barra de cerca i feu clic al servei EC2, com es mostra a continuació:\n\n\n\nAWS Dashboard\n\n\nAra veureu el tauler d’EC2. A la part esquerra de la pantalla, veureu una llista d’opcions. Feu clic a Key Pairs (Pares de claus) i després a Create key pair (Crear parell de claus), com es mostra a continuació:\n\n\n\nAWS Dashboard\n\n\nAra heu de donar un nom al parell de claus. Podeu anomenar-lo com vulgueu, però us suggereixo que el anomeneu aws-keypair per mantenir les coses simples. Assegureu-vos que l’opció Key type (Tipus de clau) estigui configurada a RSA i que l’opció Private key file format (Format del fitxer de clau privada) estigui configurada a PEM. Això és important perquè la clau privada s’ha d’utilitzar en format PEM per connectar-se a la màquina remota. Feu clic a Create key pair (Crear parell de claus), com es mostra a continuació:\n\n\n\nAWS Dashboard\n\n\n\n\n\n\n\n\nNota\n\n\n\nPodeu també fer clic al botó Browse per seleccionar el fitxer de clau pública des del vostre ordinador. Només cal que feu clic a Browse, navegueu fins a la carpeta .ssh i seleccioneu el fitxer aws-keypair.pub. Però recordeu, el fitxer ha de ser el fitxer de clau pública, no el fitxer de clau privada. És a dir, el fitxer ha de tenir l’extensió .pub. Un cop hàgiu seleccionat el fitxer, feu clic a Import Key Pair.\nRecordeu que com s’ha explicat a la nota anterior, potser no veureu la carpeta .ssh a l’explorador de fitxers i potser no veureu l’extensió .pub del fitxer. Si teniu problemes amb això, us recomano utilitzar el terminal per copiar el contingut del fitxer com es mostra a la captura de pantalla anterior.\n\n\nAra hauríeu de veure el parell de claus que acabeu d’importar a la llista de parells de claus. Probablement hi haurà un altre parell de claus allà, això està bé, podeu ignorar-lo. Perfecte! Ara heu importat la clau pública a AWS. A continuació, crearem una instància EC2 i la configurarem per utilitzar el parell de claus que acabem d’importar.\n\n\n\nEl primer pas serà anar al tauler d’EC2. Podeu fer-ho escrivint EC2 a la barra de cerca i fent clic al servei EC2, com vam fer al principi del Pas 3:\n\n\n\nAWS Dashboard\n\n\nUn cop estigueu al tauler d’EC2, feu clic a Instances &gt; Launch Instance, com es mostra a continuació:\n\n\n\nAWS Dashboard\n\n\nDeixeu-ho tot com està excepte l’opció Key pair (login) (Parell de claus (inici de sessió)) (haureu de desplaçar-vos cap avall per trobar-la). Feu clic al menú desplegable i seleccioneu el parell de claus que heu importat anteriorment. En aquest cas, hauria de ser aws-keypair. Feu clic a Launch instance, com es mostra a continuació:\n\n\n\nAWS Dashboard\n\n\nAra tenim una instància EC2 en execució amb la nostra clau pública importada. Això significa que tenim una màquina remota a AWS a la qual podem connectar-nos des del nostre ordinador local mitjançant SSH. Vegem com fer-ho.\n\n\n\nAbans de connectar-nos a la màquina remota, vull que proveu alguns ordres al vostre ordinador local que després repetirem un cop estiguem connectats a la màquina remota. Una de les ordres és pwd, que significa print working directory, com ja s’ha comentat anteriorment. Aquesta ordre us mostrarà la ruta al directori en què esteu actualment. L’altra ordre és whoami, que us mostrarà el nom d’usuari amb el qual heu iniciat sessió. Proveu aquestes ordres al vostre ordinador local i recordeu-ne la sortida. Les repetirem un cop estiguem connectats a la màquina remota.\nA continuació es mostra la sortida que obtinc al meu ordinador local:\nPS C:\\Users\\fnao&gt; pwd\n\nPS C:\\Users\\fnao&gt; whoami\ngft\\fnao\nPS C:\\Users\\fnao&gt;\n\n\n\n\n\n\nAlerta\n\n\n\nEl ordinador local que utilitzo és un portàtil amb Windows, així que la sortida serà diferent de la vostra si esteu utilitzant un Mac o un ordinador amb Linux. Substitueix fnao pel vostre nom d’usuari i C:\\Users\\fnao per la ruta al vostre directori d’usuari.\n\n\nPer connectar-nos a la instància EC2, utilitzarem el terminal del nostre ordinador local. Així com vam fer al principi Pas 3, obriu un terminal al vostre ordinador local. Utilitzarem l’ordre ssh per connectar-nos a la màquina remota. L’ordre tindrà aquest aspecte:\nssh -i .ssh/aws-keypair ec2-user@&lt;public-ip&gt;\nHaureu de substituir &lt;public-ip&gt; per la IP pública de la instància EC2. Per trobar la IP pública, torneu al tauler d’EC2 i feu clic a Instances a la part esquerra de la pantalla. Veureu una llista d’instàncies, feu clic a la instància que heu creat. Veureu la IP pública a la part inferior de la pantalla com es mostra a continuació:\n\n\n\nAWS Dashboard\n\n\nTant l’adreça Public IPv4 address com el Public IPv4 DNS es poden utilitzar com a &lt;public-ip&gt; a l’ordre ssh. Copieu el que preferiu i enganxeu-lo a l’ordre ssh. L’ordre hauria d’assemblar-se a alguna cosa així si utilitzeu l’adreça IP:\nssh -i .ssh/aws-keypair ec2-user@98.84.68.70\no així si utilitzeu el DNS:\nssh -i .ssh/aws-keypair ec2-user@ec2-98-84-68-70.compute-1.amazonaws.com\nSi és la primera vegada que us connecteu a la màquina remota, obtindreu una advertència. Això és normal, només heu d’escriure yes i prémer Enter. Ara hauríeu de estar connectats a la màquina remota. Veureu un missatge similar al següent:\n   ,     #_\n   ~\\_  ####_        Amazon Linux 2023\n  ~~  \\_#####\\\n  ~~     \\###|\n  ~~       \\#/ ___   https://aws.amazon.com/linux/amazon-linux-2023\n   ~~       V~' '-&gt;\n    ~~~         /\n      ~~._.   _/\n         _/ _/\n       _/m/'\nLast login: Sun Mar  2 09:50:33 2025 from 79.156.58.43\n[ec2-user@ip-172-31-86-82 ~]$\n\n\n\n\n\n\nImportantExercici\n\n\n\nInvestiga quin és el significat i la importànica del missatge que acceptes quan et connectes per primera vegada a la màquina remota. Per què és important acceptar aquest missatge? Què significa? Quines implicacions té?\n\n\nFantàstic! Ara esteu connectats a la màquina remota. És important entendre que a partir d’ara, les ordres que escrivim s’executaran a la màquina remota, no al nostre ordinador local. Per comprovar-ho, escriviu les ordres pwd i whoami com vam fer al nostre ordinador local. Veureu que la sortida és diferent. A continuació es mostra la sortida que obtinc a la màquina remota:\n[ec2-user@ip-172-31-86-82 ~]$ pwd\n/home/ec2-user\n[ec2-user@ip-172-31-86-82 ~]$ whoami\nec2-user\n[ec2-user@ip-172-31-86-82 ~]$\n\n\n\n\n\n\nNota\n\n\n\nAquesta vegada la sortida hauria de ser la mateixa que la meva. Observeu que el prompt [ec2-user@ip-172-31-86-82 ~]$ és diferent, però això no forma part de les sortides de les ordres. Les sortides de les ordres són pwd i whoami, que són home/ec2-user i ec2-user respectivament. El prompt és només una manera de mostrar-vos on esteu al sistema de fitxers i qui sou com a usuari connectat.\n\n\n\n\n\n\n\n\nImportantExercici\n\n\n\nUtilitza la comanada lastlog i investiga com administrador com podem trueure partit d’aquesta informació.",
    "crumbs": [
      "Laboratoris",
      "Unitat 01 · Fonaments de l'Administració de Sistemes",
      "Laboratori 01 · Introducció a AWS"
    ]
  },
  {
    "objectID": "laboratories/01-foundations/01-aws-introduction.html#preparant-lentorn-de-treball-remot",
    "href": "laboratories/01-foundations/01-aws-introduction.html#preparant-lentorn-de-treball-remot",
    "title": "Unitat 1 · Laboratori de preparació i comandes bàsiques d’administració",
    "section": "",
    "text": "Per preparar l’entorn de treball a AWS, seguirem els següents passos:\n\nCrear un compte d’AWS Academy\nAccedir al tauler d’AWS\nCrear un parell de claus SSH\nLlançar una instància EC2\nConnectar-se a la instància EC2 mitjançant SSH\n\n\n\nReviseu el vostre correu electrònic per veure si heu rebut un correu electrònic d’AWS Academy amb l’assumpte Invitació al curs. Si no l’heu rebut, feu-m’ho saber. El correu electrònic contindrà un botó amb el text Get Started. Feu clic en aquest botó per iniciar el procés de registre.\n\nDesprés de fer clic al botó Get Started, sereu redirigits a la pàgina d’inici de sessió d’AWS Academy. Ara heu de fer clic al botó Create my account per iniciar el procés de registre, com es mostra a continuació:\n\nSeleccioneu una contrasenya i completeu el procés de registre. Un cop hàgiu completat el procés de registre, sereu redirigits al tauler d’AWS Academy. Enhorabona! Heu creat amb èxit el vostre compte d’AWS Academy.\n\n\n\nAra que heu creat el vostre compte d’AWS Academy, podeu accedir al tauler d’AWS. El primer que heu de fer és fer clic a la pestanya Courses (1) a la part esquerra de la pantalla. Veureu una llista de cursos disponibles per a vosaltres. Feu clic al curs AWS Academy Learner Lab (2), com es mostra a la captura de pantalla següent:\n\n\n\n\n\n\n\nNota\n\n\n\nEl curs AWS Academy Learner Lab és el curs que utilitzareu per completar els laboratoris pràctics, si recordeu a la primera sessió vam parlar del curs AWS Academy Cloud Foundations, que no és obligatori però és altament recomanat per a aquells que vulguin tenir una base més sòlida i obtenir el 5% de l’apartat (Async Activities AWS).\n\n\n\n\n\n\n\n\nAlerta\n\n\n\nTingueu en compte que només hi ha un curs a la captura de pantalla següent, no és el que hauríeu de veure, hauríeu de veure dos cursos, un per al AWS Academy Cloud Foundations i un per al AWS Academy Learner Lab. Si no veieu el curs AWS Academy Cloud Foundations i voleu tenir accés a ell, feu-m’ho saber.\n\n\nAra hem de buscar la pestanya Modules (1) a la part esquerra de la pantalla. Feu clic en ella i veureu una llista de mòduls disponibles per a vosaltres. Feu clic en el mòdul AWS Academy Learner Lab (2), com es mostra a continuació:\n\nAra se us demanarà que accepteu els termes i condicions del curs. Feu-ho desplaçant-vos fins al final de la pàgina i fent clic al botó I Agree.\n\nDesprés d’acceptar els termes i condicions, ara només heu de fer clic al botó Start Lab.\n\nAra doneu-li uns minuts per carregar. Veureu aquesta animació mentre el laboratori s’està preparant per a vosaltres:\n\nFinalment, quan el laboratori estigui llest, veureu que el punt al costat de AWS és verd. També veureu un temporitzador que compta enrere des de 4 hores. Aquest és el temps que teniu per treballar al laboratori. A l’esquerra del temporitzador veureu com va el vostre pressupost. Teniu un pressupost de 50 dòlars per gastar en serveis d’AWS. Feu clic a AWS per accedir al tauler d’AWS, com es mostra a continuació:\n\n\n\n\n\n\n\nImportantConsideracions sobre els laboratoris\n\n\n\n\nEls laboratoris són un entorn real d’AWS, per tant, és important que tingueu cura dels recursos i de les vostres accions.\nSi superes el pressupost de 50 dòlars, ja no tindràs accés al tauler d’AWS i perdràs la teva feina. Assegureu-vos de vigilar el pressupost, és responsabilitat de cada estudiant mantenir-se dins del pressupost.\nEls laboratoris tenen una durada de 4 hores. Un cop passades les 4 hores, la sessió expirarà i no podreu accedir al tauler d’AWS. No obstant això, això no vol dir que perdràs el teu treball automàticament. Les tasques i recursos que has creat (com ara instàncies EC2, buckets de S3, etc.) es mantindran accessibles entre sessions, sempre que no els eliminis manualment. Podeu tornar a iniciar el laboratori de forma il·limitada, però és una bona pràctica aturar o tancar manualment els serveis que ja no necessiteu per evitar que consumeixin recursos innecessàriament.\n\nPer tant, si comences un laboratori i el deixes a mig fer, podràs reprendre’l en una sessió posterior.\n\n\nGenial! Ara heu accedit al tauler d’AWS. Veureu una pantalla similar a la següent:\n\n\n\n\nLa clau SSH és un mecanisme de seguretat que permet l’autenticació segura entre dos sistemes. El servidor d’Amazon EC2 té la clau pública i el client (el vostre ordinador local) té la clau privada. Quan el client es connecta al servidor, el servidor comprova si la clau pública del client coincideix amb la clau privada del servidor. Si les claus coincideixen, el client es connecta al servidor. Per tant, la clau privada no s’ha de compartir amb ningú. Mentre que la clau pública es pot compartir amb qualsevol i la podeu fer servir en múltiples servidors. A dia d’avui, no hi ha cap mecanisme per obtenir la clau privada a partir de la clau pública.\nPer crear un parell de claus SSH, utilitzarem la comanda ssh-keygen. Aquesta comanda està disponible a la majoria dels sistemes operatius, inclosos Linux, MacOS i Windows (a través de PowerShell o Windows Subsystem for Linux - WSL). Si utilitzeu Windows i no teniu accés a ssh-keygen, podeu utilitzar eines com PuTTYgen per generar les claus SSH.\nAquesta comanda té diversos paràmetres que permeten personalitzar la clau SSH. Els paràmetres més comuns són:\n\n-t: Especifica el tipus de xifratge de la clau. Els tipus més comuns són rsa, dsa, ecdsa i ed25519.\n-f: Especifica el nom del fitxer on es guardarà la clau.\n-b: Especifica la longitud de la clau en bits.\n\n\n\n\n\n\n\nNota\n\n\n\nÉs molt important entendre quan estem treballant al nostre ordinador local i quan estem treballant a la màquina remota. El primer pas sempre serà obrir un terminal al nostre propi ordinador, però un cop ens connectem a la màquina remota mitjançant l’ordre SSH, encara que sembli que res no ha canviat, el terminal ara està connectat a la màquina remota. Això vol dir que a partir d’ara les ordres que escrivim s’executaran a la màquina remota, no al nostre ordinador local. Si no esteu segurs si esteu treballant al vostre ordinador local o a la màquina remota, només heu d’escriure pwd i veure quin és el resultat. Si és el vostre ordinador local, veureu la ruta al directori en què esteu al vostre ordinador local, si és la màquina remota, veureu la ruta al directori en què esteu a la màquina remota. pwd significa print working directory.\n\n\nEl primer pas per crear el parell de claus SSH serà assegurar-nos que el directori .ssh existeix. Per fer-ho, obriu un terminal al vostre ordinador local i escriviu la següent ordre:\nmkdir .ssh\n\n\n\n\n\n\nAlerta\n\n\n\nSi el directori .ssh ja existeix, obtindreu un error indicant que el directori ja existeix. Això és normal, només vol dir que el directori ja estava allà.\n\n\nAra crearem el parell de claus SSH. Escriviu la següent ordre:\nssh-keygen -t rsa -f .ssh/aws-keypair\nSe us demanarà que introduïu una contrasenya. Podeu deixar-la buida prement Enter dues vegades (us recomano fer-ho per simplicitat, si no, cada vegada que us connecteu a la màquina remota haureu d’introduir la contrasenya). Hauríeu de veure una sortida similar a la següent:\nGenerating public/private rsa key pair.\nEnter passphrase (empty for no passphrase):\nEnter same passphrase again:\nYour identification has been saved in .ssh/aws-keypair\nYour public key has been saved in .ssh/aws-keypair.pub\nThe key fingerprint is:\nSHA256:uhINFvYaJh6MbwFQCXdZyrW7W46jFGHUhLglDgQ5OYE ferran@DESKTOP-0841\n+---[RSA 3072]----+\n|XBooo*+          |\n|E.++*o..         |\n| O ==o.          |\n|. B.=...         |     \n| o *.=. S        |\n|  + o..o         |\n| .  ..o .        |\n|   .. .*         |\n|    .o+..        |\n+----[SHA256]-----+\nAquí, ssh-keygen és l’ordre per generar el parell de claus, -t rsa especifica el tipus de clau a crear, en aquest cas una clau RSA, i -f .ssh/aws-keypair especifica el nom del fitxer per al parell de claus. Podeu anomenar el fitxer com vulgueu, però és important recordar el nom que li heu donat. En aquest cas, l’estem anomenant aws-keypair. Us recomano que el nomeu igual que jo per no confondre-us més endavant.\n\n\n\n\n\n\nConsellEntendre les claus SSH - Veure video\n\n\n\nEs clau entendre com funcionen les claus públiques i privades i com s’utilitzen per establir una connexió SSH, heu de veure aquest vídeo.\n\n\nUna altra vegada, podem comprovar el contingut del directori .ssh escrivint la següent ordre:\nls .ssh\nHauríem de veure ara dos fitxers, aws-keypair i aws-keypair.pub. El primer és la clau privada i el segon és la clau pública. La clau privada mai s’ha de compartir amb ningú, mentre que la clau pública és la que s’ha de compartir amb la màquina remota. Una ordre útil per inspeccionar el contingut d’un fitxer és cat. Per exemple, per veure el contingut de la clau pública, escriviu la següent ordre:\ncat .ssh/aws-keypair.pub\n\n\n\n\n\n\nNota\n\n\n\nTambé podeu inspeccionar el contingut de la carpeta .ssh i dels fitxers que hi ha dins utilitzant l’Explorador de fitxers (o Finder en dispositius Mac). Però tingueu cura, per defecte, les carpetes i fitxers que comencen amb un . (com .ssh) estan ocults en la majoria d’exploradors de fitxers i si voleu poder veure’ls, haureu d’habilitar l’opció per mostrar fitxers ocults. Consulteu aquest tutorial per veure com fer-ho al vostre sistema operatiu. Una altra cosa a tenir en compte és que les extensions de fitxer (és a dir, la part del nom del fitxer que ve després del darrer .) també solen estar ocultes, això vol dir que a l’Explorador de fitxers potser veieu dos fitxers anomenats aws-keypair quan en realitat un és aws-keypair i l’altre és aws-keypair.pub. Aquí teniu un tutorial sobre com mostrar les extensions de fitxer al vostre sistema operatiu.\nNo cal que us preocupeu per res d’això si esteu utilitzant el terminal, el terminal us mostrarà els fitxers i les seves extensions tal com són. Però per veure fitxers i carpetes ocults (aquells que comencen amb un .) haureu d’utilitzar l’ordre ls -a.\nls -a .ssh\n\n\nHem creat un parell de claus SSH que podem utilitzar per connectar-nos a màquines remotes. A continuació, importarem la nostra clau pública a AWS.\n\n\n\nAra que hem creat el nostre parell de claus SSH, hem d’importar la clau pública a AWS per poder utilitzar-la per connectar-nos a les instàncies EC2 que crearem més endavant. Per fer-ho, hem de tornar al tauler d’AWS, que és on vam acabar després de completar el Pas 2.\nAra anirem a la barra de cerca i buscarem el servei EC2. Escriviu EC2 a la barra de cerca i feu clic al servei EC2, com es mostra a continuació:\n\n\n\nAWS Dashboard\n\n\nAra veureu el tauler d’EC2. A la part esquerra de la pantalla, veureu una llista d’opcions. Feu clic a Key Pairs (Pares de claus) i després a Create key pair (Crear parell de claus), com es mostra a continuació:\n\n\n\nAWS Dashboard\n\n\nAra heu de donar un nom al parell de claus. Podeu anomenar-lo com vulgueu, però us suggereixo que el anomeneu aws-keypair per mantenir les coses simples. Assegureu-vos que l’opció Key type (Tipus de clau) estigui configurada a RSA i que l’opció Private key file format (Format del fitxer de clau privada) estigui configurada a PEM. Això és important perquè la clau privada s’ha d’utilitzar en format PEM per connectar-se a la màquina remota. Feu clic a Create key pair (Crear parell de claus), com es mostra a continuació:\n\n\n\nAWS Dashboard\n\n\n\n\n\n\n\n\nNota\n\n\n\nPodeu també fer clic al botó Browse per seleccionar el fitxer de clau pública des del vostre ordinador. Només cal que feu clic a Browse, navegueu fins a la carpeta .ssh i seleccioneu el fitxer aws-keypair.pub. Però recordeu, el fitxer ha de ser el fitxer de clau pública, no el fitxer de clau privada. És a dir, el fitxer ha de tenir l’extensió .pub. Un cop hàgiu seleccionat el fitxer, feu clic a Import Key Pair.\nRecordeu que com s’ha explicat a la nota anterior, potser no veureu la carpeta .ssh a l’explorador de fitxers i potser no veureu l’extensió .pub del fitxer. Si teniu problemes amb això, us recomano utilitzar el terminal per copiar el contingut del fitxer com es mostra a la captura de pantalla anterior.\n\n\nAra hauríeu de veure el parell de claus que acabeu d’importar a la llista de parells de claus. Probablement hi haurà un altre parell de claus allà, això està bé, podeu ignorar-lo. Perfecte! Ara heu importat la clau pública a AWS. A continuació, crearem una instància EC2 i la configurarem per utilitzar el parell de claus que acabem d’importar.\n\n\n\nEl primer pas serà anar al tauler d’EC2. Podeu fer-ho escrivint EC2 a la barra de cerca i fent clic al servei EC2, com vam fer al principi del Pas 3:\n\n\n\nAWS Dashboard\n\n\nUn cop estigueu al tauler d’EC2, feu clic a Instances &gt; Launch Instance, com es mostra a continuació:\n\n\n\nAWS Dashboard\n\n\nDeixeu-ho tot com està excepte l’opció Key pair (login) (Parell de claus (inici de sessió)) (haureu de desplaçar-vos cap avall per trobar-la). Feu clic al menú desplegable i seleccioneu el parell de claus que heu importat anteriorment. En aquest cas, hauria de ser aws-keypair. Feu clic a Launch instance, com es mostra a continuació:\n\n\n\nAWS Dashboard\n\n\nAra tenim una instància EC2 en execució amb la nostra clau pública importada. Això significa que tenim una màquina remota a AWS a la qual podem connectar-nos des del nostre ordinador local mitjançant SSH. Vegem com fer-ho.\n\n\n\nAbans de connectar-nos a la màquina remota, vull que proveu alguns ordres al vostre ordinador local que després repetirem un cop estiguem connectats a la màquina remota. Una de les ordres és pwd, que significa print working directory, com ja s’ha comentat anteriorment. Aquesta ordre us mostrarà la ruta al directori en què esteu actualment. L’altra ordre és whoami, que us mostrarà el nom d’usuari amb el qual heu iniciat sessió. Proveu aquestes ordres al vostre ordinador local i recordeu-ne la sortida. Les repetirem un cop estiguem connectats a la màquina remota.\nA continuació es mostra la sortida que obtinc al meu ordinador local:\nPS C:\\Users\\fnao&gt; pwd\n\nPS C:\\Users\\fnao&gt; whoami\ngft\\fnao\nPS C:\\Users\\fnao&gt;\n\n\n\n\n\n\nAlerta\n\n\n\nEl ordinador local que utilitzo és un portàtil amb Windows, així que la sortida serà diferent de la vostra si esteu utilitzant un Mac o un ordinador amb Linux. Substitueix fnao pel vostre nom d’usuari i C:\\Users\\fnao per la ruta al vostre directori d’usuari.\n\n\nPer connectar-nos a la instància EC2, utilitzarem el terminal del nostre ordinador local. Així com vam fer al principi Pas 3, obriu un terminal al vostre ordinador local. Utilitzarem l’ordre ssh per connectar-nos a la màquina remota. L’ordre tindrà aquest aspecte:\nssh -i .ssh/aws-keypair ec2-user@&lt;public-ip&gt;\nHaureu de substituir &lt;public-ip&gt; per la IP pública de la instància EC2. Per trobar la IP pública, torneu al tauler d’EC2 i feu clic a Instances a la part esquerra de la pantalla. Veureu una llista d’instàncies, feu clic a la instància que heu creat. Veureu la IP pública a la part inferior de la pantalla com es mostra a continuació:\n\n\n\nAWS Dashboard\n\n\nTant l’adreça Public IPv4 address com el Public IPv4 DNS es poden utilitzar com a &lt;public-ip&gt; a l’ordre ssh. Copieu el que preferiu i enganxeu-lo a l’ordre ssh. L’ordre hauria d’assemblar-se a alguna cosa així si utilitzeu l’adreça IP:\nssh -i .ssh/aws-keypair ec2-user@98.84.68.70\no així si utilitzeu el DNS:\nssh -i .ssh/aws-keypair ec2-user@ec2-98-84-68-70.compute-1.amazonaws.com\nSi és la primera vegada que us connecteu a la màquina remota, obtindreu una advertència. Això és normal, només heu d’escriure yes i prémer Enter. Ara hauríeu de estar connectats a la màquina remota. Veureu un missatge similar al següent:\n   ,     #_\n   ~\\_  ####_        Amazon Linux 2023\n  ~~  \\_#####\\\n  ~~     \\###|\n  ~~       \\#/ ___   https://aws.amazon.com/linux/amazon-linux-2023\n   ~~       V~' '-&gt;\n    ~~~         /\n      ~~._.   _/\n         _/ _/\n       _/m/'\nLast login: Sun Mar  2 09:50:33 2025 from 79.156.58.43\n[ec2-user@ip-172-31-86-82 ~]$\n\n\n\n\n\n\nImportantExercici\n\n\n\nInvestiga quin és el significat i la importànica del missatge que acceptes quan et connectes per primera vegada a la màquina remota. Per què és important acceptar aquest missatge? Què significa? Quines implicacions té?\n\n\nFantàstic! Ara esteu connectats a la màquina remota. És important entendre que a partir d’ara, les ordres que escrivim s’executaran a la màquina remota, no al nostre ordinador local. Per comprovar-ho, escriviu les ordres pwd i whoami com vam fer al nostre ordinador local. Veureu que la sortida és diferent. A continuació es mostra la sortida que obtinc a la màquina remota:\n[ec2-user@ip-172-31-86-82 ~]$ pwd\n/home/ec2-user\n[ec2-user@ip-172-31-86-82 ~]$ whoami\nec2-user\n[ec2-user@ip-172-31-86-82 ~]$\n\n\n\n\n\n\nNota\n\n\n\nAquesta vegada la sortida hauria de ser la mateixa que la meva. Observeu que el prompt [ec2-user@ip-172-31-86-82 ~]$ és diferent, però això no forma part de les sortides de les ordres. Les sortides de les ordres són pwd i whoami, que són home/ec2-user i ec2-user respectivament. El prompt és només una manera de mostrar-vos on esteu al sistema de fitxers i qui sou com a usuari connectat.\n\n\n\n\n\n\n\n\nImportantExercici\n\n\n\nUtilitza la comanada lastlog i investiga com administrador com podem trueure partit d’aquesta informació.",
    "crumbs": [
      "Laboratoris",
      "Unitat 01 · Fonaments de l'Administració de Sistemes",
      "Laboratori 01 · Introducció a AWS"
    ]
  },
  {
    "objectID": "laboratories/01-foundations/01-aws-introduction.html#execucio-en-el-nostre-laboratori-remot",
    "href": "laboratories/01-foundations/01-aws-introduction.html#execucio-en-el-nostre-laboratori-remot",
    "title": "Unitat 1 · Laboratori de preparació i comandes bàsiques d’administració",
    "section": "Execució en el nostre laboratori remot",
    "text": "Execució en el nostre laboratori remot\nEn aquest apartat de laboratori, treballarem la comunicació amb servidors remots i la transferència de fitxers entre la màquina local i la màquina remota. Utilitzarem un script de Python per simular una càrrega de treball i generar un gràfic a partir d’un fitxer de dades. Aquest laboratori es durà a terme a la instància EC2 que hem creat anteriorment.\n\nPas 1: Configuració de l’entorn remot a l’EC2\nPrimer, hem de preparar l’entorn a la nostra instància EC2. Això inclou instal·lar les eines necessàries per executar el nostre script de Python i gestionar les dades. Per tant, ens connectarem a la instància EC2 mitjançant SSH com hem fet anteriorment i executarem les següents ordres per instal·lar les eines necessàries.\n# Connecta't a la instància EC2\nssh -i .ssh/aws-keypair ec2-user@&lt;public-ip&gt;\n\nActualització del sistema:\n\nsudo yum update -y\n\nComprova si tens instal·lat Python i, si no, instal·la’l:\n\npython3 --version # Comprova si Python està instal·lat\nsudo yum install python3 -y # Instal·la Python si no està instal·lat\n\nCrea un entorn virtual per a Python:\n\npython3 -m venv myenv\nsource myenv/bin/activate\n\nComprova l’entorn virtual amb un Hello World:\n\npython3 -c \"print('Hello World from the virtual environment')\"\n\n\n\n\n\n\nImportantExercici\n\n\n\nAra utiltiza la comanda exit per sortir de la màquina remota. Un cop al teu ordinador local, torna a connectar-te a la màquina remota amb SSH i torna a executar la comanda python3 -c \"print('Hello World from the virtual environment')\". Quin és el resultat? Per què és diferent del que has obtingut abans? Com ho podem solucionar?\n\n\n\nInstal·la les biblioteques necessàries per al nostre script:\n\npip install pandas matplotlib psutil\n\nCrea un directori per al projecte i entra-hi:\n\nmkdir lab01-workload-simulation\ncd lab01-workload-simulation\n\nCrea el fitxer del script de Python, utilitzant vi o vim:\n\nvi simulate_workload.py\n\n#!/usr/bin/env python3\nimport sys\nimport time\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\ndef main():\n    if len(sys.argv) != 2:\n        print(\"Ús: python3 simulate.py workload.csv\")\n        sys.exit(1)\n\n    csv_file = sys.argv[1]\n    df = pd.read_csv(csv_file)\n\n    print(\"Simulació d'ús de CPU i memòria (amb gràfic)\\n\")\n\n    plt.ion()\n    fig, ax = plt.subplots()\n    cpu_vals, mem_vals, ts_vals = [], [], []\n\n    for i, row in df.iterrows():\n        ts = row['timestamp']\n        cpu = row['cpu_usage']\n        mem = row['memory_usage']\n\n        print(f\"[{ts}] CPU: {cpu:.2f}%  |  MEM: {mem:.2f}%\")\n\n        ts_vals.append(ts)\n        cpu_vals.append(cpu)\n        mem_vals.append(mem)\n\n        ax.clear()\n        ax.plot(ts_vals, cpu_vals, label=\"CPU (%)\", color=\"tab:red\", marker=\"o\")\n        ax.plot(ts_vals, mem_vals, label=\"Memòria (%)\", color=\"tab:blue\", marker=\"x\")\n        ax.set_ylim(0, 100)\n        ax.set_xlabel(\"Temps\")\n        ax.set_ylabel(\"Ús (%)\")\n        ax.set_title(\"Simulació de càrrega del sistema\")\n        ax.legend()\n        plt.xticks(rotation=45)\n\n\n    print(\"\\n--- Fi de la simulació ---\")\n    plt.savefig(\"workload_analysis.png\")\n\nif __name__ == \"__main__\":\n    main()\n\nSi el fitxer existeix, pots executar-lo amb la següent ordre:\n\npython3 simulate_workload.py workload.csv\nEn aquest punt, hauríeu de veure un error indicant que el fitxer workload.csv no existeix. Això és normal perquè encara no hem pujat el fitxer de dades a la instància EC2.\n\n\nPas 2: Transferència del fitxer de dades a la instància EC2\nPer transferir el fitxer de dades workload.csv a la instància EC2, utilitzarem SFTP (SSH File Transfer Protocol). SFTP és un protocol segur per transferir fitxers entre un ordinador local i una màquina remota. Utilitzarem el mateix parell de claus SSH que vam crear anteriorment per autenticar-nos a la instància EC2.\n\nDescarrega’t el fitxer de dades workload.csv al teu ordinador local.\nUtilitza SFTP per pujar el fitxer de dades a la instància EC2:\n\n# Substitueix &lt;public-ip&gt; per la IP pública de la teva instància EC2\nsftp -i .ssh/aws-keypair ec2-user@&lt;public-ip&gt;:/home/ec2-user/lab01-workload-simulation\n# Baixa el fitxer workload.csv del directori remot a la màquina local\nput workload.csv\n# Tanca la sessió SFTP\nexit\n\nTorna a connectar-te a la instància EC2 mitjançant SSH, i executa el programa de Python de nou:\n\npython3 simulate_workload.py workload.csv\nAra hauria de funcionar correctament i generar un fitxer d’imatge amb el gràfic de la càrrega de treball. Pots comprovar que el fitxer d’imatge s’ha creat correctament amb l’ordre ls -l. Un cop la imatge s’ha generat, pots utilitzar SFTP per baixar-la a la teva màquina local:\n# Substitueix &lt;public-ip&gt; per la IP pública de la teva instància EC2\nsftp -i .ssh/aws-keypair ec2-user@&lt;public-ip&gt;:/home/ec2-user/lab01-workload-simulation\n# Baixa el fitxer workload_analysis.png del directori remot a la màquina local\nget workload_analysis.png\n# Tanca la sessió SFTP\nexit\n\n\n\n\n\n\nImportantExercicis\n\n\n\n\nCom podem descarregar tots els fitxers d’un directori remot a la nostra màquina local utilitzant el protocol SFTP? Per exemple, imagina que necessites descarregar tot el contingut del directori remot anomenat lab-workload-simulation. Explica els passos o la comanda que utilitzaries per dur a terme aquesta tasca de manera eficient.\nCom podem descarregar un fitxer específic des d’una URL directament a un servidor remot? Per a fer-ho més pràctic, prepara un script que, donada una URL, descarregui un fitxer directament al servidor remot sense passar-lo per la màquina local. Fes el test amb el fitxer workload.csv que hem utilitzat en aquest laboratori.",
    "crumbs": [
      "Laboratoris",
      "Unitat 01 · Fonaments de l'Administració de Sistemes",
      "Laboratori 01 · Introducció a AWS"
    ]
  },
  {
    "objectID": "laboratories/01-foundations/01-aws-introduction.html#tasques-basiques-dadministracio",
    "href": "laboratories/01-foundations/01-aws-introduction.html#tasques-basiques-dadministracio",
    "title": "Unitat 1 · Laboratori de preparació i comandes bàsiques d’administració",
    "section": "Eines bàsqiques d’administració",
    "text": "Eines bàsqiques d’administració\nEn aquest apartat, explorarem algunes tasques bàsiques d’administració que podem realitzar en un servidor Linux. Aquestes tasques inclouen la gestió de l’espai en disc.\n\nGestió de l’espai en disc\nAmb la comanda df -h podem veure l’espai en disc disponible i utilitzat a les particions del sistema. Aquesta comanda ens mostrarà informació sobre l’espai en disc de cada partició, incloent-hi la mida total, l’espai utilitzat, l’espai disponible i el punt de muntatge. En aquest curs estudiarem el sistema de fitxers en profunditat, però ara només introduirem la comanda i veurem el seu resultat.\n[ec2-user@ip-172-31-30-17 ~]$ df -h\nFilesystem        Size  Used Avail Use% Mounted on\ndevtmpfs          4.0M     0  4.0M   0% /dev\ntmpfs             453M     0  453M   0% /dev/shm\ntmpfs             181M  424K  181M   1% /run\n/dev/nvme0n1p1    8.0G  2.0G  6.1G  25% /\ntmpfs             453M     0  453M   0% /tmp\n/dev/nvme0n1p128   10M  1.3M  8.7M  13% /boot/efi\ntmpfs              91M     0   91M   0% /run/user/1000\nEn aquest cas, podem veure que la partició /dev/nvme0n1p1 té una mida total de 8.0 GB, amb 2.0 GB utilitzats i 6.1 GB disponibles. Això significa que el 25% de l’espai en disc està utilitzat. El seu punt de muntatge és /, que és el directori arrel del sistema de fitxers. La resta de particions les podem ignorar per ara i les veurem en detall més endavant.\nA més, també podem utilitzar la comanda du per veure l’espai en disc utilitzat per un directori específic. Per exemple, si volem veure l’espai en disc utilitzat pel directori /home/ec2-user, podem utilitzar la comanda següent:\n[ec2-user@ip-172-31-30-17 ~]$ du -sh /home/ec2-user\n301M    /home/ec2-user\nAquesta comanda ens mostrarà l’espai en disc utilitzat pel directori /home/ec2-user i tots els seus subdirectoris. L’opció -s indica que volem un resum de l’espai utilitzat, i l’opció -h mostra la sortida en un format llegible per humans (per exemple, en KB, MB, GB). En aquest cas, podem veure que el directori /home/ec2-user utilitza 301 MB d’espai en disc.\nPodem crear un fitxer de prova per veure com afecta l’espai en disc. Per exemple, podem crear un fitxer de text gran amb la comanda dd:\ndd if=/dev/zero of=largefile.txt bs=1M count=100\nAquesta comanda crearà un fitxer anomenat largefile.txt de 100 MB ple de zeros. Ara podem tornar a executar la comanda du -sh /home/ec2-user per veure com ha canviat l’espai en disc utilitzat pel directori /home/ec2-user:\n[ec2-user@ip-172-31-30-17 ~]$ du -sh /home/ec2-user\n401M    /home/ec2-user\nPer eliminar el fitxer que hem creat, podem utilitzar la comanda rm:\nrm largefile.txt\n\n\n\n\n\n\nImportantExercici\n\n\n\n\nCompleta aquest script perque ens permeti llegir un fitxer de text línia a línia, cada linia conté el nom i la mida en MB d’un fitxer que volem crear. El script ha de crear els fitxers amb la mida especificada al directori on s’executa el script.\n\nwhile read -r nom_fitxer mida_mb; do\n  \ndone &lt; \"$1\"\n\nUtiltiza la comanda du, sort, head, tail per obtenir el fitxer més gran i el més petit del directori on s’executa el script.\nUtilitza la comanda find per trobar tots els fitxers més grans de 10 MB al directori on s’executa el script.",
    "crumbs": [
      "Laboratoris",
      "Unitat 01 · Fonaments de l'Administració de Sistemes",
      "Laboratori 01 · Introducció a AWS"
    ]
  },
  {
    "objectID": "laboratories/01-foundations/01-aws-introduction.html#neteja-final",
    "href": "laboratories/01-foundations/01-aws-introduction.html#neteja-final",
    "title": "Unitat 1 · Laboratori de preparació i comandes bàsiques d’administració",
    "section": "Neteja final",
    "text": "Neteja final\nUn cop hàgiu acabat el laboratori, és important que tanqueu la instància EC2 per evitar costos innecessaris. Per fer-ho, torneu al tauler d’EC2 i seleccioneu la instància que heu creat. A la part superior de la pantalla, feu clic a Instance state i després a Terminate instance.",
    "crumbs": [
      "Laboratoris",
      "Unitat 01 · Fonaments de l'Administració de Sistemes",
      "Laboratori 01 · Introducció a AWS"
    ]
  },
  {
    "objectID": "laboratories/01-foundations/01-aws-introduction.html#entrega-del-laboratori",
    "href": "laboratories/01-foundations/01-aws-introduction.html#entrega-del-laboratori",
    "title": "Unitat 1 · Laboratori de preparació i comandes bàsiques d’administració",
    "section": "Entrega del laboratori",
    "text": "Entrega del laboratori\nPer a l’entrega d’aquest laboratori, heu de preparar un document PDF amb les respostes completes a tots els exercicis. Un cop finalitzat, cal que el pengeu al Campus Virtual, a l’apartat designat per al Laboratori 1.",
    "crumbs": [
      "Laboratoris",
      "Unitat 01 · Fonaments de l'Administració de Sistemes",
      "Laboratori 01 · Introducció a AWS"
    ]
  },
  {
    "objectID": "laboratories/01-foundations/02-aws-wordpress.html",
    "href": "laboratories/01-foundations/02-aws-wordpress.html",
    "title": "Unitat 1 · Desplegament d’una aplicació web amb AWS",
    "section": "",
    "text": "Desplegar una aplicació web utilitzant serveis d’AWS. En concret, es desplegarà una aplicació WordPress utilitzant Amazon EC2 com a servidor web i Amazon RDS com a base de dades.",
    "crumbs": [
      "Laboratoris",
      "Unitat 01 · Fonaments de l'Administració de Sistemes",
      "Laboratori 02 · Desplegament d'una aplicació web amb AWS"
    ]
  },
  {
    "objectID": "laboratories/01-foundations/02-aws-wordpress.html#objectius",
    "href": "laboratories/01-foundations/02-aws-wordpress.html#objectius",
    "title": "Unitat 1 · Desplegament d’una aplicació web amb AWS",
    "section": "",
    "text": "Desplegar una aplicació web utilitzant serveis d’AWS. En concret, es desplegarà una aplicació WordPress utilitzant Amazon EC2 com a servidor web i Amazon RDS com a base de dades.",
    "crumbs": [
      "Laboratoris",
      "Unitat 01 · Fonaments de l'Administració de Sistemes",
      "Laboratori 02 · Desplegament d'una aplicació web amb AWS"
    ]
  },
  {
    "objectID": "laboratories/01-foundations/02-aws-wordpress.html#bases-de-dades-rds",
    "href": "laboratories/01-foundations/02-aws-wordpress.html#bases-de-dades-rds",
    "title": "Unitat 1 · Desplegament d’una aplicació web amb AWS",
    "section": "Bases de dades RDS",
    "text": "Bases de dades RDS\nEl servei de bases de dades relacional d’Amazon Web Services (RDS) és una opció molt interessant per a desplegar bases de dades MySQL, MariaDB, PostgreSQL, Oracle, SQL Server i Aurora. Aquest servei ofereix una gestió fàcil i eficient de les bases de dades, així com la possibilitat de fer còpies de seguretat, escalabilitat i alta disponibilitat.\n\nAnem a la consola de Amazon RDS.\nA la consola de Amazon RDS, fem clic a Create database.\n\nSeleccionem el mode Standard Create.\nSeleccionem el motor de base de dades MySQL.\nSeleccionem la versió de la base de dades MySQL 8.0.42.\nSeleccionem la plantilla Sandbox.\nNom de la base de dades wordpress.\nMaster username admin.\nGestió de credencials: self-managed.\nSeleccioneu auto-generate a password.\n\nLa resta de paràmetres els deixarem per defecte. Una vegada acabat, fem clic a Create database.\n\n\n\n\n\n\n\nImportantContrassenya\n\n\n\nFeu clic a View Connection Details per veure la password generada. Si no ho feu, haureu d’anar a modificar, regenerar la password i aplicar els canvis.\n\n\n\nEspereu uns minuts fins que la columna Status estigui en verd i posi Available.\nUn cop la base de dades estigui disponible, fem clic a la base de dades i anem a la pestanya Connectivity & security per veure els detalls de connexió.\n\nHostname: database-1.cik8jidkherq.us-east-1.rds.amazonaws.com\nPort: 3306\nUsername: admin\nDatabase name: wordpress\n\nAra ja podem connectar-nos a la base de dades amb un client MySQL com MySQL Workbench o phpMyAdmin.\n\nHostname: database-1.cik8jidkherq.us-east-1.rds.amazonaws.com\nPort: 3306\nUsername: admin\nPassword: XXXXXXXXXXXXXXX (la que heu generat abans)\n\nPer testejar la connexió, necessitem un client MySQL. La manera més senzilla és crear una instància EC2 i instal·lar el client MySQL.\n\n\nCrea una instància EC2 amb Amazon Linux 2023 (igual que en el laboratori anterior).\nConnecta’t a la instància EC2 via SSH.\nInstal·la el client MySQL:\n# Busquem el paquet a instal·lar\ndnf search mysql\n# Instal·lem el client mariadb\nsudo dnf install mariadb105 -y\nConnecta’t a la base de dades RDS des de la instància EC2:\nmysql -h hostname -u admin -p\n# Introdueix la contrassenya quan et demani\n\nEn aquest punt, observarem que no ens podem connectar a la base de dades. Això és degut a que la base de dades està protegida per un Security Group que no permet connexions des de l’exterior. Per solucionar-ho, hem d’afegir una regla al Security Group de la base de dades per permetre connexions des de la instància EC2.\n\nAnem a la consola d’Amazon RDS.\nSeleccionem la nostra instància de base de dades.\nA la secció de Connectivity & security, busquem el Security Group associat a la base de dades.\nFem clic al Security Group per editar les regles (semblant a default sg-0efc4051ab6288a2d).\nAfegim una nova regla d’entrada (Inbound rule) per permetre connexions des de l’adreça IP de la nostra instància EC2. Seleccionem el tipus de connexió MySQL/Aurora i introduïm l’adreça IP de la instància EC2. Per fer-ho, has de clicar a Edit inbound rules i després afegir la regla següent:\n\n  Type: MySQL/Aurora\n  Protocol: TCP\n  Port Range: 3306\n  Source: Custom\n  Seleccionar el grup de seguretat de la instància EC2 (launch-wizard-1)\n\n\n\n\n\n\nNotaObservació\n\n\n\nAquesta regla permetrà connexions a la base de dades des de qualsevol instància EC2 que utilitzi aquest grup de seguretat (launch-wizard-1).\n\n\n\nGuardem les regles i tornem a intentar connectar-nos a la base de dades des de la instància EC2.\nSi tot ha anat bé, ara sí que ens podrem connectar a la base de dades.\nUn cop connectats, ja podem crear la base de dades wordpress i l’usuari wordpress amb tots els permisos.\nCREATE DATABASE wordpress;\nCREATE USER 'wordpress'@'%' IDENTIFIED BY 'wordpress';\nGRANT ALL PRIVILEGES ON wordpress.* TO 'wordpress'@'%';\nFLUSH PRIVILEGES;\nexit\nJa tenim la base de dades preparada per a la instal·lació de WordPress.\n\n\nInstal·lació de WordPress a l’instància EC2\n\nPer instal·lar WordPress, primer hem d’instal·lar un servidor web (Apache):\nsudo dnf install httpd -y\nsudo systemctl start httpd\nsudo systemctl enable httpd\n\n\n\n\n\n\n\nConsellNota\n\n\n\nObserveu que l’ordre start inicia el servei Apache, però no el fa arrencar automàticament en reiniciar la màquina. Per això, hem d’executar també l’ordre enable.\n\n\n\nPer defecte, el grup de seguretat de la instància EC2 no permet connexions HTTP (port 80). Podeu comprovar-ho intentant accedir a l’adreça IP pública de la instància EC2 des del navegador web. Veureu que no es pot connectar.\n\n\n\n\n\n\n\nConsellNota\n\n\n\nSi feu clic a l’enllaç de l’adreça IP pública intentarà accedir per https, però com que no tenim certificat SSL, no funcionarà. Modifiqueu manualment la url per http://.\n\n\n\nHem d’afegir una regla d’entrada al grup de seguretat per permetre connexions HTTP.\n\nAnem a la consola d’EC2.\nSeleccionem la nostra instància EC2.\nA la secció de Security, fem clic al Security Group associat a la instància (launch-wizard-1).\nAfegim una nova regla d’entrada (Inbound rule) per permetre connexions HTTP:\n\nType: HTTP\nProtocol: TCP\nPort Range: 80\nSource: Anywhere (0.0.0.0/0)\n\n\n\n\n\n\n\nConsellNota\n\n\n\nAquesta regla permetrà connexions HTTP des de qualsevol lloc.\n\n\n\nUn cop afegida la regla, ja podem accedir a l’adreça IP pública de la instància EC2 des del navegador web. Haurem de veure la pàgina per defecte d’Apache.\nUn requisit per a WordPress és tenir PHP instal·lat. Instal·lem PHP i les extensions necessàries:\nsudo dnf install php8.1 -y\nsudo dnf install php-curl php-zip php-gd php-soap php-intl php-mysqlnd php-pdo -y\nReiniciem el servei Apache per carregar les extensions de PHP:\nsudo systemctl restart httpd\nAra ja podem instal·lar WordPress. Primer, descarreguem l’última versió de WordPress i la desem a la carpeta per defecte d’Apache:\ncd /tmp\nwget https://wordpress.org/latest.tar.gz\ntar -xvzf latest.tar.gz\nsudo mv wordpress/* /var/www/html/\nsudo rm -rf wordpress latest.tar.gz\nsudo chown -R apache:apache /var/www/html/\nAra podeu accedir a l’adreça IP pública de la instància EC2 des del navegador web. Haureu de veure la pàgina d’instal·lació de WordPress.\nSeguiu els passos de la instal·lació de WordPress:\n\nSeleccioneu l’idioma (català).\nFeu clic a Continua.\nFeu clic a Som-hi!.\nIntroduïu les dades de connexió a la base de dades:\n\nDatabase Name: wordpress\nUsername: wordpress (usuari creat abans)\nPassword: wordpress (contrasenya creada abans)\nDatabase Host: l’endpoint de la base de dades RDS (per exemple, database-1.cik8jidkherq.us-east-1.rds.amazonaws.com)\nTable Prefix: wp_ (podeu deixar-ho per defecte)\n\nFeu clic a Envia.\nSi tot és correcte, feu clic a Executa la instal·lació.\nIntroduïu el títol del lloc (AMSA Lab02), el nom d’usuari (jordi), la contrassenya (9T3nEBqnFqDW3uhc7S) i el correu electrònic (jordi@example.com, pot ser qualsevol).\nFeu clic a Instal·la WordPress.\nUn cop acabada la instal·lació, feu clic a Inicia sessió i introduïu les credencials que heu creat.",
    "crumbs": [
      "Laboratoris",
      "Unitat 01 · Fonaments de l'Administració de Sistemes",
      "Laboratori 02 · Desplegament d'una aplicació web amb AWS"
    ]
  },
  {
    "objectID": "laboratories/01-foundations/02-aws-wordpress.html#automatizació-de-la-installació",
    "href": "laboratories/01-foundations/02-aws-wordpress.html#automatizació-de-la-installació",
    "title": "Unitat 1 · Desplegament d’una aplicació web amb AWS",
    "section": "Automatizació de la instal·lació",
    "text": "Automatizació de la instal·lació\nFins ara hem fet la instal·lació de WordPress manualment (pas a pas amb ordres a l’EC2). Una manera més eficient és automatitzar aquest procés utilitzant un script en bash.\n\n\n\n\n\n\nImportantExercici\n\n\n\n\nCreeu un script en bash que faci la instal·lació de WordPress a la instància EC2.\n\n\n\nAquest mètode encara no és ideal, ja que encara estem fent la instal·lació manualment (hem de connectar-nos a l’EC2 i executar l’script). Una forma encara millor és utilitzar eines d’automatització com Ansible.\nEl primer pas és instal·lar Ansible a la nostra màquina local (si no el tenim instal·lat). Si no voleu fer-ho a la vostra màquina local, podeu utilitzar una altra instància EC2 per fer-ho. Per tant, crearem 2 instàncies EC2: una per fer d’Ansible i una altra per instal·lar WordPress, les podeu anomenar ansible i webserver.\nA les dues màquines EC2 heu d’instal·lar el programari ansible amb la comanda següent:\nsudo yum install ansible -y\nAnsible utilitza el protocol SSH per connectar-se a les màquines remotes, per tant, heu de tenir accés SSH a la màquina webserver des de la màquina ansible. Per fer-ho, podeu crear un parell de claus SSH a la màquina ansible i afegir la clau pública al fitxer ~/.ssh/authorized_keys de la màquina webserver.\nUn cop tingueu accés SSH a la màquina webserver des de la màquina ansible, podeu crear un fitxer d’inventari d’Ansible per definir la màquina webserver. Creeu un fitxer anomenat hosts amb el contingut següent (substituïu &lt;IP_INSTANCIA_EC2&gt; per l’adreça IP pública de la vostra instància EC2) i ~/.ssh/my-key-pair per la ruta a la vostra clau privada SSH:\n[webserver]\n&lt;IP_INSTANCIA_EC2&gt; ansible_user=ec2-user ansible_ssh_private_key_file=~/.ssh/my-key-pair\nOn  és l’adreça IP pública de la vostra instància EC2 on voleu instal·lar WordPress i la ruta ~/.ssh/my-key-pair és la ruta a la vostra clau privada SSH que us permet accedir a la instància EC2.\nA continuació, creeu un playbook d’Ansible per instal·lar WordPress a la màquina webserver. Un playbook és un fitxer YAML que defineix les tasques que Ansible ha d’executar a les màquines remotes. Podeu descargar el fitxer wordpress.yml o bé crear-lo amb el contingut següent (substituïu &lt;RDS_ENDPOINT&gt; per l’endpoint de la vostra base de dades RDS):\n---\n- hosts: webserver\n  become: yes\n  tasks:\n    - name: Actualitzar repositoris\n      dnf:\n        name: \"*\"\n        state: latest\n\n    - name: Instal·lar Apache i PHP amb extensions\n      dnf:\n        name: \n          - httpd\n          - php\n          - php-mysqlnd\n          - php-gd\n          - php-xml\n          - php-json\n          - php-intl\n          - php-cli\n        state: present\n\n    - name: Activar i arrencar Apache\n      systemd:\n        name: httpd\n        state: started\n        enabled: yes\n\n    - name: Descarregar WordPress\n      get_url:\n        url: https://wordpress.org/latest.tar.gz\n        dest: /tmp/latest.tar.gz\n\n    - name: Descomprimir WordPress\n      unarchive:\n        src: /tmp/latest.tar.gz\n        dest: /var/www/html/\n        remote_src: yes\n        extra_opts: [--strip-components=1]\n\n    - name: Assignar permisos correctes\n      file:\n        path: /var/www/html\n        owner: apache\n        group: apache\n        mode: '0755'\n        recurse: yes\n\n    - name: Crear arxiu wp-config.php bàsic\n      copy:\n        dest: /var/www/html/wp-config.php\n        content: |\n          &lt;?php\n          define('DB_NAME', 'wordpress');\n          define('DB_USER', 'wordpress');\n          define('DB_PASSWORD', 'wordpress');\n          define('DB_HOST', '&lt;RDS_ENDPOINT&gt;');\n          define('DB_CHARSET', 'utf8');\n          define('DB_COLLATE', '');\n          $table_prefix = 'wp_';\n          define('WP_DEBUG', false);\n          if ( !defined('ABSPATH') )\n            define('ABSPATH', __DIR__ . '/');\n          require_once ABSPATH . 'wp-settings.php';\nFinalment, executeu el playbook d’Ansible per instal·lar WordPress a la vostra instància EC2.\nansible-playbook -i hosts wordpress.yml\nUn cop finalitzat, podeu accedir a l’adreça IP pública de la instància EC2 des del navegador web i completar la instal·lació de WordPress com s’ha descrit anteriorment.\n\n\n\n\n\n\nImportantExercici\n\n\n\n\nReviseu la documentació d’Ansible per utilitzar variables i millorar el playbook wordpress.yml fent-lo més genèric.",
    "crumbs": [
      "Laboratoris",
      "Unitat 01 · Fonaments de l'Administració de Sistemes",
      "Laboratori 02 · Desplegament d'una aplicació web amb AWS"
    ]
  },
  {
    "objectID": "laboratories/01-foundations/02-aws-wordpress.html#entrega-del-laboratori",
    "href": "laboratories/01-foundations/02-aws-wordpress.html#entrega-del-laboratori",
    "title": "Unitat 1 · Desplegament d’una aplicació web amb AWS",
    "section": "Entrega del laboratori",
    "text": "Entrega del laboratori\nHeu de pujar al Campus Virtual, un document amb les següents captures de pantalla:\n\nPantalla de la consola d’Amazon RDS amb la base de dades creada.\nPantalla de la consola d’EC2 amb la instància EC2 creada (eg. podeu fer servir history per veure les ordres que heu executat).\nPantalla del navegador web amb la pàgina d’inici de sessió de WordPress.\nPantalla del tauler d’administració de WordPress.\nPantalla del playbook d’Ansible executat correctament.\n\nA més, heu d’incloure el contingut dels següents fitxers:\n\nScript d’Ansible modificat amb variables (si heu fet l’exercici).\nScript en bash per instal·lar WordPress (si heu fet l’exercici).",
    "crumbs": [
      "Laboratoris",
      "Unitat 01 · Fonaments de l'Administració de Sistemes",
      "Laboratori 02 · Desplegament d'una aplicació web amb AWS"
    ]
  },
  {
    "objectID": "laboratories/01-foundations/02-aws-wordpress.html#neteja-els-recursos-creats",
    "href": "laboratories/01-foundations/02-aws-wordpress.html#neteja-els-recursos-creats",
    "title": "Unitat 1 · Desplegament d’una aplicació web amb AWS",
    "section": "Neteja els recursos creats",
    "text": "Neteja els recursos creats\nUn cop finalitzat podeu eliminar totes les instàncies EC2 i la base de dades RDS per evitar càrrecs innecessaris al vostre compte d’AWS.",
    "crumbs": [
      "Laboratoris",
      "Unitat 01 · Fonaments de l'Administració de Sistemes",
      "Laboratori 02 · Desplegament d'una aplicació web amb AWS"
    ]
  },
  {
    "objectID": "laboratories/01-introduction.html#laboratori-1-fonaments-de-ladministració-de-sistemes-amb-aws",
    "href": "laboratories/01-introduction.html#laboratori-1-fonaments-de-ladministració-de-sistemes-amb-aws",
    "title": "Laboratori: Fonaments de l’Administració de Sistemes amb AWS",
    "section": "Laboratori 1: Fonaments de l’Administració de Sistemes amb AWS",
    "text": "Laboratori 1: Fonaments de l’Administració de Sistemes amb AWS",
    "crumbs": [
      "Laboratoris",
      "Unitat 01 · Fonaments de l'Administració de Sistemes",
      "Laboratori · Fonaments de l'Administració de Sistemes amb AWS"
    ]
  },
  {
    "objectID": "laboratories/01-introduction.html#objectius-del-laboratori",
    "href": "laboratories/01-introduction.html#objectius-del-laboratori",
    "title": "Laboratori: Fonaments de l’Administració de Sistemes amb AWS",
    "section": "Objectius del laboratori",
    "text": "Objectius del laboratori\n\nAccedir a la plataforma de computació en núvol AWS a travvés AWS Educate.\nEntendre els conceptes bàsic d’aministració remota a través de SSH.\nÚs d’autenticació amb claus SSH.\nCrear i gestionar màquines virtuals a AWS EC2.\n\n\n🧪 Laboratori 01: Laboratori de preparació i comandes bàsiques d’administració",
    "crumbs": [
      "Laboratoris",
      "Unitat 01 · Fonaments de l'Administració de Sistemes",
      "Laboratori · Fonaments de l'Administració de Sistemes amb AWS"
    ]
  },
  {
    "objectID": "laboratories/01-introduction.html#laboratori-2-desplegament-duna-aplicació-web-amb-wordpress-a-aws",
    "href": "laboratories/01-introduction.html#laboratori-2-desplegament-duna-aplicació-web-amb-wordpress-a-aws",
    "title": "Laboratori: Fonaments de l’Administració de Sistemes amb AWS",
    "section": "Laboratori 2: Desplegament d’una aplicació web amb WordPress a AWS",
    "text": "Laboratori 2: Desplegament d’una aplicació web amb WordPress a AWS",
    "crumbs": [
      "Laboratoris",
      "Unitat 01 · Fonaments de l'Administració de Sistemes",
      "Laboratori · Fonaments de l'Administració de Sistemes amb AWS"
    ]
  },
  {
    "objectID": "laboratories/01-introduction.html#esquema-de-larquitectura",
    "href": "laboratories/01-introduction.html#esquema-de-larquitectura",
    "title": "Laboratori: Fonaments de l’Administració de Sistemes amb AWS",
    "section": "Esquema de l’arquitectura",
    "text": "Esquema de l’arquitectura",
    "crumbs": [
      "Laboratoris",
      "Unitat 01 · Fonaments de l'Administració de Sistemes",
      "Laboratori · Fonaments de l'Administració de Sistemes amb AWS"
    ]
  },
  {
    "objectID": "laboratories/01-introduction.html#objectius-del-laboratori-1",
    "href": "laboratories/01-introduction.html#objectius-del-laboratori-1",
    "title": "Laboratori: Fonaments de l’Administració de Sistemes amb AWS",
    "section": "Objectius del laboratori",
    "text": "Objectius del laboratori\n\nConèixer els serveis bàsics d’AWS per desplegar aplicacions web.\nDesplegar una base de dades gestionada amb Amazon RDS.\nDesplegar una màquina virtual amb Amazon EC2.\nDesplegar una aplicació web amb WordPress.\nÚs d’Ansible per automatitzar el desplegament de l’aplicació\n\n\n🧪 Laboratori 02: Desplegament d’una aplicació web amb WordPress a AWS",
    "crumbs": [
      "Laboratoris",
      "Unitat 01 · Fonaments de l'Administració de Sistemes",
      "Laboratori · Fonaments de l'Administració de Sistemes amb AWS"
    ]
  },
  {
    "objectID": "CONTRIBUTING.html",
    "href": "CONTRIBUTING.html",
    "title": "Contribueix",
    "section": "",
    "text": "Aquest material és de codi obert i podeu col·laborar-hi, complementar-lo o corregir-lo mitjançant pull requests al repositori.\n\n\n\nFork el repositori: Fes clic al botó Fork a la part superior dreta de la pàgina. Això crearà una còpia del repositori al teu compte de GitHub. Veure imatge:\n\n\n\n\nClona el repositori a la teva màquina: Utilitza Git per clonar el repositori que has clonat a la teva màquina.\nCrea una branca (branch) nova: Abans de fer canvis, crea una branca nova on faràs les teves modificacions. Això ajuda a mantenir les coses ordenades. Utilitza la comanda següent:\n\ngit checkout -b nom_de_la_branca\n\nFes els canvis: Realitza les modificacions necessàries en els fitxers del projecte.\nAfegeix i commiteja els canvis: Utilitza els següents comandos per afegir els canvis i fer un commit.\nPuja els canvis al teu repositori a GitHub amb la comanda següent:\n\ngit push origin nom_de_la_branca\n\nCrea una PR: Vés al teu repositori a GitHub i selecciona la branca on has fet els canvis. Apareixerà un missatge destacat dient que has fet una nova branca. Fes clic a “Compare & pull request” per començar la PR.\n\nTambé, pots anar a la nova branca fent click al menu desplegable i seleccionant la branca que has creat 1 i fent click al botó New pull request 2. Veure imatge:\n\n\nProporciona una descripció detallada dels canvis que has fet. A més, pots afegir captures de pantalla o informació addicional per ajudar els revisors a entendre els teus canvis. Fes clic a New pull request i beuras una pantalla com la següent:\n\n\n1 Indica el meu repositori (on vols enviar les modificacions) i 2 indica el teu fork (on has fet les modificacions). Assegura’t de seleccionar la branca amb les modificacions 3. Finalment, fes clic a Create pull request 4.\n\nEnvia la PR: Un cop hagis omplert tota la informació, fes clic al botó “Create pull request” per enviar la PR al projecte original.\n\n\n\n\nPer editar el material:\n\nAl teu ordinador, necessitareu instal·lar Quarto.\nDirectament al navegador, podeu editar els fitxers .qmd fent clic al botó de llapis que apareix a la part superior dreta de cada fitxer. Això crearà una nova branca amb els teus canvis i et permetrà fer una PR directament des del navegador.\n\n\n\nAbans de començar, assegura’t que tens Quarto instal·lat al teu ordinador. Obra un terminal o un IDE com VSCode i navega fins a la carpeta on tens el projecte.\nPer veure una previsualització local del lloc web:\nquarto preview\nAixò obrirà una previsualització local al teu navegador. La previsualització s’actualitza automàticament quan deses els canvis.\n\n\n\nEs pot integrar amb Visual Studio Code (VSCode) per a una millor experiència d’edició. Si no tens VSCode, pots descarregar-lo des de https://code.visualstudio.com/.\n\nQuarto: Edició en mode visual: Permet editar els fitxers .qmd en un mode visual que facilita l’ús de les funcions de Quarto.\nQuarto: Previsualització: Obre una previsualització del fitxer .qmd actual.\nQuarto: Edició en mode font: Torna a l’edició en mode text pla."
  },
  {
    "objectID": "CONTRIBUTING.html#instruccions-per-contribuïr",
    "href": "CONTRIBUTING.html#instruccions-per-contribuïr",
    "title": "Contribueix",
    "section": "",
    "text": "Fork el repositori: Fes clic al botó Fork a la part superior dreta de la pàgina. Això crearà una còpia del repositori al teu compte de GitHub. Veure imatge:\n\n\n\n\nClona el repositori a la teva màquina: Utilitza Git per clonar el repositori que has clonat a la teva màquina.\nCrea una branca (branch) nova: Abans de fer canvis, crea una branca nova on faràs les teves modificacions. Això ajuda a mantenir les coses ordenades. Utilitza la comanda següent:\n\ngit checkout -b nom_de_la_branca\n\nFes els canvis: Realitza les modificacions necessàries en els fitxers del projecte.\nAfegeix i commiteja els canvis: Utilitza els següents comandos per afegir els canvis i fer un commit.\nPuja els canvis al teu repositori a GitHub amb la comanda següent:\n\ngit push origin nom_de_la_branca\n\nCrea una PR: Vés al teu repositori a GitHub i selecciona la branca on has fet els canvis. Apareixerà un missatge destacat dient que has fet una nova branca. Fes clic a “Compare & pull request” per començar la PR.\n\nTambé, pots anar a la nova branca fent click al menu desplegable i seleccionant la branca que has creat 1 i fent click al botó New pull request 2. Veure imatge:\n\n\nProporciona una descripció detallada dels canvis que has fet. A més, pots afegir captures de pantalla o informació addicional per ajudar els revisors a entendre els teus canvis. Fes clic a New pull request i beuras una pantalla com la següent:\n\n\n1 Indica el meu repositori (on vols enviar les modificacions) i 2 indica el teu fork (on has fet les modificacions). Assegura’t de seleccionar la branca amb les modificacions 3. Finalment, fes clic a Create pull request 4.\n\nEnvia la PR: Un cop hagis omplert tota la informació, fes clic al botó “Create pull request” per enviar la PR al projecte original."
  },
  {
    "objectID": "CONTRIBUTING.html#edició-del-material",
    "href": "CONTRIBUTING.html#edició-del-material",
    "title": "Contribueix",
    "section": "",
    "text": "Per editar el material:\n\nAl teu ordinador, necessitareu instal·lar Quarto.\nDirectament al navegador, podeu editar els fitxers .qmd fent clic al botó de llapis que apareix a la part superior dreta de cada fitxer. Això crearà una nova branca amb els teus canvis i et permetrà fer una PR directament des del navegador.\n\n\n\nAbans de començar, assegura’t que tens Quarto instal·lat al teu ordinador. Obra un terminal o un IDE com VSCode i navega fins a la carpeta on tens el projecte.\nPer veure una previsualització local del lloc web:\nquarto preview\nAixò obrirà una previsualització local al teu navegador. La previsualització s’actualitza automàticament quan deses els canvis.\n\n\n\nEs pot integrar amb Visual Studio Code (VSCode) per a una millor experiència d’edició. Si no tens VSCode, pots descarregar-lo des de https://code.visualstudio.com/.\n\nQuarto: Edició en mode visual: Permet editar els fitxers .qmd en un mode visual que facilita l’ús de les funcions de Quarto.\nQuarto: Previsualització: Obre una previsualització del fitxer .qmd actual.\nQuarto: Edició en mode font: Torna a l’edició en mode text pla."
  },
  {
    "objectID": "course-information/schedule.html",
    "href": "course-information/schedule.html",
    "title": "AMSA 105013: System Administration",
    "section": "",
    "text": "A continuació es presenta un calendari complet dels temes, el contingut del curs i les tasques per al semestre. Tingueu en compte que aquest calendari és un document viu i es pot actualitzar. Tots els canvis es publicaran aquí per assegurar-vos que teniu la informació més actual.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSetmana\nTipus\nData\nTema\nDiapositives\nApunts\nLaboratori\nAltres\nTasques\nLliuraments\n\n\n\n\n1\nTeoria\n10/09/25\nUnitat 01: Fonaments de l’Administració de Sistemes\n📖\n\n\n\n📝 📝\n\n\n\n2\nLaboratori\n15/09/25\nUnitat 01: Fonaments de l’Administració de Sistemes\n\n\n🧪 🧪\n\n\n\n\n\n3\nTeoria\n17/09/25\nUnitat 02: Arrencada del sistema\n📖\n\n\n\n📝 📝 📝\n\n\n\n4\nLaboratori\n24/09/25\nUnitat 02: Arrencada del sistema (II)\n📖\n\n\n💬\n📝 📝\n\n\n\n5\nTeoria\n29/09/25\nUnitat 02: Arrencada del sistema (III)\n📖\n\n\n💬\n📝 📝\n👩🏻‍💻\n\n\n6\nLaboratori\n01/10/25\nNetworking\n\n\n🧪\n\n\n\n\n\n7\nTeoria\n06/10/25\nUnitat 03: Sistemes de fitxers (Part 1)\n📖\n\n\n\n📝"
  },
  {
    "objectID": "course-information/schedule.html#planificació",
    "href": "course-information/schedule.html#planificació",
    "title": "AMSA 105013: System Administration",
    "section": "",
    "text": "A continuació es presenta un calendari complet dels temes, el contingut del curs i les tasques per al semestre. Tingueu en compte que aquest calendari és un document viu i es pot actualitzar. Tots els canvis es publicaran aquí per assegurar-vos que teniu la informació més actual.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSetmana\nTipus\nData\nTema\nDiapositives\nApunts\nLaboratori\nAltres\nTasques\nLliuraments\n\n\n\n\n1\nTeoria\n10/09/25\nUnitat 01: Fonaments de l’Administració de Sistemes\n📖\n\n\n\n📝 📝\n\n\n\n2\nLaboratori\n15/09/25\nUnitat 01: Fonaments de l’Administració de Sistemes\n\n\n🧪 🧪\n\n\n\n\n\n3\nTeoria\n17/09/25\nUnitat 02: Arrencada del sistema\n📖\n\n\n\n📝 📝 📝\n\n\n\n4\nLaboratori\n24/09/25\nUnitat 02: Arrencada del sistema (II)\n📖\n\n\n💬\n📝 📝\n\n\n\n5\nTeoria\n29/09/25\nUnitat 02: Arrencada del sistema (III)\n📖\n\n\n💬\n📝 📝\n👩🏻‍💻\n\n\n6\nLaboratori\n01/10/25\nNetworking\n\n\n🧪\n\n\n\n\n\n7\nTeoria\n06/10/25\nUnitat 03: Sistemes de fitxers (Part 1)\n📖\n\n\n\n📝"
  },
  {
    "objectID": "slides/02-booting-part3.html#etapes-de-larrancada",
    "href": "slides/02-booting-part3.html#etapes-de-larrancada",
    "title": "Arrencada del sistema (Part 3)",
    "section": "Etapes de l’arrancada",
    "text": "Etapes de l’arrancada",
    "crumbs": [
      "Diapositives",
      "Unitat 02 · Arrencada del sistema (Part 3)"
    ]
  },
  {
    "objectID": "slides/02-booting-part3.html#pid-1-initsystemd",
    "href": "slides/02-booting-part3.html#pid-1-initsystemd",
    "title": "Arrencada del sistema (Part 3)",
    "section": "PID 1: init/systemd",
    "text": "PID 1: init/systemd\nQuan s’acaba el procés d’inicialització del sistema en l’espai del kernel i es descomprimeix i executa l’initramfs, es produeix una transició important cap a l’espai d’usuari.\nexec switch_root /mnt /sbin/init\n\nEl comandament switch_root substitueix l’arrel del sistema de fitxers actual (l’initramfs) per la partició arrel real del sistema operatiu.\nEl kernel deixa de gestionar directament els processos i passa el control a un procés en l’espai d’usuari.\nEl procés PID 1 és el primer procés que s’inicia en l’espai d’usuari i és responsable de la gestió dels processos del sistema operatiu.\nTradicionalment, aquest procés era el programa init, però en els sistemes moderns, systemd ha substituït init com a responsable principal de la gestió de processos.",
    "crumbs": [
      "Diapositives",
      "Unitat 02 · Arrencada del sistema (Part 3)"
    ]
  },
  {
    "objectID": "slides/02-booting-part3.html#funcions-de-pid-1",
    "href": "slides/02-booting-part3.html#funcions-de-pid-1",
    "title": "Arrencada del sistema (Part 3)",
    "section": "Funcions de PID 1",
    "text": "Funcions de PID 1\n\nGestió de la inicialització del sistema. Carrega els serveis i dimonis necessaris per al bon funcionament del sistema.\nGestió dels processos del sistema. Controla la creació, execució i finalització dels processos. Si un procés orfe (un procés que perd el seu procés pare) continua en execució, el PID 1 assumeix la seva gestió i, eventualment, la seva terminació.\nArrel de l’arbre de processos: Tots els altres processos del sistema pengen d’ell, directament o indirectament. Això fa que sigui fonamental per a l’estabilitat i la continuïtat del sistema.\nApagat i reinici del sistema: El PID 1 també és responsable de controlar l’apagat i reinici del sistema, garantint que els processos es tanquin adequadament i que el sistema es desconnecti de manera segura",
    "crumbs": [
      "Diapositives",
      "Unitat 02 · Arrencada del sistema (Part 3)"
    ]
  },
  {
    "objectID": "slides/02-booting-part3.html#systemd-vs-sysvinit",
    "href": "slides/02-booting-part3.html#systemd-vs-sysvinit",
    "title": "Arrencada del sistema (Part 3)",
    "section": "Systemd vs SysVinit",
    "text": "Systemd vs SysVinit\nEl canvi de SysVinit a Systemd en moltes distribucions de Linux va ser motivat per la necessitat de millorar l’eficiència i la gestió dels serveis del sistema.\n\n\nSysVinit\n\nSeqüencial: Basat en scripts. Cada servei depèn de l’execució completa del servei anterior, la qual cosa pot ser lenta.\nSimple: Cada servei s’inicia amb un script directament llegible i modificable per l’administrador del sistema.\nInflexible: Dificultat engestionar dependències. No permet arrencar serveis en paral·lel ni controlar els processos un cop arrencats.\n\n\nSystemd\n\nRendiment: Capacitat de carregar serveis en paral·lel. Reducció temps d’inici del sistema.\nModularitat: Els serveis es gestionen a través d’unitats (unit files) que poden especificar dependències, condicions de reinici automàtic,etc.\nCgroups: Limitar/gestionar els recursos assignats a cada servei.\nMonitoratge: Control i seguiment granular dels serveis amb journalctl.",
    "crumbs": [
      "Diapositives",
      "Unitat 02 · Arrencada del sistema (Part 3)"
    ]
  },
  {
    "objectID": "slides/02-booting-part3.html#crítiques-a-systemd",
    "href": "slides/02-booting-part3.html#crítiques-a-systemd",
    "title": "Arrencada del sistema (Part 3)",
    "section": "Crítiques a Systemd",
    "text": "Crítiques a Systemd\n\nComplexitat: Integra múltiples funcionalitats (gestió de serveis, journal, timers, logind, networkd, etc.) en un sol procés. Això pot augmentar la superfície de fallada i dificultar la depuració.\nTrenca amb la filosofia Unix tradicional\n\nUnix promou eines petites, especialitzades i composables.\n\nSystemd concentra moltes tasques en un únic sistema de gestió.\n\nDependència del sistema: Molts scripts, paquets i eines modernes depenen de systemd, dificultant la compatibilitat amb sistemes alternatius (SysVinit, OpenRC).\n\n\nDebat en la comunitat\n\nEls defensors de systemd argumenten que simplifica l’administració de sistemes moderns i ofereix funcions que abans requerien múltiples eines externes.\n\nEls crítics insisteixen en que és massa intrusiu i redueix la flexibilitat per a administradors avançats i entorns mínims.",
    "crumbs": [
      "Diapositives",
      "Unitat 02 · Arrencada del sistema (Part 3)"
    ]
  },
  {
    "objectID": "slides/02-booting-part3.html#backdoor-en-xz-utils-i",
    "href": "slides/02-booting-part3.html#backdoor-en-xz-utils-i",
    "title": "Arrencada del sistema (Part 3)",
    "section": "Backdoor en XZ Utils (I)",
    "text": "Backdoor en XZ Utils (I)\nRecents vulnerabilitats en paquets com xz-utils han posat en evidència la complexitat de Systemd i com una backdoor ocult pot comprometre gran part de la infraestructura moderna de Linux.\n\nEl backdoor va ser introduït de manera gradual, començant amb contribucions sospitoses al projecte libarchive el 2021.\nDurant el 2022, un desenvolupador desconegut, JiaT75, va guanyar influència dins del projecte xz-utils, substituint el contacte del mantenidor original i introduint canvis que van ocultar les vulnerabilitats.\nEl 2023, JiaT75 va introduir modificacions malicioses a xz-utils, aprofitant-les per comprometre sistemes a través de dependències amb Systemd.\n\nCVE-2024-3094: Vulnerabilitat que permet l’execució de codi maliciós en el sistema mitjançant un defecte en la descompressió de fitxers .xz.",
    "crumbs": [
      "Diapositives",
      "Unitat 02 · Arrencada del sistema (Part 3)"
    ]
  },
  {
    "objectID": "slides/02-booting-part3.html#backdoor-en-xz-utils-ii",
    "href": "slides/02-booting-part3.html#backdoor-en-xz-utils-ii",
    "title": "Arrencada del sistema (Part 3)",
    "section": "Backdoor en XZ Utils (II)",
    "text": "Backdoor en XZ Utils (II)\nAquesta vulnerabilitat va afectar molts servidors Linux, que van actualitzar xz-utils amb la versió compromesa.\n\nliblzma és una llibreria de compressió que es pot enllaçar amb altres programes. Per exemple, OpenSSH es pot vincular a liblzma per gestionar la descompressió de fitxers de configuració.\nEn sistemes amb systemd, OpenSSH enllaça amb systemd, que a la vegada enllaça amb liblzma. Això permet a XZ Utils controlar indirectament serveis essencials com sshd.\nMitjançant una backdoor oculta en versions modificades de xz-utils, un atacant amb una clau de xifrat prèviament establerta podria carregar codi maliciós en certificats SSH i executar-lo en dispositius compromesos.\n\n\nAquests esdeveniments posen de manifest les contrapartides de la complexitat de Systemd i com una vulnerabilitat en un paquet aparentment inofensiu com xz-utils pot tenir un impacte significatiu en la seguretat del sistema i serveis crítics com sshd.",
    "crumbs": [
      "Diapositives",
      "Unitat 02 · Arrencada del sistema (Part 3)"
    ]
  },
  {
    "objectID": "slides/02-booting-part3.html#executar-els-targets-o-runlevels",
    "href": "slides/02-booting-part3.html#executar-els-targets-o-runlevels",
    "title": "Arrencada del sistema (Part 3)",
    "section": "Executar els Targets o Runlevels",
    "text": "Executar els Targets o Runlevels\nEl PID 1 executa els targets de systemd o runlevels d’init. Els targets representen un conjunt de serveis i mòduls que s’executen per a cada estat del sistema. La seva funció és definir l’estat del sistema i els serveis que s’han de carregar en aquest estat. La transició entre els targets es pot fer manualment amb la comanda systemctl isolate o automàticament amb la comanda systemctl set-default.\n\n\ndefault.target: Apunta a graphical.target o multi-user.target-\ngraphical.target: Defineix un entorn gràfic.\nmulti-user.target: Proporciona un entorn no gràfic, permetent múltiples usuaris al sistema, habitual per a servidors.\nrescue.target: Proporciona un entorn de rescat amb una consola de línia de comandes.\nemergency.target: Ofereix un entorn d’emergència que inicialitza el mínim de serveis necessaris per a la solució de problemes.\nshutdown.target: Gestiona l’apagat del sistema.\nreboot.target: Gestiona el reinici del sistema.",
    "crumbs": [
      "Diapositives",
      "Unitat 02 · Arrencada del sistema (Part 3)"
    ]
  },
  {
    "objectID": "slides/02-booting-part3.html#units-de-systemd",
    "href": "slides/02-booting-part3.html#units-de-systemd",
    "title": "Arrencada del sistema (Part 3)",
    "section": "Units de systemd",
    "text": "Units de systemd\nEls units són els fitxers de configuració de systemd que defineixen els serveis, ens permeten gestionar-los i controlar-los.\n\n/etc/systemd/system/: Fitxers d’unitat personalitzats per l’administrador.\n/run/systemd/system/: Configuració en temps d’execució, és a dir, afecta només un arrencada única.\n/usr/lib/systemd/system/: Configuració proporcionada per la distribució. A Debian és /lib/systemd/system/.\n\n\nQuan hi ha dos fitxers de configuració amb el mateix nom, systemd carregarà només un des del directori que estigui més alt en la jerarquia. Per exemple, la configuració a /etc sempre sobreescriu la configuració a /usr.\n\n\nDesprés de canviar la configuració, és necessari recarregar systemd amb: systemctl daemon-reload.",
    "crumbs": [
      "Diapositives",
      "Unitat 02 · Arrencada del sistema (Part 3)"
    ]
  },
  {
    "objectID": "slides/02-booting-part3.html#tipus-dunitats",
    "href": "slides/02-booting-part3.html#tipus-dunitats",
    "title": "Arrencada del sistema (Part 3)",
    "section": "Tipus d’unitats",
    "text": "Tipus d’unitats\n\nServeis: Fitxers que defineixen com s’inicien, s’aturen i es gestionen els serveis. Ex: /etc/systemd/system/sshd.service (servei SSH).\nSockets: Units que gestionen els sockets de comunicació per als serveis.\nDevices: Units que representen dispositius de maquinari.\nMounts: Units que gestionen els punts de muntatge del sistema de fitxers.\nPaths: Units que monitoren els canvis en fitxers o directoris específics.\nTimers: Units que planifiquen tasques per a la seva execució en moments específics.\nTargets: Units que agrupen altres units per a l’arrencada d’estats del sistema.",
    "crumbs": [
      "Diapositives",
      "Unitat 02 · Arrencada del sistema (Part 3)"
    ]
  },
  {
    "objectID": "slides/02-booting-part3.html#targets-i-systemd",
    "href": "slides/02-booting-part3.html#targets-i-systemd",
    "title": "Arrencada del sistema (Part 3)",
    "section": "Targets i Systemd",
    "text": "Targets i Systemd",
    "crumbs": [
      "Diapositives",
      "Unitat 02 · Arrencada del sistema (Part 3)"
    ]
  },
  {
    "objectID": "slides/02-booting-part3.html#exemple-de-fitxer-dunitat",
    "href": "slides/02-booting-part3.html#exemple-de-fitxer-dunitat",
    "title": "Arrencada del sistema (Part 3)",
    "section": "Exemple de fitxer d’unitat",
    "text": "Exemple de fitxer d’unitat\n\n\n[Unit]\nDescription=CUPS Scheduler\nDocumentation=man:cupsd(8)\nAfter=network.target\n[Service]\nExecStart=/usr/sbin/cupsd -l\nType=notify\n[Install]\nAlso=cups.socket cups.path\nWantedBy=printer.target\n\n\nCUPS (Common Unix Printing System) és un sistema d’impressió utilitzat en sistemes Unix i Linux.\nTé una dependència amb la xarxa (After=network.target), ja que sovint es connecta a impressores de xarxa.\n\n\n\nS’inicia amb el comandament /usr/sbin/cupsd -l, que posa en marxa el servei d’impressió.\nEs configura per iniciar-se automàticament quan s’arrenca el sistema (WantedBy=printer.target).\nCups.socket és una unitat de tipus socket que permet a CUPS escoltar connexions entrants per a serveis d’impressió.\nCups.path és una unitat de tipus path que monitoritza canvis en fitxers o directoris relacionats amb la configuració d’impressió.\n\n\nAquest fitxer defineix el servei CUPS (Common Unix Printing System) és un sistema que té una depenència amb la xarxa (After=network.target), s’inicia amb el comandament /usr/sbin/cupsd -l i es configura per iniciar-se automàticament quan s’arrenca el sistema (WantedBy=printer.target). Printer.target és un target que agrupa serveis relacionats amb la impressió. Cups.socket i cups.path són altres unitats que també s’inicien quan s’inicia el servei CUPS ja que estan lligades a aquest servei. El tipus de servei és notify, el qual indica que el servei enviarà una notificació a systemd quan estigui llest.",
    "crumbs": [
      "Diapositives",
      "Unitat 02 · Arrencada del sistema (Part 3)"
    ]
  },
  {
    "objectID": "slides/02-booting-part3.html#dependències-entre-unitats-i",
    "href": "slides/02-booting-part3.html#dependències-entre-unitats-i",
    "title": "Arrencada del sistema (Part 3)",
    "section": "Dependències entre unitats (I)",
    "text": "Dependències entre unitats (I)\nLes unitats són objectes gestionats per systemd. Les dependències són associacions entre elles. Cada tipus d’unitat té algunes dependències per defecte (a menys que s’especifiqui el contrari).\nRelacionals\n\nRequires: Indica que una unitat depèn d’una altra unitat per a la seva activació. Si la unitat requerida no està activa, la unitat que la requereix no s’activarà.\nWants: Similar a Requires, però no és tan estricte. Si la unitat requerida no està activa, la unitat que la vol no es bloquejarà.\nBindsTo: Similar a Requires, però si la unitat requerida es deté, la unitat que la vincula també es detindrà.\nPartOf: Indica que una unitat és part d’una altra unitat. Si la unitat pare es deté, la unitat fill també es detindrà.\nConflicts: Indica que dues unitats no poden estar actives al mateix temps. Si una unitat s’activa, l’altra es detindrà automàticament.",
    "crumbs": [
      "Diapositives",
      "Unitat 02 · Arrencada del sistema (Part 3)"
    ]
  },
  {
    "objectID": "slides/02-booting-part3.html#dependències-entre-unitats-ii",
    "href": "slides/02-booting-part3.html#dependències-entre-unitats-ii",
    "title": "Arrencada del sistema (Part 3)",
    "section": "Dependències entre unitats (II)",
    "text": "Dependències entre unitats (II)\nOrdenació\n\nAfter: Indica que una unitat s’ha d’iniciar després d’una altra unitat. No crea una dependència estricta, només defineix l’ordre d’inici.\nBefore: Indica que una unitat s’ha d’iniciar abans d’una altra unitat. No crea una dependència estricta, només defineix l’ordre d’inici.",
    "crumbs": [
      "Diapositives",
      "Unitat 02 · Arrencada del sistema (Part 3)"
    ]
  },
  {
    "objectID": "slides/02-booting-part3.html#transaccions-a-systemd-i",
    "href": "slides/02-booting-part3.html#transaccions-a-systemd-i",
    "title": "Arrencada del sistema (Part 3)",
    "section": "Transaccions a systemd (I)",
    "text": "Transaccions a systemd (I)\nCada vegada que l’usuari o un servei sol·licita una acció (per exemple, iniciar o aturar un servei), es crea una transacció que gestiona l’execució ordenada de les unitats afectades.\n\nCreació de feines (jobs)\n\nEs crea una feina per a la unitat sol·licitada.\n\nS’afegeixen recursivament les feines corresponents a totes les dependències de la unitat.\n\nMinimització de la transacció\n\nEliminar feines duplicades o redundants.\n\nEliminar feines que no estiguin referenciades per cap altre job (ancoratge).\n\nResolució de cicles de dependències\n\nDetectar loops en el gràfic de dependències.\n\nTrencar-los eliminant feines problemàtiques per evitar deadlocks.",
    "crumbs": [
      "Diapositives",
      "Unitat 02 · Arrencada del sistema (Part 3)"
    ]
  },
  {
    "objectID": "slides/02-booting-part3.html#transaccions-a-systemd-i-1",
    "href": "slides/02-booting-part3.html#transaccions-a-systemd-i-1",
    "title": "Arrencada del sistema (Part 3)",
    "section": "Transaccions a systemd (I)",
    "text": "Transaccions a systemd (I)\n\nFusió i optimització de feines\n\nFusionar feines similars per reduir el nombre d’operacions.\n\nPrioritzar feines ja existents a la cua.\n\nEnviament i execució\n\nAfegir les feines a la cua de jobs de systemd.\n\nExecutar les feines segons la dependència i l’ordre optimitzat.\n\n\n\nGaranteix que les unitats es gestionin de manera atòmica i ordenada, permetent a systemd paral·lelitzar serveis mentre respecta les dependències.\n\n\n\nLes transaccions garanteixen que les unitats es gestionin de manera atòmica i ordenada.\n\nAixò permet a systemd paral·lelitzar serveis mentre respecta les dependències.\n\nCadascuna de les feines conté informació sobre la unitat, la seva acció (start, stop, reload) i les condicions d’execució.",
    "crumbs": [
      "Diapositives",
      "Unitat 02 · Arrencada del sistema (Part 3)"
    ]
  },
  {
    "objectID": "slides/02-booting-part3.html#systemctl-i",
    "href": "slides/02-booting-part3.html#systemctl-i",
    "title": "Arrencada del sistema (Part 3)",
    "section": "systemctl (I)",
    "text": "systemctl (I)\nLa comanda systemctl és l’eina principal per interactuar amb systemd i gestionar els serveis i unitats del sistema. Algunes de les operacions més comunes inclouen:\n\n\n\n\n\n\n\nComanda\nDescripció\n\n\n\n\nsystemctl start &lt;unit&gt;\nInicia una unitat (servei, socket, etc.).\n\n\nsystemctl stop &lt;unit&gt;\nAtura una unitat.\n\n\nsystemctl restart &lt;unit&gt;\nReinicia una unitat.\n\n\nsystemctl status &lt;unit&gt;\nMostra l’estat actual d’una unitat.\n\n\nsystemctl enable &lt;unit&gt;\nHabilita una unitat perquè s’iniciï automàticament en arrencar el sistema.\n\n\nsystemctl disable &lt;unit&gt;\nDeshabilita una unitat perquè no s’iniciï automàticament.\n\n\nsystemctl is-active &lt;unit&gt;\nComprova si una unitat està activa.\n\n\nsystemctl is-enabled &lt;unit&gt;\nComprova si una unitat està habilitada per arrencar automàticament.",
    "crumbs": [
      "Diapositives",
      "Unitat 02 · Arrencada del sistema (Part 3)"
    ]
  },
  {
    "objectID": "slides/02-booting-part3.html#systemctl-ii",
    "href": "slides/02-booting-part3.html#systemctl-ii",
    "title": "Arrencada del sistema (Part 3)",
    "section": "systemctl (II)",
    "text": "systemctl (II)\n\n\n\n\n\n\n\nComanda\nDescripció\n\n\n\n\nsystemctl list-units\nLlista totes les unitats carregades actualment.\n\n\nsystemctl list-unit-files\nLlista tots els fitxers d’unitats disponibles.\n\n\nsystemctl list-dependencies &lt;SERVICE&gt;\nMostra les dependències d’una unitat.\n\n\nsystemctl list-jobs\nMostra les feines pendents i en execució.",
    "crumbs": [
      "Diapositives",
      "Unitat 02 · Arrencada del sistema (Part 3)"
    ]
  },
  {
    "objectID": "slides/02-booting-part3.html#unitat-install",
    "href": "slides/02-booting-part3.html#unitat-install",
    "title": "Arrencada del sistema (Part 3)",
    "section": "Unitat [INSTALL]",
    "text": "Unitat [INSTALL]\n[Install]\nWantedBy=multi-user.target\nAlso=sysstat-collect.timer\nAlso=sysstat-summary.timer\nAlias=monitoring.service\n\nLa secció [Install] defineix com s’instal·la i s’inicia una unitat.\nWantedBy=multi-user.target indica que aquesta unitat s’ha d’iniciar quan s’arrenca el sistema en mode multiusuari (runlevel 3).\nAlso= permet associar altres unitats que s’han d’iniciar juntament amb aquesta.\nAlias= crea un nom alternatiu per a la unitat, facilitant la seva referència.\n\n\nEn aquest cas, la unitat s’iniciarà automàticament en arrencar el sistema en mode multiusuari, i també s’iniciaran els temporitzadors sysstat-collect.timer i sysstat-summary.timer. A més, es pot referenciar aquesta unitat amb el nom alternatiu monitoring.service.",
    "crumbs": [
      "Diapositives",
      "Unitat 02 · Arrencada del sistema (Part 3)"
    ]
  },
  {
    "objectID": "slides/02-booting-part3.html#opcions-service-i",
    "href": "slides/02-booting-part3.html#opcions-service-i",
    "title": "Arrencada del sistema (Part 3)",
    "section": "Opcions [Service] (I)",
    "text": "Opcions [Service] (I)\n\n\n\n\n\n\n\nOpció\nDescripció\n\n\n\n\nType=\nDefineix el tipus de servei (simple, forking, oneshot, notify, idle).\n\n\nExecStart=\nComanda que s’executa per iniciar el servei.\n\n\nExecStop=\nComanda que s’executa per aturar el servei.\n\n\nExecReload=\nComanda que s’executa per recarregar la configuració del servei.\n\n\nRemainAfterExit=\nIndica si el servei es manté actiu després de finalitzar.\n\n\nRestart=\nDefineix si el servei s’ha de reiniciar en cas de fallada.\n\n\nUser=\nDefineix l’usuari amb el qual s’executa el servei.\n\n\nGroup=\nDefineix el grup amb el qual s’executa el servei.",
    "crumbs": [
      "Diapositives",
      "Unitat 02 · Arrencada del sistema (Part 3)"
    ]
  },
  {
    "objectID": "slides/02-booting-part3.html#opcions-service-ii",
    "href": "slides/02-booting-part3.html#opcions-service-ii",
    "title": "Arrencada del sistema (Part 3)",
    "section": "Opcions [Service] (II)",
    "text": "Opcions [Service] (II)\n\n\n\n\n\n\n\nOpció\nDescripció\n\n\n\n\nEnvironment=\nDefineix variables d’entorn per al servei.\n\n\nWorkingDirectory=\nDefineix el directori de treball del servei.\n\n\nPIDFile=\nEspecifica el fitxer que conté el PID del servei.\n\n\nTimeoutStartSec=\nTemps d’espera per a l’inici del servei.\n\n\nTimeoutStopSec=\nTemps d’espera per a l’aturada del servei.\n\n\nStandardOutput=\nDefineix on s’envia la sortida estàndard del servei.\n\n\nStandardError=\nDefineix on s’envia l’error",
    "crumbs": [
      "Diapositives",
      "Unitat 02 · Arrencada del sistema (Part 3)"
    ]
  },
  {
    "objectID": "slides/02-booting-part3.html#tipus-de-serveis-i",
    "href": "slides/02-booting-part3.html#tipus-de-serveis-i",
    "title": "Arrencada del sistema (Part 3)",
    "section": "Tipus de serveis (I)",
    "text": "Tipus de serveis (I)\n\nSimple: Per defecte, aquest servei s’inicia immediatament després del fork(). No espera cap senyal de que el servei estigui llest.\nForking: Aquest tipus de servei és per a processos que es bifurquen (fork) i es converteixen en dimonis. El servei es considera actiu després que el procés pare finalitzi.\nOneshot: Aquest tipus és per a serveis que realitzen una tasca única i després finalitzen. Systemd espera que el procés acabi abans de considerar el servei com a actiu.\nNotify: Aquest tipus de servei utilitza el mecanisme de notificació de systemd per informar quan està llest. El servei ha d’enviar una notificació explícita a systemd.\nDBus: Aquest tipus de servei s’utilitza per a serveis que es comuniquen a través de DBus. El servei es considera actiu quan el nom del bus apareix al bus de sistema.\nIdle: Aquest tipus de servei s’inicia només quan el sistema està inactiu, és a dir, quan no hi ha altres feines pendents.",
    "crumbs": [
      "Diapositives",
      "Unitat 02 · Arrencada del sistema (Part 3)"
    ]
  },
  {
    "objectID": "slides/02-booting-part3.html#efecte-del-tipus-de-servei-al-runtime",
    "href": "slides/02-booting-part3.html#efecte-del-tipus-de-servei-al-runtime",
    "title": "Arrencada del sistema (Part 3)",
    "section": "Efecte del tipus de servei al runtime",
    "text": "Efecte del tipus de servei al runtime",
    "crumbs": [
      "Diapositives",
      "Unitat 02 · Arrencada del sistema (Part 3)"
    ]
  },
  {
    "objectID": "slides/02-booting-part3.html#script-de-lusuari",
    "href": "slides/02-booting-part3.html#script-de-lusuari",
    "title": "Arrencada del sistema (Part 3)",
    "section": "Script de l’usuari",
    "text": "Script de l’usuari\nUn cop s’han carregat tots els serveis i el sistema està en marxa, els usuaris poden iniciar sessió al sistema. Els scripts de l’usuari es troben a la carpeta /etc/profile.d/ i s’executen quan l’usuari inicia sessió.\n\n/etc/profile: Conté la configuració global per a tots els usuaris. S’executa en iniciar sessió en un entorn de shell.\n/etc/bashrc: Proporciona configuració per a shells interactius. S’executa cada vegada que s’inicia una nova sessió de shell.\n~/.bashrc: Fitxer de configuració específic per a l’usuari, que s’executa en iniciar una sessió de shell interactiu.\n~/.bash_profile: S’executa quan l’usuari inicia sessió a la terminal. Normalment, s’utilitza per configurar l’entorn de l’usuari, incloent la configuració de l’PATH.\n~/.bash_logout: S’executa quan l’usuari tanca la sessió de shell. Aquí es poden incloure comandes de neteja o tancament.\n~/.bash_history: Fitxer que emmagatzema l’històric de les comandes executades per l’usuari en la sessió de shell.",
    "crumbs": [
      "Diapositives",
      "Unitat 02 · Arrencada del sistema (Part 3)"
    ]
  },
  {
    "objectID": "slides/02-booting-part3.html#exercicis-propostas",
    "href": "slides/02-booting-part3.html#exercicis-propostas",
    "title": "Arrencada del sistema (Part 3)",
    "section": "Exercicis Propostas",
    "text": "Exercicis Propostas\n\nAnàlisi del procés d’arrencada amb systemd\nServei de Còpia de Seguretat Automàtica amb systemd\nDiscussió: Secure Boot és realment segur?: Cerca notícies recents sobre Secure Boot i comparteix-les al fòrum del curs. Debatiu sobre avantatges, desavantatges, vulnerabilitats conegudes i experiències personals.\nPràctica 01: Snapshots i restauració amb systemd i initramfs",
    "crumbs": [
      "Diapositives",
      "Unitat 02 · Arrencada del sistema (Part 3)"
    ]
  },
  {
    "objectID": "slides/02-booting-part3.html#thats-all",
    "href": "slides/02-booting-part3.html#thats-all",
    "title": "Arrencada del sistema (Part 3)",
    "section": "That’s all",
    "text": "That’s all\n\n\n\n\n\n\n\n\n\nTake Home Message\n\n\nEl procés d’arrencada és un procés complex. Els administradors de sistemes han de conèixer aquest procés per poder gestionar i solucionar problemes durant l’arrencada del sistema i garantir un sistema segur, estable i eficient.",
    "crumbs": [
      "Diapositives",
      "Unitat 02 · Arrencada del sistema (Part 3)"
    ]
  },
  {
    "objectID": "slides/03-filesystem-part1.html#necessitat-dun-sistema-de-fitxers-i",
    "href": "slides/03-filesystem-part1.html#necessitat-dun-sistema-de-fitxers-i",
    "title": "Sistema de fitxers (I)",
    "section": "Necessitat d’un Sistema de Fitxers (I)",
    "text": "Necessitat d’un Sistema de Fitxers (I)\nLa implementació d’un Sistema de Fitxers (FS) és essencial per a l’organització, emmagatzematge i recuperació eficient de la informació en qualsevol sistema operatiu modern.\n\n\n\n\n\n\n\nObservació\n\n\nEn els sistemes operatius moderns (UNIX-like), el seu rol s’estén molt més enllà de la gestió de dades persistents al disc, abracant una filosofia fonamental.\n\n\n\n\n\nEverything is a File",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Sistemes de fitxers (Part 1)"
    ]
  },
  {
    "objectID": "slides/03-filesystem-part1.html#necessitat-dun-sistema-de-fitxers-ii",
    "href": "slides/03-filesystem-part1.html#necessitat-dun-sistema-de-fitxers-ii",
    "title": "Sistema de fitxers (I)",
    "section": "Necessitat d’un Sistema de Fitxers (II)",
    "text": "Necessitat d’un Sistema de Fitxers (II)\n\n\n\n\n\n\n\n\nTipus de Recurs\nExemple de Path\nSistema de Fitxers\n\n\n\n\nProcés/Estat del Kernel\n/proc/PID (p. ex., /proc/1234/status)\nprocfs (Memòria, no disc)\n\n\nDispositiu de Blocs\n/dev/sda1\ndevfs o udev\n\n\nPunts de Configuració\n/etc/hosts, /usr/bin/comando\nFS persistent (Ext4, XFS)\n\n\nDades d’Usuari\n/home/username/documents\nFS persistent\n\n\nXarxa\n/dev/tcp/80 (en certs entorns, e.g., Plan 9)\nÚs de Sockets com a File Descriptors\n\n\n\n\n\n\n\n\n\n\nAvantatge\n\n\nLa implementació d’un sistema de fitxers permet unificar l’accés a recursos heterogenis. El kernel pot tractar una E/S a /dev/sda1 (blocs físics) i una E/S a /proc/cpuinfo (informació virtual) utilitzant la mateixa API. API.",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Sistemes de fitxers (Part 1)"
    ]
  },
  {
    "objectID": "slides/03-filesystem-part1.html#dispositius-i-device-files",
    "href": "slides/03-filesystem-part1.html#dispositius-i-device-files",
    "title": "Sistema de fitxers (I)",
    "section": "Dispositius i Device Files",
    "text": "Dispositius i Device Files\nUn Fitxer de Dispositiu (Device File o Node) és un nom assignat a un dispositiu d’E/S (Entrada/Sortida), ja sigui físic (disc, targeta de so) o lògic (port de xarxa, terminal).\n\n\n\n\n\n\n\n\nTipus de Dispositiu\nExemples Comuns\nCaracterística\n\n\n\n\nBlocs (Block Devices)\n/dev/sda (Disc sencer), /dev/sdb1 (Partició), /dev/md0 (RAID)\nTransfereixen dades en blocs de mida fixa. Són cachejables i permeten accés aleatori.\n\n\nCaràcters (Character Devices)\n/dev/ttyX (Terminals), /dev/lp0 (Port Paral·lel), /dev/input/mouse0\nTransfereixen dades seqüencialment caràcter a caràcter. No tenen caching de blocs.\n\n\n\nEls drivers és el conjunt de rutines del kernel que defineix com s’ha de dur a terme la comunicació específica amb el Hardware mitjançant interrupcions, accés directe a memòria (DMA) i E/S programada. Sense el driver, el fitxer a /dev seria inútil.",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Sistemes de fitxers (Part 1)"
    ]
  },
  {
    "objectID": "slides/03-filesystem-part1.html#virtual-filesystem-switch-vfs",
    "href": "slides/03-filesystem-part1.html#virtual-filesystem-switch-vfs",
    "title": "Sistema de fitxers (I)",
    "section": "Virtual Filesystem Switch (VFS)",
    "text": "Virtual Filesystem Switch (VFS)\nUn Sistema de Fitxers (FS) és la capa lògica fonamental que gestiona l’accés i l’organització dels objectes (fitxers i directoris) sobre un dispositiu d’emmagatzematge.\n\n\n\n\n\n\n\nMúltiples FS actius\n\n\nÉs habitual que un sistema operatiu gestioni simultàniament diverses instàncies de sistemes de fitxers diferents:\n\nExt4 per a dades d’usuari (/home)\nBtrfs per a backups automàtics\ntmpfs per a fitxers temporals (/tmp)\nprocfs per a informació del kernel (/proc)\n\nCadascun muntat en un punt d’accés lògic diferent.",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Sistemes de fitxers (Part 1)"
    ]
  },
  {
    "objectID": "slides/03-filesystem-part1.html#abstraccions-comunes-del-vfs",
    "href": "slides/03-filesystem-part1.html#abstraccions-comunes-del-vfs",
    "title": "Sistema de fitxers (I)",
    "section": "Abstraccions Comunes del VFS",
    "text": "Abstraccions Comunes del VFS\nTot i les diferències estructurals a nivell de disc, el VFS (Virtual Filesystem Switch) del kernel utilitza abstraccions uniformes per oferir una interfície consistent als processos.\n\n\n\n\n\n\n\n\n\nAbstracció\nUbicació\nFunció Tècnica\nPersistència\n\n\n\n\nSuperbloc\nDisc + Memòria\nConté metadata global del FS: tipus, mida, estat, punters clau\nPersistent\n\n\nInode\nDisc + Memòria\nMetadata del fitxer: permisos, timestamps, punters a blocs de dades\nPersistent\n\n\nDentry\nNomés Memòria\nEntrada de Directori: cacheja nom del fitxer ↔︎ inode\nTemporal\n\n\nFile Object\nNomés Memòria\nRepresenta un fitxer obert per un procés (file descriptors)\nTemporal\n\n\n\nPermet que un programa pugui treballar amb fitxers Ext4, XFS, NTFS o FAT32 sense modificar ni una sola línia de codi.",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Sistemes de fitxers (Part 1)"
    ]
  },
  {
    "objectID": "slides/03-filesystem-part1.html#jerarquia-lògica-de-les-abstraccions",
    "href": "slides/03-filesystem-part1.html#jerarquia-lògica-de-les-abstraccions",
    "title": "Sistema de fitxers (I)",
    "section": "Jerarquia Lògica de les Abstraccions",
    "text": "Jerarquia Lògica de les Abstraccions\nPer entendre com el kernel mapeja un nom de fitxer a les dades, visualitzem la interacció entre les estructures in-memory i on-disk.\n\n\n\n\n\nclassDiagram\n    direction LR\n    \n    class Superbloc {\n        &lt;&lt;On-Disk i In-Memory&gt;&gt;\n        + Tipus FS (Ext4, XFS)\n        + Mida del Volum\n        + Punter a llistes d'Inodes Lliures\n    }\n\n    class Inode {\n        &lt;&lt;On-Disk i In-Memory&gt;&gt;\n        + Num Inode Únic\n        + Pointers a Blocs de Dades\n        + Permisos/ACLs\n        + UID/GID, Timestamps\n    }\n\n    class Dentry {\n        &lt;&lt;In-Memory Cache&gt;&gt;\n        + Nom del Fitxer/Directori\n        + Punter a Inode\n        + Punter al Dentry Pare\n    }\n\n    class FileObject {\n        &lt;&lt;In-Memory&gt;&gt;\n        + File Descriptor FD\n        + Offset de Lectura/Escriptura Actual\n        + Punter a Dentry (Path)\n    }\n\n    Superbloc \"1\" --&gt; \"*\" Inode : Gestiona\n    Dentry \"1\" --&gt; \"1\" Inode : Caching · Nom -&gt; Metadata\n    FileObject \"1\" --&gt; \"1\" Dentry : Resolució de Path\n    Inode \"1\" --&gt; \"*\" DataBlocks : Adreçament\n    \n    %% Colors per a claredat tècnica\n    classDef memory fill:#eaf7ff,stroke:#007bff\n    classDef disk fill:#f9f5dd,stroke:#c4aa18\n    class Dentry\n    FileObject memory\n    class Inode\n    Superbloc disk\n\n\n\n\n\n\n\n\n\n\n\n\n\nImpacte del Dentry\n\n\nUna Dentry Cache saturada o poc eficient pot degradar significativament el rendiment del sistema (I/O latency), ja que el kernel es veu forçat a re-llegir l’estructura de directoris directament del disc.\n\n\n\n\n\n\nFileObject: Un procés obre un fitxer, creant un FileObject amb un File Descriptor.\nDentry (Cache): El FileObject resol el camí a través d’una cadena de Dentries (des de la muntura fins al fitxer final). El Dentry proporciona l’associació Nom → Inode.\nInode: El número d’Inode permet al VFS carregar les metadades on-disk a memòria. Aquesta estructura conté els punters directes i indirectes als blocs de dades.",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Sistemes de fitxers (Part 1)"
    ]
  },
  {
    "objectID": "slides/03-filesystem-part1.html#relacions-in-memory-del-vfs",
    "href": "slides/03-filesystem-part1.html#relacions-in-memory-del-vfs",
    "title": "Sistema de fitxers (I)",
    "section": "Relacions In-Memory del VFS",
    "text": "Relacions In-Memory del VFS\n\nMúltiples descriptors de fitxer poden apuntar al mateix fitxer (dup()).\nMúltiples abstraccions de fitxer poden apuntar a la mateixa Dentry (obrim el mateix path diverses vegades).\nMúltiples Dentries poden apuntar al mateix Inode (Hard Links).",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Sistemes de fitxers (Part 1)"
    ]
  },
  {
    "objectID": "slides/03-filesystem-part1.html#el-superbloc",
    "href": "slides/03-filesystem-part1.html#el-superbloc",
    "title": "Sistema de fitxers (I)",
    "section": "El Superbloc",
    "text": "El Superbloc\nEl Superbloc és el punt de referència absolut de qualsevol Sistema de Fitxers (FS). Sense aquesta estructura, el kernel no pot ni tan sols intentar muntar el volum.\n\n\n\n\n\n\n\nAvís\n\n\nSi el Superbloc es corromp (per un error de disc o d’E/S), el sistema de fitxers esdevé inaccessible fins que es restaura una de les seves còpies de seguretat (backup copies).\n\n\n\n\nPer aquest motiu, els FS moderns mantenen múltiples còpies del superbloc distribuïdes pel volum.",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Sistemes de fitxers (Part 1)"
    ]
  },
  {
    "objectID": "slides/03-filesystem-part1.html#organització-física-del-superbloc",
    "href": "slides/03-filesystem-part1.html#organització-física-del-superbloc",
    "title": "Sistema de fitxers (I)",
    "section": "Organització Física del Superbloc",
    "text": "Organització Física del Superbloc\n\n\nEl diagrama mostra que el superbloc es troba típicament a l’inici del sistema de fitxers i que hi ha diversos blocs utilitzats amb diferents propòsits: alguns per emmagatzemar dentries, alguns per emmagatzemar inodes i alguns per emmagatzemar blocs de dades d’usuari. També hi ha blocs utilitzats per gestionar els blocs lliures disponibles (p. ex., mapes de bits per als sistemes de fitxers simples).",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Sistemes de fitxers (Part 1)"
    ]
  },
  {
    "objectID": "slides/03-filesystem-part1.html#abstraccions-del-superbloc",
    "href": "slides/03-filesystem-part1.html#abstraccions-del-superbloc",
    "title": "Sistema de fitxers (I)",
    "section": "Abstraccions del Superbloc",
    "text": "Abstraccions del Superbloc\n\n\n\n\n\n\n\n\nComponent\nFunció\nUbicació\n\n\n\n\nSuperbloc\nConté la metadata global del FS: tipus, mida, estat, i punters clau.\nInici del FS (i còpies de seguretat).\n\n\nIMAP (Inode Map)\nBitmap per a l’assignació i desassignació d’Inodes. Indica quins Inodes estan lliures o en ús dins de la IZONE.\nBloc(s) assignat(s) pel Superbloc.\n\n\nDMAP (Data Map)\nBitmap per a l’assignació i desassignació de Blocs de Dades. Indica quins blocs de la DZONE estan lliures o en ús.\nBloc(s) assignat(s) pel Superbloc.\n\n\nIZONE\nÀrea que conté les estructures d’Inode dels fitxers.\nDesprés dels mapes.\n\n\nDZONE\nÀrea que conté les dades d’usuari (el contingut real dels fitxers).\nDesprés de la IZONE.",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Sistemes de fitxers (Part 1)"
    ]
  },
  {
    "objectID": "slides/03-filesystem-part1.html#estructura-i-implementació-del-superbloc",
    "href": "slides/03-filesystem-part1.html#estructura-i-implementació-del-superbloc",
    "title": "Sistema de fitxers (I)",
    "section": "Estructura i Implementació del Superbloc",
    "text": "Estructura i Implementació del Superbloc\nEl Superbloc no només s’autodefineix, sinó que defineix l’arquitectura de tota la partició:\n\nfs_type: El tipus de FS (p. ex., EXT4_MAGIC).\ns_blocks_count: El nombre total de blocs al FS.\ns_log_block_size: Defineix la mida del bloc lògic (p. ex., 1K, 4K). Tota la I/O es fa en aquesta unitat.\nPunters a Bitmaps: Adreces del primer bloc de l’IMAP i el DMAP.\nEstat del FS: Indica si el FS va ser desmuntat netament o si va patir un crash (s_state - important per al fsck).",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Sistemes de fitxers (Part 1)"
    ]
  },
  {
    "objectID": "slides/03-filesystem-part1.html#mapes-de-bits-bitmaps",
    "href": "slides/03-filesystem-part1.html#mapes-de-bits-bitmaps",
    "title": "Sistema de fitxers (I)",
    "section": "Mapes de Bits (Bitmaps)",
    "text": "Mapes de Bits (Bitmaps)\nEls mapes de bits són crucials per a l’eficiència en l’assignació:\n\nIMAP (Inode Bitmap): Cada bit representa l’estat d’un únic Inode a la IZONE. 1 = En ús, 0 = Lliure.\nDMAP (Data Bitmap): Cada bit representa l’estat d’un únic bloc a la DZONE. 1 = Ocupat per dades, 0 = Lliure per assignació.\n\n\n\n\n\n\n\nOptimització (Caching)\n\n\nQuan el FS es munta, el kernel carrega el Superbloc i, almenys parcialment, els mapes IMAP i DMAP a la memòria. Això permet que les noves assignacions de fitxers i blocs siguin extremadament ràpides sense requerir una E/S de disc constant.\n\n\n\n\n\n\n\n\n\n\nFS Grans\n\n\nEs carreguen parcialment i a demanda per no gastar massa memòria en FS grans.",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Sistemes de fitxers (Part 1)"
    ]
  },
  {
    "objectID": "slides/03-filesystem-part1.html#mapping-crides-de-sistema-vfs",
    "href": "slides/03-filesystem-part1.html#mapping-crides-de-sistema-vfs",
    "title": "Sistema de fitxers (I)",
    "section": "Mapping: Crides de Sistema → VFS",
    "text": "Mapping: Crides de Sistema → VFS\n\n\n\n\n\n\n\n\n\n\nCrida al Sistema\nOperació VFS\nDescripció\n\n\n\n\nmount()\nvfs_mount()\nMuntar un FS.\n\n\nopen()\nvfs_open()\nObrir un fitxer (i obtenir un FD).\n\n\nstat() / fstat()\nvfs_stat() / vfs_fstat()\nConsultar atributs del fitxer.\n\n\nread() / write()\nvfs_read() / vfs_write()\nLlegir o escriure dades.\n\n\ncreate() / delete()\nvfs_create() / vfs_unlink()\nCrear i eliminar fitxers.\n\n\nclose()\nvfs_close()\nTancar un fitxer\n\n\n\n\nEl VFS és l’abstracció de Linux que permet gestionar múltiples tipus de FS (Ext4, XFS, NTFS) de manera transparent.\n\n\n\n\n\ngraph TD\n    A[Crida al Sistema open, read] --&gt; B{VFS};\n    B --&gt;|Operació abstracta| C1[Driver FS Específic Ext4];\n    B --&gt;|Operació abstracta| C2[Driver FS Específic XFS];\n    C1 --&gt; D[Subsistema d'Emmagatzematge E/S];\n    C2 --&gt; D;\n    \n    style B fill:#eaf7ff,stroke:#007bff\n    style C1 fill:#f9f5dd,stroke:#c4aa18\n    style C2 fill:#f9f5dd,stroke:#c4aa18",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Sistemes de fitxers (Part 1)"
    ]
  },
  {
    "objectID": "slides/03-filesystem-part1.html#montatge-dun-fs",
    "href": "slides/03-filesystem-part1.html#montatge-dun-fs",
    "title": "Sistema de fitxers (I)",
    "section": "Montatge d’un FS",
    "text": "Montatge d’un FS\n# Sintaxi: mount -t &lt;fs_type&gt; &lt;device&gt; &lt;mount_point&gt;\nmount -t ext4 /dev/nvme0n1p2 /home\nmount -t btrfs /dev/sdb1 /backup\nmount -t tmpfs -o size=1G tmpfs /tmp/ramdisk\n\n\n\n\n\n\n\n\nPas\nDescripció\nImplicació\n\n\n\n\n1. Entrada/Sortida\nInput: Dispositiu de blocs (Partició). Output: Dentry arrel del FS.\n\n\n\n2. Check Device\nValidació de l’estructura inicial del FS.\n\n\n\n3. Llegir Superbloc\nDeterminar paràmetres (mida de bloc, magic number). Carregar el Superbloc a memòria.\nCrític: Estableix el context global.\n\n\n4. Crear Inode i Dentry\nLocalitzar el Root Inode (e.g., inode 2 a Ext4) i crear l’estructura Dentry arrel a la memòria.\nInici de la navegació lògica.",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Sistemes de fitxers (Part 1)"
    ]
  },
  {
    "objectID": "slides/03-filesystem-part1.html#obertura-dun-fitxer",
    "href": "slides/03-filesystem-part1.html#obertura-dun-fitxer",
    "title": "Sistema de fitxers (I)",
    "section": "Obertura d’un Fitxer",
    "text": "Obertura d’un Fitxer\n\n\n\n\n\nsequenceDiagram \n    participant P as Procés\n    participant VFS as VFS (Kernel)\n    participant FS as Driver de FS (read_inode)\n\n    P-&gt;&gt;VFS: open -&gt; /a/b/fitxer.txt \n    VFS-&gt;&gt;VFS: 1. Per cada component a, b, fitxer.txt:\n    VFS-&gt;&gt;VFS: Resoldre Dentry Pare (Cache)\n    VFS-&gt;&gt;FS: 2. Carregar Inode si no està en cache (via Num. Inode)\n    VFS-&gt;&gt;VFS: 3. Final: Crear nou **FILE OBJECT**\n    VFS-&gt;&gt;P: 4. Assignar **File Descriptor** (FD)",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Sistemes de fitxers (Part 1)"
    ]
  },
  {
    "objectID": "slides/03-filesystem-part1.html#consultar-atributs",
    "href": "slides/03-filesystem-part1.html#consultar-atributs",
    "title": "Sistema de fitxers (I)",
    "section": "Consultar Atributs",
    "text": "Consultar Atributs\n\n\n\n\n\nsequenceDiagram\n    participant P as Procés\n    participant VFS as VFS (Kernel)\n    participant FS as Driver de FS (read_inode)\n    P-&gt;&gt;VFS: stat -&gt; fitxer.txt o fstat -&gt; FD\n    VFS-&gt;&gt;VFS: 1. Accés a l'Inode via FD\n    VFS-&gt;&gt;FS: 2. Si no està en cache, llegir Inode del disc\n    FS--&gt;&gt;VFS: 3. Retornar Atributs\n    VFS--&gt;&gt;P: 4. Retornar Atributs UID, GID, Permisos, Mida, Timestamps",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Sistemes de fitxers (Part 1)"
    ]
  },
  {
    "objectID": "slides/03-filesystem-part1.html#operacions-de-lectura",
    "href": "slides/03-filesystem-part1.html#operacions-de-lectura",
    "title": "Sistema de fitxers (I)",
    "section": "Operacions de Lectura",
    "text": "Operacions de Lectura\n\n\n\n\n\nsequenceDiagram\n    participant P as Procés\n    participant VFS as VFS \n    participant FS as Driver de FS · read\n    P-&gt;&gt;VFS: read -&gt; FD, buf, len\n    VFS-&gt;&gt;VFS: 1. Validar FD i permisos\n    VFS-&gt;&gt;VFS: 2. Calcular blocs a llegir -&gt; offset, len\n    VFS-&gt;&gt;FS: 3. Llegir dades file-&gt;dentry-&gt;inode-&gt;data blocks\n    FS--&gt;&gt;VFS: 4. Retornar dades a VFS\n    VFS--&gt;&gt;P: 5. Copiar dades a l'espai d'usuari",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Sistemes de fitxers (Part 1)"
    ]
  },
  {
    "objectID": "slides/03-filesystem-part1.html#operacions-descriptura",
    "href": "slides/03-filesystem-part1.html#operacions-descriptura",
    "title": "Sistema de fitxers (I)",
    "section": "Operacions d’Escriptura",
    "text": "Operacions d’Escriptura\n\n\n\n\n\nsequenceDiagram\n    participant P as Procés\n    participant VFS as VFS\n    participant PC as Page Cache\n    participant FS as Driver FS\n    participant J as Journal\n    participant BD as Block Device\n\n    P-&gt;&gt;VFS: write -&gt; fd=5, buffer, 4096\n    VFS-&gt;&gt;VFS: Validar FD i permisos d'escriptura\n    VFS-&gt;&gt;VFS: Calcular nous blocs necessaris\n    \n    alt Fitxer necessita créixer\n        VFS-&gt;&gt;FS: Assignar nous blocs de dades\n        FS-&gt;&gt;FS: Actualizar bitmaps i inode\n        FS-&gt;&gt;J: Registrar transacció al journal\n    end\n    \n    VFS-&gt;&gt;PC: Escriure dades a la page cache · dirty pages\n    VFS--&gt;&gt;P: Retornar bytes escrits \n    \n    Note over PC,BD: Writeback asíncron \n    PC-&gt;&gt;BD: Flush dirty pages al disc\n    J-&gt;&gt;BD: Commit transacció journal",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Sistemes de fitxers (Part 1)"
    ]
  },
  {
    "objectID": "slides/03-filesystem-part1.html#escriptura-asíncrona-i-writeback",
    "href": "slides/03-filesystem-part1.html#escriptura-asíncrona-i-writeback",
    "title": "Sistema de fitxers (I)",
    "section": "Escriptura Asíncrona i Writeback",
    "text": "Escriptura Asíncrona i Writeback\nLa escriptura asíncrona permet que les operacions d’escriptura es realitzin en segon pla, millorant la resposta del sistema. Les dades es desplacen a la page cache i es poden escriure al disc més tard.\n\nDirty Pages: Pàgines a la memòria que han estat modificades però encara no s’han escrit al disc.\nWriteback: Procés de transferir les dirty pages de la memòria al disc.\nJournaling: Mecanisme per assegurar la integritat del FS en cas de fallada durant el writeback.\nFlush: Operació per escriure immediatament les dirty pages al disc.",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Sistemes de fitxers (Part 1)"
    ]
  },
  {
    "objectID": "slides/03-filesystem-part1.html#creació-de-directoris",
    "href": "slides/03-filesystem-part1.html#creació-de-directoris",
    "title": "Sistema de fitxers (I)",
    "section": "Creació de Directoris",
    "text": "Creació de Directoris\n\n\n\n\n\nsequenceDiagram\n    participant P as Procés\n    participant VFS as VFS\n    participant FS as Driver de FS · mkdir\n    P-&gt;&gt;VFS: mkdir -&gt; /a/b/novedirectori\n    VFS-&gt;&gt;VFS: 1. Resoldre Dentry Pare -&gt; /a/b -&gt; Determinar Inode Pare\n    VFS-&gt;&gt;VFS: 2. Llegir blocs de dades del directori pare · Trobar espai per a nova Dentry\n    VFS-&gt;&gt;FS: 4. Crear nou Inode per al directori\n    FS--&gt;&gt;VFS: 5. Retornar Num. Inode\n    VFS-&gt;&gt;VFS: 6. Afegir Dentry al directori par · Escriure els blocs de dades del directori pare modificats\n    VFS--&gt;&gt;P: 8. Retornar èxit o error",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Sistemes de fitxers (Part 1)"
    ]
  },
  {
    "objectID": "slides/03-filesystem-part1.html#eliminació-de-fitxers",
    "href": "slides/03-filesystem-part1.html#eliminació-de-fitxers",
    "title": "Sistema de fitxers (I)",
    "section": "Eliminació de Fitxers",
    "text": "Eliminació de Fitxers\n\n\n\n\n\nsequenceDiagram\n    participant P as Procés\n    participant VFS as VFS\n    participant FS as Driver de FS · unlink\n    P-&gt;&gt;VFS: unlink -&gt; /a/b/fitxer.txt\n    VFS-&gt;&gt;VFS: 1. Resoldre Dentry Pare -&gt; /a/b -&gt; Determinar Inode Pare\n    VFS-&gt;&gt;VFS: 2. Llegir blocs de dades del directori pare · Trobar i esborrar la Dentry\n    VFS-&gt;&gt;VFS: 4. Comprovar enllaços -&gt; Si és l'últim enllaç, desassignar blocs de dades i blocs d'inode\n    VFS-&gt;&gt;FS: 6. Actualitzar metadades al disc\n    FS--&gt;&gt;VFS: 7. Confirmació d'actualització\n    VFS--&gt;&gt;P: 8. Retornar èxit o error",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Sistemes de fitxers (Part 1)"
    ]
  },
  {
    "objectID": "slides/03-filesystem-part1.html#superbloc-i-operacions-dinode",
    "href": "slides/03-filesystem-part1.html#superbloc-i-operacions-dinode",
    "title": "Sistema de fitxers (I)",
    "section": "Superbloc i Operacions d’Inode",
    "text": "Superbloc i Operacions d’Inode\nEl VFS (Virtual Filesystem Switch) estableix dos conjunts d’operacions que el driver de cada Sistema de Fitxers ha d’implementar. Aquests mètodes permeten al kernel interactuar amb les metadades de forma uniforme.\n\n\n\n\n\n\n\n\nOperació\nFunció Tècnica\nPropòsit\n\n\n\n\nfill_super()\nLlegeix l’estat global del FS (total/lliure d’Inodes i Blocs).\nInicialització i muntatge.\n\n\nwrite_super()\nPersisteix les estadístiques i l’estat actualitzat al disc.\nCanvis en l’assignació.\n\n\nput_super()\nAllibera la memòria associada a la instància del FS.\nDesmuntatge (umount).",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Sistemes de fitxers (Part 1)"
    ]
  },
  {
    "objectID": "slides/03-filesystem-part1.html#operacions-de-linode",
    "href": "slides/03-filesystem-part1.html#operacions-de-linode",
    "title": "Sistema de fitxers (I)",
    "section": "Operacions de l’Inode",
    "text": "Operacions de l’Inode\nMalgrat el nom, la majoria d’aquestes operacions tracten amb la gestió de les Dentries i la jerarquia de noms de fitxer (no el contingut de l’Inode en si).\n\nCreació i Cerca: create, lookup, link, unlink.\nDirectori i Enllaços: mkdir, rmdir, symlink, readlink, rename.\n\n\n\n\n\n\n\n\nTipus d’Inode\n\n\nEls drivers de FS treballen amb dos tipus d’Inode:\n\nVFS Inode: Estructura genèrica utilitzada pel kernel.\nFS Inode: Estructura interna del driver (p. ex., la versió Ext4 o XFS).\n\nEl driver és responsable de la conversió entre aquestes dues estructures segons sigui necessari.",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Sistemes de fitxers (Part 1)"
    ]
  },
  {
    "objectID": "slides/03-filesystem-part1.html#cache-dinodes-icache",
    "href": "slides/03-filesystem-part1.html#cache-dinodes-icache",
    "title": "Sistema de fitxers (I)",
    "section": "Cache d’Inodes (Icache)",
    "text": "Cache d’Inodes (Icache)\nAquesta cache emmagatzema les metadades del fitxer a memòria (l’estructura de l’Inode), evitant lectures repetitives a la IZONE del disc.\n\nEstructura: S’indexa mitjançant una Taula Hash (hash table).\nClau Hash: Es genera a partir de la tupla (Superbloc, Número d’Inode).\nPolítica: Els Inodes es mantenen fins que el FS es desmunta, s’elimina el fitxer, o hi ha pressió de memòria (memory pressure).",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Sistemes de fitxers (Part 1)"
    ]
  },
  {
    "objectID": "slides/03-filesystem-part1.html#cache-de-dentries",
    "href": "slides/03-filesystem-part1.html#cache-de-dentries",
    "title": "Sistema de fitxers (I)",
    "section": "Cache de Dentries",
    "text": "Cache de Dentries\nLa Dcache és l’eina més important per a la resolució ràpida de camins (path lookup). Cacheja la relació Nom \\(\\rightarrow\\) Inode.\n\n\n\n\n\n\n\nEstat de la Dentry\nImplicació Tècnica\n\n\n\n\nUsed\nL’objecte està en ús (p. ex., associat a un FILE Objecte). El seu d_inode és vàlid.\n\n\nUnused\nEl d_inode és vàlid, però l’objecte Dentry no està sent utilitzat activament per cap procés.\n\n\nNegative\nL’d_inode no és vàlid. S’utilitza per recordar que un fitxer no existeix o ha estat eliminat, evitant cerques futures innecessàries al disc.\n\n\n\n\n\n\n\n\n\n\nOptimització de la Dentry Cache\n\n\nL’accés a l’Inode cache (per al seu alliberament en condicions de memòria baixa) utilitza l’estat d’ús, basat en el Superbloc i el número d’Inode. La Dentry cache també fa servir taules hash per a cerques ultra-ràpides.",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Sistemes de fitxers (Part 1)"
    ]
  },
  {
    "objectID": "slides/03-filesystem-part1.html#cache-de-pàgines-dades-i-es",
    "href": "slides/03-filesystem-part1.html#cache-de-pàgines-dades-i-es",
    "title": "Sistema de fitxers (I)",
    "section": "Cache de pàgines: Dades i E/S",
    "text": "Cache de pàgines: Dades i E/S\nLa Cache de pàgines és el mecanisme principal del kernel per a la gestió de dades d’E/S, utilitzat per tots els sistemes de fitxers. Emmagatzema els blocs de dades del fitxer a la memòria del sistema,per a la lectura ràpida i per a l’escriptura diferida.\n\n\n\n\n\n\n\nGestió de Memòria\n\n\nLinux reutilitza la memòria lliure com a cache, però l’allibera quan un procés necessita RAM.\n\n\n\n\n\nDades Cachejades: Només dades de fitxers, no metadades de nivell de bloc (block device data).\nMecanismes d’E/S: Suporta operacions read(), write() i mmap() (mapes de memòria).\n\n\n\n\n\n\n\n\nEstructura Interna: Ràdix-Arbre\n\n\nLa Cache de pàgines utilitza una estructura de dades Radix Tree per mapejar de manera eficient els offsets de fitxer a les pàgines de memòria. Això permet accés ràpid a pàgines de dades grans.",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Sistemes de fitxers (Part 1)"
    ]
  },
  {
    "objectID": "slides/03-filesystem-part1.html#fat-file-allocation-table",
    "href": "slides/03-filesystem-part1.html#fat-file-allocation-table",
    "title": "Sistema de fitxers (I)",
    "section": "FAT: File Allocation Table",
    "text": "FAT: File Allocation Table\n\nSistema de fitxers creat el 1977 i popularitzat gràcies a MS-DOS.\nEncara popular avui (FAT32): USB, targetes de memòria, partició d’arrencada EFI.\nFile Allocation Table: Estructura de llista enllaçada que conté informació sobre els blocs ocupats per cada fitxer.\nTambé determina si un bloc està en ús o no.",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Sistemes de fitxers (Part 1)"
    ]
  },
  {
    "objectID": "slides/03-filesystem-part1.html#fat-organització-de-directoris",
    "href": "slides/03-filesystem-part1.html#fat-organització-de-directoris",
    "title": "Sistema de fitxers (I)",
    "section": "FAT: Organització de Directoris",
    "text": "FAT: Organització de Directoris\nEls directoris en FAT són fitxers especials que contenen entrades de 32 bytes per a cada fitxer o subdirectori. Cada entrada inclou: nom, atributs, timestamps, primer clúster i mida del fitxer.\n\n\n\nNom\nIndex\nDir?\nPermisos\n\n\n\n\n.\n2\nSí\nrwx\n\n\nWindows\n3\nSí\nrwx\n\n\nUsers\n4\nSí\nrwx\n\n\npagefile.sys\n5\nNo\nr–\n\n\n\nEl superbloc actua com a punt de referència per a tot el sistema de fitxers, emmagatzemant informació crítica com la mida del clúster, la ubicació de la FAT i la ubicació del directori arrel.",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Sistemes de fitxers (Part 1)"
    ]
  },
  {
    "objectID": "slides/03-filesystem-part1.html#fat-limitacions-tècniques",
    "href": "slides/03-filesystem-part1.html#fat-limitacions-tècniques",
    "title": "Sistema de fitxers (I)",
    "section": "FAT: Limitacions Tècniques",
    "text": "FAT: Limitacions Tècniques\nLimitacions de capacitat:\n\nFAT32: màxim 2TB per volum\nFAT32: màxim 4GB per fitxer\n\nProblemes de rendiment:\n\nLocalització de blocs lliures: scan complet de la FAT\nFragmentació severa (pobra localitat)\nFragmentació de metadata: cerques costoses\nLlistes enllaçades ineficients per fitxers grans\n\nImpacte pràctic:\n\nUn fitxer de 16MB (4096 clústers de 4KB) requereix 4096 lectures de la FAT per accés seqüencial complet",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Sistemes de fitxers (Part 1)"
    ]
  },
  {
    "objectID": "slides/03-filesystem-part1.html#ext-extended-file-system",
    "href": "slides/03-filesystem-part1.html#ext-extended-file-system",
    "title": "Sistema de fitxers (I)",
    "section": "EXT: Extended File System",
    "text": "EXT: Extended File System\nEls sistemes EXT van ser dissenyats específicament per a Linux com a evolució dels sistemes Unix tradicionals.\nEvolució:\n\next (1992): Primera versió, problemes de rendiment\next2 (1993): Inodes, directoris flexibles\n\next3 (2001): Journaling per a consistència\next4 (2008): Extents, millor rendiment\n\nCaracterístiques:\n\nInodes com a element bàsic\nBitmaps per gestió d’assignació\nBlock Groups per localitat de dades\nJournaling per integritat",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Sistemes de fitxers (Part 1)"
    ]
  },
  {
    "objectID": "slides/03-filesystem-part1.html#ext-estructura-de-linode",
    "href": "slides/03-filesystem-part1.html#ext-estructura-de-linode",
    "title": "Sistema de fitxers (I)",
    "section": "EXT: Estructura de l’Inode",
    "text": "EXT: Estructura de l’Inode\nL’inode és el nucli del sistema EXT. Cada fitxer té almenys un inode que conté tota la seva metadata:\nstruct ext4_inode {\n    uint16_t i_mode;        // Permisos i tipus de fitxer\n    uint16_t i_uid;         // User ID del propietari\n    uint32_t i_size;        // Mida del fitxer en bytes\n    uint32_t i_atime;       // Últim temps d'accés\n    uint32_t i_ctime;       // Temps de creació de l'inode\n    uint32_t i_mtime;       // Últim temps de modificació\n    uint16_t i_gid;         // Group ID del propietari\n    uint16_t i_links_count; // Nombre de hard links\n    \n    // Punters a blocs de dades\n    uint32_t i_block[15];   // Blocs directes i indirectes\n    /*\n     * i_block[0-11]: 12 punters directes (48KB amb blocs de 4KB)\n     * i_block[12]:   1 punter simple indirecte (4MB addicionals)\n     * i_block[13]:   1 punter doble indirecte (4GB addicionals)\n     * i_block[14]:   1 punter triple indirecte (4TB addicionals)\n     */\n\n};\nEls i-nodes consumeixen un 10% de l’emmagatzematge del disc (es pot configurar en el moment de la creació del sistema de fitxers).",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Sistemes de fitxers (Part 1)"
    ]
  },
  {
    "objectID": "slides/03-filesystem-part1.html#ext-adreçament-de-blocs-ext2",
    "href": "slides/03-filesystem-part1.html#ext-adreçament-de-blocs-ext2",
    "title": "Sistema de fitxers (I)",
    "section": "EXT: Adreçament de Blocs (ext2)",
    "text": "EXT: Adreçament de Blocs (ext2)\n\nUn fitxer de 100MB (25.600 blocs de 4KB) necessita 2 nivells d’indirecció, requerint múltiples lectures de metadades abans d’accedir a les dades reals.",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Sistemes de fitxers (Part 1)"
    ]
  },
  {
    "objectID": "slides/03-filesystem-part1.html#ext-organització",
    "href": "slides/03-filesystem-part1.html#ext-organització",
    "title": "Sistema de fitxers (I)",
    "section": "EXT: Organització",
    "text": "EXT: Organització\n\n\nBitmap d’Inodes: mapa de bits d’inodes ocupats/lliures.\nBitmap de Blocs: mapa de bits de blocs ocupats/lliures.\nTaula d’Inodes: cada entrada és un únic inode.",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Sistemes de fitxers (Part 1)"
    ]
  },
  {
    "objectID": "slides/03-filesystem-part1.html#ext3-problema-de-consistència-i",
    "href": "slides/03-filesystem-part1.html#ext3-problema-de-consistència-i",
    "title": "Sistema de fitxers (I)",
    "section": "EXT3: Problema de Consistència (I)",
    "text": "EXT3: Problema de Consistència (I)\nImagineu que un fitxer necessita augmentar la seva mida, i això requereix assignar un nou bloc de dades i actualitzar l’inode per reflectir aquesta nova assignació. Aquest procés implica múltiples operacions d’escriptura al disc.",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Sistemes de fitxers (Part 1)"
    ]
  },
  {
    "objectID": "slides/03-filesystem-part1.html#ext3-problema-de-consistència-ii",
    "href": "slides/03-filesystem-part1.html#ext3-problema-de-consistència-ii",
    "title": "Sistema de fitxers (I)",
    "section": "EXT3: Problema de Consistència (II)",
    "text": "EXT3: Problema de Consistència (II)\n\nImagina que el procés es veu interromput (crash) a mitja operació.",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Sistemes de fitxers (Part 1)"
    ]
  },
  {
    "objectID": "slides/03-filesystem-part1.html#journaling---consistència",
    "href": "slides/03-filesystem-part1.html#journaling---consistència",
    "title": "Sistema de fitxers (I)",
    "section": "Journaling - Consistència",
    "text": "Journaling - Consistència\n\n\n\n\n\nsequenceDiagram\n    participant P as Procés\n    participant K as Kernel\n    participant J as Journal\n    participant FS as Filesystem\n\n    P-&gt;&gt;K: write() - ampliar fitxer\n    \n    Note over K,J: FASE 1: Preparació\n    K-&gt;&gt;J: Crear transacció: T1\n    K-&gt;&gt;J: Nou bloc dades · Update bitmap · Update inode\n    K-&gt;&gt;J: COMMIT transacció T1\n    \n    Note over K,FS: FASE 2: Aplicació\n    K-&gt;&gt;FS: Aplicar canvis del journal\n    K-&gt;&gt;J: Marcar T1 com a completa\n    \n    K--&gt;&gt;P: write() completat",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Sistemes de fitxers (Part 1)"
    ]
  },
  {
    "objectID": "slides/03-filesystem-part1.html#journaling-modes",
    "href": "slides/03-filesystem-part1.html#journaling-modes",
    "title": "Sistema de fitxers (I)",
    "section": "Journaling: Modes",
    "text": "Journaling: Modes\n\nJournaling Complet: Tant les dades com les metadades s’escriuen al journal abans d’aplicar-les al sistema de fitxers. Màxima seguretat, però més lent.\nJournaling de Metadades: Només les metadades s’escriuen al journal. Les dades es poden escriure directament al sistema de fitxers. Equilibri entre seguretat i rendiment.\nEscriptura Diferida (Writeback): Les dades i les metadades es poden escriure directament al sistema de fitxers sense passar pel journal. Màxim rendiment, però risc de corrupció de dades en cas de fallada.",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Sistemes de fitxers (Part 1)"
    ]
  },
  {
    "objectID": "slides/03-filesystem-part1.html#ext3-journaling",
    "href": "slides/03-filesystem-part1.html#ext3-journaling",
    "title": "Sistema de fitxers (I)",
    "section": "ext3 · Journaling",
    "text": "ext3 · Journaling\n\nPre-escriptura (Write-Ahead Logging):\n\nAbans d’escriure qualsevol dada o metadada al disc, es registra la intenció d’aquesta escriptura en un registre especial anomenat journal. Garanteix que les operacions es completin correctament, fins i tot en cas de fallades.\n\nSi escriu el journal correctament:\n\nLa transacció es marca com a completa. Els canvis es poden aplicar al sistema de fitxers de manera segura.\n\nSi la escriptura del journal es veu interrompuda:\n\nLa transacció no es completa (pèrdua de dades), però el sistema de fitxers roman consistent.\n\nSi el journal s’escriu correctament, però el disc no:\n\nTemporalment, el sistema de fitxers perd la consistència.El registre té la informació per restaurar-la (durant l’arrencada, els journals inacabats es completen).",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Sistemes de fitxers (Part 1)"
    ]
  },
  {
    "objectID": "slides/03-filesystem-part1.html#ext4-extents-per-a-millor-eficiència",
    "href": "slides/03-filesystem-part1.html#ext4-extents-per-a-millor-eficiència",
    "title": "Sistema de fitxers (I)",
    "section": "ext4: Extents per a Millor Eficiència",
    "text": "ext4: Extents per a Millor Eficiència\nEl principal problema (ext2/ext3) era la gestió ineficient dels punters a blocs de dades, especialment per a fitxers grans.\n\nUn extends és un descriptor que representa un rang contigu de blocs, millorant l’eficiència en l’assignació i reduint la fragmentació.\n\n\nRangs de blocs físics contigus, descrits amb una entrada (bloc inicial + nombre de blocs).\nUn extent pot mapar fins a 128 MiB (blocs de 4KB) d’espai contigu amb blocs de 4 KiB.\nL’inode d’ext4 pot contenir directament fins a 4 extents; si el fitxer és gran o fragmentat, s’utilitza una estructura d’arbre (HTree) per indexar més extents.",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Sistemes de fitxers (Part 1)"
    ]
  },
  {
    "objectID": "slides/03-filesystem-part1.html#ext4-estructura-dun-extent",
    "href": "slides/03-filesystem-part1.html#ext4-estructura-dun-extent",
    "title": "Sistema de fitxers (I)",
    "section": "ext4: Estructura d’un Extent",
    "text": "ext4: Estructura d’un Extent\nstruct ext4_extent {\n    uint32_t ee_block;      // Bloc lògic inicial al fitxer\n    uint16_t ee_len;        // Longitud en blocs (màxim 32.768)\n    uint16_t ee_start_hi;   // Bits alts del bloc físic\n    uint32_t ee_start_lo;   // Bits baixos del bloc físic\n};\n\n\n\n\n\ngraph TD\n    A[Inode] --&gt; B[Extent Header]\n    B --&gt; C1[Extent 1]\n    B --&gt; C2[Extent 2]\n    B --&gt; C3[Extent 3]\n    B --&gt; C4[Extent 4]\n    C1 --&gt; D1[Bloc Físic 1000 - 1023]\n    C2 --&gt; D2[Bloc Físic 2000 - 2023]\n    C3 --&gt; D3[Bloc Físic 3000 - 3023]\n    C4 --&gt; D4[Bloc Físic 4000 - 4023]\n    style A fill:#eaf7ff,stroke:#007bff\n    style B fill:#f9f5dd,stroke:#c4aa18",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Sistemes de fitxers (Part 1)"
    ]
  },
  {
    "objectID": "slides/03-filesystem-part1.html#ext4-htreebtree",
    "href": "slides/03-filesystem-part1.html#ext4-htreebtree",
    "title": "Sistema de fitxers (I)",
    "section": "ext4: HTree/Btree",
    "text": "ext4: HTree/Btree\n\n\n\nUn B-tree és una estructura d’arbre auto-balancejada que manté dades ordenades i permet cerques, insercions i eliminacions en temps logarítmic.\nUn HTree és una variant de B-tree utilitzada específicament per indexar fitxers i directoris en ext4.\nLa principal diferència és que les entrades es distribueixen en nodes fulla i no fulla, amb una estructura de capçalera específica per a cada node.\nInode/Arrel: Apunta a la capçalera de l’HTree.\n\n\n\n\n\n\n\ngraph TD\n    A[Inode] --&gt; B[HTree Root]\n    B --&gt; C1[Node No Fulla 1]\n    B --&gt; C2[Node No Fulla 2]\n    C1 --&gt; D1[Node Fulla 1]\n    C1 --&gt; D2[Node Fulla 2]\n    C2 --&gt; D3[Node Fulla 3]\n    C2 --&gt; D4[Node Fulla 4]\n    D1 --&gt; E1[Extent 1]\n    D1 --&gt; E2[Extent 2]\n    D2 --&gt; E3[Extent 3]\n    D3 --&gt; E4[Extent 4]\n    D4 --&gt; E5[Extent 5]\n\n\n\n\n\n\n\nNodes no fulla: Indexen altres nodes, permetent que l’arbre creixi i es mantingui balancejat.\nNodes fulla: Contenen les extents, que són rangs de blocs físics contigus.\nExtents: Descriuen els blocs reals del fitxer o directori.",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Sistemes de fitxers (Part 1)"
    ]
  },
  {
    "objectID": "slides/03-filesystem-part1.html#ext4-assignació-multibloc-i-retrassada",
    "href": "slides/03-filesystem-part1.html#ext4-assignació-multibloc-i-retrassada",
    "title": "Sistema de fitxers (I)",
    "section": "ext4 · Assignació multibloc i retrassada",
    "text": "ext4 · Assignació multibloc i retrassada\n\nAssignació Multibloc:\n\next4 pot assignar múltiples blocs a la vegada, agrupant blocs consecutius per minimitzar la fragmentació.\nAixò redueix la sobrecàrrega d’assignació i millora la localitat de les dades.\n\nAssignació Retardada:\n\nL’assignació retardada espera a bloquejar l’espai fins just abans d’escriure, optimitzant la distribució de blocs.\nAixò permet agrupar escriptures i minimitzar la fragmentació.",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Sistemes de fitxers (Part 1)"
    ]
  },
  {
    "objectID": "slides/03-filesystem-part1.html#exercicis-propostas",
    "href": "slides/03-filesystem-part1.html#exercicis-propostas",
    "title": "Sistema de fitxers (I)",
    "section": "Exercicis Propostas",
    "text": "Exercicis Propostas\n\nAdministració Bàsica de Sistemes de Fitxers\nDiscussió: Secure Boot és realment segur?: Cerca notícies recents sobre Secure Boot i comparteix-les al fòrum del curs. Debatiu sobre avantatges, desavantatges, vulnerabilitats conegudes i experiències personals.\nPràctica 01: Snapshots i restauració amb systemd i initramfs",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Sistemes de fitxers (Part 1)"
    ]
  },
  {
    "objectID": "slides/03-filesystem-part1.html#thats-all",
    "href": "slides/03-filesystem-part1.html#thats-all",
    "title": "Sistema de fitxers (I)",
    "section": "That’s all",
    "text": "That’s all\n\n\n\n\n\n\n\n\n\nTake Home Message\n\n\nEls sistemes de fitxers són complexos i crítics per al rendiment i la fiabilitat del sistema operatiu. El VFS proporciona una capa d’abstracció que permet gestionar diferents tipus de sistemes de fitxers de manera uniforme. Sistemes de fitxers com EXT4 han evolucionat per abordar problemes de rendiment i consistència, incorporant característiques com els extents i el journaling.",
    "crumbs": [
      "Diapositives",
      "Unitat 03 · Sistemes de fitxers (Part 1)"
    ]
  },
  {
    "objectID": "exercises/01-foundations-of-systems-administration/02-ex-week1.html",
    "href": "exercises/01-foundations-of-systems-administration/02-ex-week1.html",
    "title": "Emulació en mode d’usuari amb QEMU",
    "section": "",
    "text": "Aquest exercici t’introduirà a l’emulació en mode d’usuari de QEMU, una eina que et permet executar un programa compilat per a una arquitectura de CPU diferent de la teva màquina. Concretament, executaràs un programa de 32 bits compilat per a ARM en un sistema x86 (processadors Intel o AMD) o ARM de 64 bits (processadors Apple M). Per simplificar l’exercici, utiltizarem un Hello, World! com a programa d’exemple.",
    "crumbs": [
      "Activitats",
      "Unitat 01 · Fonaments de l'Administració de Sistemes",
      "Activitat 2 · Emulació en mode d'usuari amb QEMU"
    ]
  },
  {
    "objectID": "exercises/01-foundations-of-systems-administration/02-ex-week1.html#requeriments-previs",
    "href": "exercises/01-foundations-of-systems-administration/02-ex-week1.html#requeriments-previs",
    "title": "Emulació en mode d’usuari amb QEMU",
    "section": "Requeriments previs",
    "text": "Requeriments previs\n\nDisposar d’una màquina virtual amb Debian configurada segons les instruccions de l’exercici de configuració d’entorn de virtualització.\nDisposar de les eines bàsiques de desenvolupament instal·lades a la màquina virtual (compilador gcc, make, etc.). Pots instal·lar-les com a root amb la comanda següent: apt install build-essential.",
    "crumbs": [
      "Activitats",
      "Unitat 01 · Fonaments de l'Administració de Sistemes",
      "Activitat 2 · Emulació en mode d'usuari amb QEMU"
    ]
  },
  {
    "objectID": "exercises/01-foundations-of-systems-administration/02-ex-week1.html#objectius",
    "href": "exercises/01-foundations-of-systems-administration/02-ex-week1.html#objectius",
    "title": "Emulació en mode d’usuari amb QEMU",
    "section": "Objectius",
    "text": "Objectius\n\nIntroduir-se en l’ús de QEMU en mode d’usuari per a l’emulació d’aplicacions.\nComprendre la diferència entre compilació nativa i compilació creuada.\nCompilar i executar un programa senzill per a una arquitectura diferent de la teva màquina.",
    "crumbs": [
      "Activitats",
      "Unitat 01 · Fonaments de l'Administració de Sistemes",
      "Activitat 2 · Emulació en mode d'usuari amb QEMU"
    ]
  },
  {
    "objectID": "exercises/01-foundations-of-systems-administration/02-ex-week1.html#tasques",
    "href": "exercises/01-foundations-of-systems-administration/02-ex-week1.html#tasques",
    "title": "Emulació en mode d’usuari amb QEMU",
    "section": "Tasques",
    "text": "Tasques\n\nEscriure i compilar un programa Hello World per a ARM\n\nCrea un fitxer anomenat hello.c amb el següent contingut:\n\n#include &lt;stdio.h&gt;\n\nint main() {\n    printf(\"Hello, World!\\n\");\n    return 0;\n}\nPer compilar-lo per a l’arquitectura ARM, necessites un compilador creuat. En aquest laboratori, utilitzarem el GNU ARM toolchain per a Linux. Instal·la’l amb la següent comanda:\n# Com a root\napt install gcc-arm-linux-gnueabi\nAra, compila el programa per a ARM amb aquesta comanda:\n# Com a usuari normal\narm-linux-gnueabi-gcc -o helloarm -static hello.c\nAixò generarà un executable anomenat helloarm. La bandera -static crea un binari estàticament enllaçat, la qual cosa significa que totes les biblioteques necessàries s’inclouen dins del propi fitxer.\nSi intentes executar helloarm directament, rebràs un error:\n./helloarm\n-bash: ./helloarm: no es pot executar el fitxer binari: Error de format d'execució\nAquest error es produeix perquè el teu sistema operatiu no reconeix l’arquitectura del fitxer. Pots verificar-ho amb la comanda file:\nfile helloarm\nhelloarm: ELF 32-bit LSB executable, ARM, EABI5 version 1 (SYSV), statically linked, not stripped\n\n\nCompilació per a l’arquitectura de la teva MV\nPer entendre la diferència, ara compila el mateix codi per a l’arquitectura de la teva màquina amb gcc:\ngcc -o hellohost hello.c\nSi l’executes, funcionarà sense problemes:\n./hellohost\nHello, World!\nPer comprovar-ne l’arquitectura, utilitza de nou la comanda file:\nfile hellohost\n# Exemple per a x86\nhellohost: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked...\n# Exemple per a Apple M Series (ARM 64-bit)\nhellohost: ELF 64-bit LSB shared object, ARM aarch64, version 1 (SYSV), dynamically linked...\n\n\nExecució del programa amb QEMU\nFinalment, per executar el binari ARM a la teva màquina, necessites el component de QEMU per a emulació en mode d’usuari. Instal·la’l amb aquesta comanda:\n# Com a root\napt install qemu-user\nUn cop instal·lat, pots executar el programa helloarm amb l’emulador qemu-arm:\nqemu-arm helloarm\nHello, World!\n\n\nPreguntes finals\n\nInvestiga quines altres arquitectures són compatibles amb QEMU en mode d’usuari. Prova de compilar i executar un programa per a una d’aquestes arquitectures.\nPer què la compilació estàtica és important en aquest context? Per què no cal incloure la bandera -static en la compilació normal? Quines avantatges i inconvenients té cada enfocament?",
    "crumbs": [
      "Activitats",
      "Unitat 01 · Fonaments de l'Administració de Sistemes",
      "Activitat 2 · Emulació en mode d'usuari amb QEMU"
    ]
  },
  {
    "objectID": "exercises/03-fs/08-ex-week5.html",
    "href": "exercises/03-fs/08-ex-week5.html",
    "title": "Administració bàsica de Sistemes de Fitxers",
    "section": "",
    "text": "Crear particions i sistemes de fitxers (ext4, xfs).\nMigrar directoris reals a particions separades amb coherència i sense pèrdua de dades.\nConfigurar el muntatge automàtic amb UUID i opcions de seguretat (nodev, nosuid, noexec).\nDiagnosticar i recuperar problemes reals: saturació d’espai i corrupció de sistema de fitxers.\nEines: fdisk, mkfs.*, tune2fs, mount, rsync, xfs_repair, hexedit.",
    "crumbs": [
      "Activitats",
      "Unitat 03 · Sistemes de fitxers",
      "Activitat 8 · Administració bàsica de Sistemes de Fitxers"
    ]
  },
  {
    "objectID": "exercises/03-fs/08-ex-week5.html#objectius",
    "href": "exercises/03-fs/08-ex-week5.html#objectius",
    "title": "Administració bàsica de Sistemes de Fitxers",
    "section": "",
    "text": "Crear particions i sistemes de fitxers (ext4, xfs).\nMigrar directoris reals a particions separades amb coherència i sense pèrdua de dades.\nConfigurar el muntatge automàtic amb UUID i opcions de seguretat (nodev, nosuid, noexec).\nDiagnosticar i recuperar problemes reals: saturació d’espai i corrupció de sistema de fitxers.\nEines: fdisk, mkfs.*, tune2fs, mount, rsync, xfs_repair, hexedit.",
    "crumbs": [
      "Activitats",
      "Unitat 03 · Sistemes de fitxers",
      "Activitat 8 · Administració bàsica de Sistemes de Fitxers"
    ]
  },
  {
    "objectID": "exercises/03-fs/08-ex-week5.html#requeriments-previs",
    "href": "exercises/03-fs/08-ex-week5.html#requeriments-previs",
    "title": "Administració bàsica de Sistemes de Fitxers",
    "section": "Requeriments previs",
    "text": "Requeriments previs\n\nTenir una màquina virtual (MV) amb Debian instal·lat.\nCrear un disc dur virtual addicional de 10GB del tipus SATA o NVMe.\nInstal·lar els paquets xfsprogs, rsync, hexedit i build-essential:\napt update -y && apt install xfsprogs rsync hexedit build-essential -y\nTotes les comandes s’han d’executar amb permisos de superusuari (root). Per tant, su -.\nCompte amb el nom del disc dur addicional, en aquest cas /dev/nvme0n2, però pot variar en funció de la configuració de la màquina virtual, utilitza la comanda lsblk per a identificar el disc dur addicional. Utilitza el nom correcte actualitzant-lo en les comandes que apareixen en aquest exercici.",
    "crumbs": [
      "Activitats",
      "Unitat 03 · Sistemes de fitxers",
      "Activitat 8 · Administració bàsica de Sistemes de Fitxers"
    ]
  },
  {
    "objectID": "exercises/03-fs/08-ex-week5.html#particions-i-sistemes-de-fitxers",
    "href": "exercises/03-fs/08-ex-week5.html#particions-i-sistemes-de-fitxers",
    "title": "Administració bàsica de Sistemes de Fitxers",
    "section": "Particions i Sistemes de Fitxers",
    "text": "Particions i Sistemes de Fitxers\n\nCrear Particions i Sistemes de Fitxers\nAssegurarem que el disc dur addicional està detectat pel sistema. En aquest cas, el disc dur és /dev/nvme0n2, però pot variar en funció de la configuració de la màquina virtual, utilitza la comanda lsblk per a identificar el disc dur addicional.\nUtilitzarem la comanda fdisk per a crear tres noves particions en el disc dur.\n\nLa primera partició serà per a /var amb el sistema de fitxers ext4, etiqueta var mida 4GB.\nLa segona partició serà per a /tmp amb el sistema de fitxers xfs, sense etiqueta i mida 2GB.\nLa tercera partició serà per a /opt amb el sistema de fitxers ext4, etiqueta opt mida 3GB.\nLa quarta partició serà /home amb el sistema de fitxers ext4, etiqueta home i la resta d’espai disponible (1GB).\n\nCrearem les noves particions en el disc dur. Podeu utilzar una pipeline per a automatitzar la creació de les particions.\necho -e \"n\\np\\n\\n\\n+4G\\nn\\np\\n\\n\\n+2G\\nn\\np\\n\\n\\n+3G\\nn\\np\\n\\n\\n+1G\\nw\" | fdisk /dev/nvme0n2\nEl següent pas és crear els sistemes de fitxers en les particions que acabem de crear i assignar les etiquetes corresponents.\nmkfs.ext4 /dev/nvme0n2p1\ntune2fs -L \"var\" /dev/nvme0n2p1\nmkfs.xfs /dev/nvme0n2p2\nmkfs.ext4 /dev/nvme0n2p3\ntune2fs -L \"opt\" /dev/nvme0n2p3\nmkfs.xfs /dev/nvme0n2p4\ntune2fs -L \"home\" /dev/nvme0n2p4\nMonteu les particions en directoris temporals per a migrar les dades, per a això, creeu els directoris /mnt/var, /mnt/tmp , /mnt/opt i /mnt/home.\nmkdir /mnt/var /mnt/tmp /mnt/opt /mnt/home\nmount /dev/nvme0n2p1 /mnt/var\nmount /dev/nvme0n2p3 /mnt/opt\nmount /dev/nvme0n2p4 /mnt/home\n\n\n\n\n\n\nNota/tmp\n\n\n\nLa partició /tmp és temporal i no conté dades importants, per tant, no la muntarem en aquest pas, ja que no necessitem migrar cap dada. Les seves dades es perdran en el reinici del sistema.\n\n\n\n\nMigrar Directoris a les Noves Particions\nAbans de migrar les dades, és important assegurar-se que no hi ha processos que estiguin utilitzant els directoris que volem migrar. Per a això, podem utilitzar la comanda lsof per a llistar els fitxers oberts en aquests directoris.\nlsof +D /var\nlsof +D /opt\nlsof +D /home\n\n\n\n\n\n\nNotaFitxers oberts\n\n\n\nSi hi ha processos que estan utilitzant els directoris que volem migrar, és recomanable aturar aquests processos abans de continuar amb la migració. Això és especialment important per al directori /var, ja que conté fitxers de registre i altres dades que poden ser utilitzades per diversos serveis del sistema.\n\n\nHi ha moltes comandes per a migrar dades entre directoris, però en aquest cas utilitzarem la comanda rsync ja que ens permet mostrar el progrés de la còpia i també ens permet reprendre la còpia en cas que es talli la connexió o hi hagi un error. A més, també ens permet excloure directoris o fitxers que no volem migrar i ens permet fer còpies incrementals.\nrsync -av /var/ /mnt/var\nrsync -av /opt/ /mnt/opt\nrsync -av /home/ /mnt/home\n\n\n\n\n\n\nNotarsync\n\n\n\nrsync és una eina molt potent per a la sincronització de fitxers i directoris. En aquest cas, utilitzem les opcions -a (mode arxiu) i -v (verbose) per a conservar els permisos, propietaris, marques de temps i per a mostrar el progrés de la còpia. La barra inclinada (/) al final dels directoris d’origen és important perquè indica a rsync que només volem copiar el contingut del directori i no el directori en si mateix. Si no posem la barra inclinada, rsync crearà un subdirectori amb el mateix nom que el directori d’origen dins del directori de destinació. Per a més informació sobre rsync, podeu consultar la documentació (man rsync).\n\n\nUn cop copiem les dades, és important verificar que les dades s’han copiat correctament. Per a això, podem utilitzar la comanda diff per a comparar els directoris d’origen i destinació.\ndiff -r /var /mnt/var\ndiff -r /opt /mnt/opt\ndiff -r /home /mnt/home\nSi la comanda diff no mostra cap sortida, significa que els directoris són idèntics i que les dades s’han copiat correctament. Si hi ha diferències, la comanda diff mostrarà les línies que són diferents entre els dos directoris.\nMuntarem les noves particions en els directoris corresponents.\nmount /dev/nvme0n2p1 /var\nmount /dev/nvme0n2p3 /opt\nmount /dev/nvme0n2p4 /home\nUtiltiza la comanda df per a comprovar que les particions s’han muntat correctament o lsblk per a veure totes les particions i els seus punts de muntatge.\n\n\nConfigurar el Muntatge Automàtic\nSi ara reinicieu el sistema reboot, les particions no estaran muntades automàticament. Per a que les particions es muntin automàticament en l’arrencada del sistema, hem d’editar el fitxer /etc/fstab i afegir les noves particions amb els seus punts de muntatge corresponents.\necho \"/dev/nvme0n2p1 /var ext4 defaults 0 0\" &gt;&gt; /etc/fstab\necho \"/dev/nvme0n2p2 /tmp xfs defaults 0 0\" &gt;&gt; /etc/fstab\necho \"/dev/nvme0n2p3 /opt ext4 defaults 0 0\" &gt;&gt; /etc/fstab\necho \"/dev/nvme0n2p4 /home xfs defaults 0 0\" &gt;&gt; /etc/fstab\n\n\n\n\n\n\nNota/etc/fstab\n\n\n\nEl fitxer /etc/fstab conté la informació de les particions que es muntaran automàticament en l’arrencada del sistema. Cada línia del fitxer conté la informació d’una partició. Els camps de cada línia són: dispositiu, punt de muntatge, sistema de fitxers, opcions, freqüència de comprovació i ordre de comprovació. Podeu consultar la documentació del fitxer per a més informació (man fstab).\n\n\nPots provar la configuració del fitxer /etc/fstab sense reiniciar el sistema amb la comanda mount -a. Aquesta comanda muntarà totes les particions que estan definides en el fitxer /etc/fstab. També podem fer un reboot per a comprovar que les particions es muntin automàticament en l’arrencada del sistema, sempre hi quan la comanda mount -a no hagi donat cap error.\nEn aquest punt podriam optimitzar la configuració particions per a millorar el rendiment del sistema.\n\nUtiltizarem els UUIDs en lloc dels dispositius per a muntar les particions. Això ens permetrà identificar les particions de forma unívoca i evitar problemes en cas que els dispositius canviïn d’identificador. Per fer-ho podem utilitzar la comanda sed per actualitzar el fitxer /etc/fstab.\nsed -i \"s|/dev/nvme0n2p1|UUID=$(blkid -s UUID -o value /dev/nvme0n2p1)|\" /etc/fstab\nsed -i \"s|/dev/nvme0n2p2|UUID=$(blkid -s UUID -o value /dev/nvme0n2p2)|\" /etc/fstab\nsed -i \"s|/dev/nvme0n2p3|UUID=$(blkid -s UUID -o value /dev/nvme0n2p3)|\" /etc/fstab\nsed -i \"s|/dev/nvme0n2p4|UUID=$(blkid -s UUID -o value /dev/nvme0n2p4)|\" /etc/fstab\n\n🔍 Pregunta: En quins casos poden canviar els dispositius o tenir duplicats?\nEls dispositius poden canviar d’identificador en cas que es connectin més dispositius al sistema o es canvii l’ordre de connexió dels dispositius. Això pot provocar que les particions es muntin en llocs diferents dels esperats. Per a evitar aquest problema, és recomanable utilitzar els UUIDs en lloc dels dispositius per a muntar les particions.\n\nUtilitzarem opcions més específiques per protegir la partició /tmp per a evitar que s’executin programes des de la partició. Utilitzant les opcions nodev, nosuid, i noexec:\n\nEdita el fitxer /etc/fstab i afegeix les opcions nodev, nosuid, i noexec a la partició /tmp.\n\n\n\n\n\n\n\n\nNotaOpcions de Muntatge\n\n\n\nLa opció defaults és una col·lecció d’opcions que s’utilitzen per defecte en la majoria de sistemes de fitxers. Aquestes opcions inclouen rw (lectura i escriptura), suid (permet l’ús de l’atribut suid), és a dir, evita que es puguin exectuar programaes amb permisos de superusuari, dev (permet l’ús de dispositius), exec (permet l’execució de fitxers binaris), auto (muntatge automàtic en l’arrencada del sistema), nouser (només l’usuari root pot muntar la partició) i async (permet l’escriptura asíncrona).\n\n\n\nComprova les opcions després d’editar el fitxer /etc/fstab.\n\nmount | grep /tmp\n\nPer aplicar les opcions de muntatge a la partició /tmp, farem un reboot del sistema.\nTestem les opcions de muntatge de la partició /tmp:\n\nProva d’executar un programa des de la partició /tmp com a usuari no privilegiat.\n\necho \"echo 'Hello, World'\" &gt; /tmp/hello.sh\nchmod +x /tmp/hello.sh\n/tmp/hello.sh\nbash /tmp/hello.sh\n\nProva de fer el mateix com a usuari privilegiat.\n\nsu -\n/tmp/hello.sh\nbash /tmp/hello.sh\n\n👁️ Observació:\nObserveu que la opció noexec impedeix la execució dels binaris però no ens protegeix contra l’execució de scripts de bash.\n\n\nProva d’accedir a un dispositiu creat a /tmp:\n\nInicialitza un dispositiu a /tmp utilitzant la comanda mknod.\n\nmknod /tmp/dispositiu c 1 3\n\n⚠️ Compte:\nLa comanda mknod única i exclusivament la poden fer els usuaris amb permisos de superusuari. Per tant, feu servir la comanda su per a canviar a l’usuari root abans de fer servir la comanda mknod.\n\n\nPer accedir al dispositiu, utilitza la comanda cat.\n\ncat /tmp/dispositiu\n\n👁️ Observació:\nFixeu-vos que quan intento accedir a un dispositiu al directori actual, no hi ha cap problema. Però quan intento accedir al dispositiu creat a /tmp, rebre un missatge d’error indicant que no es pot accedir al dispositiu. Això és degut a la opció nodev que impedeix l’accés a dispositius en la partició.\n\n\n\nPer veure, les implicacions de la opció nosuid, podem realitzar el següent experiment:\nPer fer-ho, crearem un executable amb c que ens indicarà l’identificador de l’usuari real i l’identificador de l’usuari efectiu. On l’usuari real és l’usuari que ha iniciat la sessió i l’usuari efectiu és l’usuari que executa el programa. Si un programa té el bit suid activat, l’usuari efectiu serà l’usuari propietari del programa i no l’usuari que l’ha executat.\n#include &lt;stdio.h&gt;\n#include &lt;sys/types.h&gt;\n#include &lt;unistd.h&gt;\n\nint main() {\n    printf(\"Effective user ID: %d\\n\", geteuid());\n    printf(\"Real user ID: %d\\n\", getuid());\n    return 0;\n}\nCompilem el programa amb la comanda gcc.\ngcc -o /tmp/suid /tmp/suid.c\nDesactiva la opció nosuid i també la opció noexec per a la partició /tmp. Per fer-ho, utilitza l’usuari root per a editar el fitxer /etc/fstab.\nRemunta la partició /tmp.\nProva d’executar el programa com a usuari no privilegiat.\n/tmp/suid\nActiva la opció nosuid i torna a provar d’executar el programa.\n/tmp/suid\n\n\n👁️ Observació:\nFixeu-vos que quan la opció nosuid està activada, no es pot executar el programa amb permisos de superusuari. Això és important per a evitar que els usuaris no privilegiats puguin executar programes amb permisos de superusuari. Aquesta opció pot permetre escalar privilegis i comprometre la seguretat del sistema.\n\n\n\n🔍 Pregunta: Per què és important tenir els directoris /var, /tmp i /opt en particions diferents?\nLa raó principal per a tenir els directoris /var, /tmp i /opt en particions diferents és per a millorar el rendiment i la seguretat del sistema. El directori /var conté dades variables com ara logs, bases de dades, correu electrònic, etc. Si aquest directori es queda sense espai, el sistema podria fallar. El mateix raonament s’aplica al directori /tmp i /opt. Per això, és important tenir-los en particions separades per a evitar que el sistema falli. A més, tenir els directoris /var, /tmp i /opt en particions separades també millora la seguretat del sistema ja que si una partició falla, les altres particions seguiran funcionant.\n\nAnem a fer una simulació de com respon el sistema en cas de no tenir els directoris /var, /tmp i /opt en particions separades. Per a això, simularem que el directori /opt es va omplint fins a ocupar tot l’espai disponible en la partició principal del sistema.\n\nDesmuntem la partició /opt per a poder continuar amb l’exercici.\numount /opt\nCreeu un fitxer de 20GB al directori /opt:\ndd if=/dev/urandom of=/opt/fitxer bs=1M count=20480\nComprova l’estat del sistema.\ndf -h\n\n\n\nComprova l’estat del sistema\n\n\nIntenta instal·lar un paquet amb apt i comprova que el sistema falla.\napt install htop\n\n\n\nIntenta instal·lar un paquet amb apt i comprova que el sistema falla\n\n\nCom podeu veure, el sistema fallarà ja que no té espai suficient per a instal·lar el paquet. Això és un problema greu ja que el sistema no podrà funcionar correctament fins que no alliberem espai en la partició principal.\nElimina el fitxer que has creat per a poder continuar amb la resta de l’exercici.\nrm /opt/fitxer\nMunteu la partició /opt i torneu a crear el fitxer per a omplir el directori.\nmount /dev/nvme0n2p3 /opt\ndd if=/dev/urandom of=/opt/fitxer bs=1M count=20480\nAra únicament teniu la partició /opt plena; però el sistema pot continuar fent tasques:\napt install htop",
    "crumbs": [
      "Activitats",
      "Unitat 03 · Sistemes de fitxers",
      "Activitat 8 · Administració bàsica de Sistemes de Fitxers"
    ]
  },
  {
    "objectID": "exercises/03-fs/08-ex-week5.html#simulant-una-corrupció-a-home",
    "href": "exercises/03-fs/08-ex-week5.html#simulant-una-corrupció-a-home",
    "title": "Administració bàsica de Sistemes de Fitxers",
    "section": "Simulant una corrupció a /home",
    "text": "Simulant una corrupció a /home\nEn aquest escenari simularem que hem patit una corrupció a la partició /home i quines eines podem utiltzar per intentar recuperar les dades. Bàsicament editarem alguns bits de la partició /home amb un editor hexadecimal per a simular la corrupció i després utilitzarem l’eina xfs_repair per a intentar recuperar les dades.\nEl primer pas que farem serà migrar el directori /home a una partició diferent per a poder simular la corrupció. A continuació, simularem la corrupció i finalment recuperarem les dades.\nAra podem crear fitxers i directoris al directori /home del vostre usuari normal, en el meu cas jordi.\nmkdir codi\nmkdir dades\ntouch dades/pokemon.csv\ntouch codi/main.c\ntouch codi/Makefile\ntouch codi/README.md\ntouch .vim\nPer a simular una corrupció editarem alguns valors de la partició /home amb un editor hexadecimal.\n\nDesmuntem la partició /home.\numount /home\n\nCompte!: Si esteu connectats per SSH, no podreu desmuntar la partició /home ja que el vostre usuari està utilitzant aquesta partició. En la primera sessió. Per tant, haure de fer-ho a la consola de la màquina virtual.\n\nObrirem la partició /home amb un editor hexadecimal:\n\nhexedit /dev/nvme0n2p4 \n\nModifiqueu bits a l’atzar i deseu els canvis. Per fer-ho escriviu damunt dels valors hexadecimals altres valors. Un cop fet guardeu amb Ctrl + X i Y.\nAra intentarem muntar la partició /home per a comprovar que ha estat corrompuda.\n\nmount /home\nSi la partició /home s’ha corromput, hauríeu de veure un missatge d’error com aquest:\n\nEls diferents sistemes de fitxers tenen eines per a comprovar la integritat dels fitxers. Per exemple, el sistema de fitxers xfs té l’eina xfs_ncheck que permet comprovar la integritat dels fitxers.\nxfs_ncheck /dev/nvme0n2p4\nPer a reparar la partició /home utilitzarem l’eina xfs_repair.\nxfs_repair /dev/nvme0n2p4\nUn cop reparada la partició /home, la muntarem de nou.\nmount /home\nComprovarem que la partició /home s’ha muntat correctament i conté els fitxers que havíem creat.\nls /home",
    "crumbs": [
      "Activitats",
      "Unitat 03 · Sistemes de fitxers",
      "Activitat 8 · Administració bàsica de Sistemes de Fitxers"
    ]
  },
  {
    "objectID": "exercises/02-booting/06-ex-week4.html",
    "href": "exercises/02-booting/06-ex-week4.html",
    "title": "Anàlisi del procés d’arrencada amb systemd",
    "section": "",
    "text": "Aprendre a utilitzar les eines de systemd per analitzar el procés d’arrencada del sistema.\nEntendre com identificar quines unitats són les més crítiques per al temps d’arrencada.\nAprendre a interpretar la sortida de les comandes systemd-analyze i systemctl.",
    "crumbs": [
      "Activitats",
      "Unitat 02 · Arrencada del sistema",
      "Activitat 6 · Anàlisi del procés d'arrencada amb systemd"
    ]
  },
  {
    "objectID": "exercises/02-booting/06-ex-week4.html#objectius",
    "href": "exercises/02-booting/06-ex-week4.html#objectius",
    "title": "Anàlisi del procés d’arrencada amb systemd",
    "section": "",
    "text": "Aprendre a utilitzar les eines de systemd per analitzar el procés d’arrencada del sistema.\nEntendre com identificar quines unitats són les més crítiques per al temps d’arrencada.\nAprendre a interpretar la sortida de les comandes systemd-analyze i systemctl.",
    "crumbs": [
      "Activitats",
      "Unitat 02 · Arrencada del sistema",
      "Activitat 6 · Anàlisi del procés d'arrencada amb systemd"
    ]
  },
  {
    "objectID": "exercises/02-booting/06-ex-week4.html#requeriments-previs",
    "href": "exercises/02-booting/06-ex-week4.html#requeriments-previs",
    "title": "Anàlisi del procés d’arrencada amb systemd",
    "section": "Requeriments Previs",
    "text": "Requeriments Previs\n\nTenir una màquina virtual (MV) amb Debian instal·lat.\nTotes les comandes s’han d’executar amb permisos de superusuari (root). Per tant, su -.",
    "crumbs": [
      "Activitats",
      "Unitat 02 · Arrencada del sistema",
      "Activitat 6 · Anàlisi del procés d'arrencada amb systemd"
    ]
  },
  {
    "objectID": "exercises/02-booting/06-ex-week4.html#anàlisi-del-procés-darrencada-amb-systemd",
    "href": "exercises/02-booting/06-ex-week4.html#anàlisi-del-procés-darrencada-amb-systemd",
    "title": "Anàlisi del procés d’arrencada amb systemd",
    "section": "Anàlisi del procés d’arrencada amb systemd",
    "text": "Anàlisi del procés d’arrencada amb systemd\nLa comanda systemd ens permet gestionar els serveis del sistema i controlar el procés d’arrencada. Podeu comprovar les seves possibilitats amb la comanda man systemd. Una de les funcionalitats més útils de systemd és la capacitat de generar informació detallada sobre el procés d’arrencada del sistema.\nEl primer pas per analitzar el procés d’arrencada amb systemd és utilitzar la comanda systemd-analyze per obtenir informació sobre el temps que ha trigat el sistema a arrencar. Aquesta comanda mostrarà informació sobre el temps que ha trigat el sistema a arrencar, incloent el temps que ha trigat el kernel i l’espai d’usuari.\nStartup finished in 899ms (kernel) + 2.074s (userspace) = 2.973s\ngraphical.target reached after 2.068s in userspace.\n\n\n\nKernel\nEspai d’usuari\nTotal\n\n\n\n\n899ms\n2.074s\n2.973s\n\n\n\nEn aquest cas, els primers 899ms s’utilitzen per carregar les funcions del kernel com ara els controladors de dispositius i el sistema de fitxers. Els següents 2.074s s’utilitzen per carregar l’espai d’usuari, com ara els serveis i els processos del sistema. En total, el sistema ha trigat 2.973s a arrencar.\nAra que tenim aquesta informació, podem utilitzar la comanda systemd-analyze blame per obtenir informació detallada sobre el temps que ha trigat cada unitat a carregar durant el procés d’arrencada. Aquesta opció ens llistarà les unitats ordenades per temps d’arrencada, de major a menor.\n\n\n\nTemps\nUnitat\n\n\n\n\n1.876s\nsystemd-random-seed.service\n\n\n784ms\ndbus.service\n\n\n782ms\ne2scrub_reap.service\n\n\n778ms\nsystemd-logind.service\n\n\n…\n…\n\n\n4ms\nsystemd-update-utmp-runlevel.service\n\n\n\nAmb aquesta informació, podem identificar les unitats que poden estar retardant el procés d’arrencada i optimitzar-les si cal. Per obtenir més informació sobre una unitat específica, podeu utilitzar la comanda systemctl status seguida del nom de la unitat. Per exemple, si volem informació sobre la unitat systemd-random-seed.service, podem executar:\nsystemctl status systemd-random-seed.service\nAquesta informació ens mostrarà:\n\nL’estat actual de la unitat (inactiu, actiu, desactivat, error o recarregant).\nLa linia Loaded ens indica la ruta al fitxer on es desa la configuració de la unitat. En aquest cas, /lib/systemd/system/systemd-random-seed.service. A més ens indica static que vol dir que la unitat no es pot desactivar. Altres unitats ens poden indicar error, masked, not-found, enable o disabled\nLa entrada al manual de la unitat, si n’hi ha.\nFinalment, ens mostra informació sobre el procés: PID, estat del procés i temps que ha estat en execució (això en el exemple) també pot mostrar la memòria, el cgroup, o el nombre de tasques associades.\n\nSi volem saber exactament què fa aquest servei, podem consultar el manual amb la comanda man systemd-random-seed.service.\nEn el manual d’aquesta comanda us explicarà de forma detallada què aquest servei carrega una llavor aleatòria al espai del nucli quan arranca i la desa quan s’apaga. Aquesta llavor es guarda a /var/lib/systemd/random-seed. Per defecte, no s’assigna entropia quan s’escriu la llavor al nucli, però això es pot canviar amb $SYSTEMD_RANDOM_SEED_CREDIT. El servei s’executa després de muntar el sistema de fitxers /var/, per la qual cosa és recomanable utilitzar un carregador d’arrencada que passi una llavor inicial al nucli, com systemd-boot.\n\n\n\n\n\n\nNotaObservació\n\n\n\nAmb aquesta informació podem identificar quina és la funció de cada servei i decidir si pel nostre sistema és necessari o no. En aquest cas, el servei systemd-random-seed.service és necessari per a la generació de nombres aleatoris, per tant, no és recomanable desactivar-lo.\n\n\nSi volem informació sobre la unitat systemd-random-seed.service, podem utilitzar la comanda systemctl cat systemd-random-seed.service per veure la configuració de la unitat.\n# /lib/systemd/system/systemd-random-seed.service\n#  SPDX-License-Identifier: LGPL-2.1-or-later\n#\n#  This file is part of systemd.\n#\n#  systemd is free software; you can redistribute it and/or modify it\n#  under the terms of the GNU Lesser General Public License as published by\n#  the Free Software Foundation; either version 2.1 of the License, or\n#  (at your option) any later version.\n\n[Unit]\nDescription=Load/Save Random Seed\nDocumentation=man:systemd-random-seed.service(8) man:random(4)\nDefaultDependencies=no\nRequiresMountsFor=/var/lib/systemd/random-seed\nConflicts=shutdown.target\nAfter=systemd-remount-fs.service\nBefore=first-boot-complete.target shutdown.target\nWants=first-boot-complete.target\nConditionVirtualization=!container\nConditionPathExists=!/etc/initrd-release\n\n[Service]\nType=oneshot\nRemainAfterExit=yes\nExecStart=/lib/systemd/systemd-random-seed load\nExecStop=/lib/systemd/systemd-random-seed save\n\n# This service waits until the kernel's entropy pool is initialized, and may be\n# used as ordering barrier for service that require an initialized entropy\n# pool. Since initialization can take a while on entropy-starved systems, let's\n# increase the timeout substantially here.\nTimeoutSec=10min\nAquesta informació ens mostra la configuració de la unitat, incloent la descripció, la documentació, les dependències, les condicions, el tipus de servei, els comandaments d’inici i parada, i altres opcions de configuració. El servei té una dependència de muntatge per a /var/lib/systemd/random-seed, i s’executa després de systemd-remount-fs.service i abans de first-boot-complete.target i shutdown.target. A més, ens indica que és un servei de tipus oneshot, que s’executa una sola vegada i roman actiu després de la sortida. Els comandaments d’inici i parada són /lib/systemd/systemd-random-seed load i /lib/systemd/systemd-random-seed save, respectivament.\n\n\n\n\n\n\nNotaNota\n\n\n\nSi observeu el paramètre TimeoutSec=10min aquesta unitat pot trigar fins a 10 minuts a carregar. Si el sistema està en un entorn amb poca entropia, aquesta unitat pot trigar més temps a carregar.\n\n\nPer exemple, editarem la unitat systemd-random-seed.service per activar la entropia al sistema. Per editar la unitat podeu utilitzar qualsevol editor de text ( i.e vi) o bé la comanda systemctl edit systemd-random-seed.service que obrirà un editor de text per afegir la línia. Un cop obert l’editor heu d’afegir la lína a la secció [Service] i desar el fitxer. Recordeu que per fer aquesta acció necessitareu permisos d’administrador. Per tant, su - per canviar a l’usuari root i després fer la comanda.\nEnvironment=SYSTEMD_RANDOM_SEED_CREDIT=4096\n\nCompte! Si feu anar el systemctl edit aquest crearà un fitxer de configuració a /etc/systemd/system/systemd-random-seed.service.d/override.conf que sobreescriurà la configuració de la unitat original. Per afegir la configuració còpieu la configuració original i afegiu la línia Environment=SYSTEMD_RANDOM_SEED_CREDIT=4096 a la secció [Service].\n\nEstem assignant un crèdit de 4096 a la llavor aleatòria. Això augmentarà la quantitat d’entropia que es passa al nucli quan s’escriu la llavor. Un crèdit més alt pot augmentar la seguretat del sistema, però també pot augmentar el temps d’arrencada en sistemes amb poca entropia.\nUn cop hàgim fet els canvis, guardarem el fitxer i sortirem de l’editor. Després, podem fer un reboot per aplicar els canvis. Quan el sistema s’hagi reiniciat, podem tornar a utilitzar la comanda systemd-analyze per comprovar si els canvis han tingut algun impacte en el temps d’arrencada del sistema.\nUna altra opció interesant que ens ofereix systemd és la comanda systemd-analyze critical-chain. Aquesta comanda ens permet veure la cadena crítica de les unitats de temps del sistema. Això ens mostra quines unitats són les més crítiques per al temps d’arrencada del sistema. Per analizar la sortida, heu de mirar el temps després del caràcter @ per veure quant temps ha trigat la unitat a activar-se o iniciar-se, i el temps després del caràcter + per veure quant temps ha trigat la unitat a iniciar-se. A més, aquesta comanda només mostra el temps que les unitats han passat a l’estat activant-se, i no cobreix les unitats que mai han passat per l’estat activant-se (com les unitats de dispositius que passen directament de inactiu a actiu). Tot i això, és una eina útil per identificar les unitats que poden estar retardant el procés d’arrencada.\ngraphical.target @2.076s\n└─multi-user.target @2.075s\n  └─ssh.service @1.497s +578ms\n    └─network.target @1.494s\n      └─networking.service @1.225s +268ms\n        └─apparmor.service @1.158s +63ms\n          └─local-fs.target @1.158s\n            └─run-credentials-systemd\\x2dtmpfiles\\x2dsetup.service.mount @1.171s\n              └─local-fs-pre.target @242ms\n                └─systemd-tmpfiles-setup-dev.service @224ms +17ms\n                  └─systemd-sysusers.service @192ms +20ms\n                    └─systemd-remount-fs.service @131ms +54ms\n                      └─systemd-journald.socket @114ms\n                        └─-.mount @86ms\n                          └─-.slice @86ms\nEn aquest cas, podem veure que la unitat ssh.service és la més crítica per al temps d’arrencada del sistema, ja que ha trigat 578ms a iniciar-se. A més, podem veure les dependències de totes les unitats que s’han carregat durant el procés d’arrencada. Començant pel graphical.target i seguint per les unitats multi-user.target, aquestes dos unitats ens asseguren que el sistema ha arrencat en mode gràfic i multiusuari. A partir d’aquest moment es carreguen la resta de serveis.\nUn altra opció interessant és utilitzar la comanda systemd-analyze plot per generar un gràfic del procés d’arrencada del sistema. Aquesta comanda generarà un fitxer SVG amb el gràfic del procés d’arrencada, que podeu visualitzar amb un navegador web o un visor d’imatges.\n\nSi volem analitzar tots les unitats:\nsystemd-analyze plot &gt; boot_system.svg\nSi volem analitzar les unitats de la instancia de l’usuari:\nsystemd-analyze --user plot &gt; boot_user.svg\nSi volem les unitats de l’arrencada del sistema:\nsystemd-analyze --system plot &gt; boot_system.svg\n\n\n\n⚠️ Compte: Com puc visualtizar una imatge SVG en un debian sense interfície gràfica?\nPer visualitzar una imatge SVG en un sistema sense interfície gràfica, podeu descarregar el fitxer SVG a la vostra màquina local i visualitzar-lo amb un visor d’imatges o un navegador web. Per exemple, podeu utilitzar la comanda scp per descarregar el fitxer SVG a la vostra màquina local:\nscp user@remote:/path/to/boot.svg /path/to/local/boot.svg\n\n\n\n⚠️ Compte: Debian no permet conexions remotes com a root per defecte. Abans de fer-ho, com debian per defecte no permet l’execució de scp com a root, caldrà fer-ho com a usuari normal i després copiar el fitxer a la carpeta desitjada.\nmv boot.svg /tmp \nchown user:user /tmp/boot.svg  \n\nPer a més informació sobre les opcions de la comanda systemd-analyze, podeu consultar el manual amb la comanda man systemd-analyze.\nPer acabar, podem comentar que així com systemctl status unitat ens mostra la informació d’una unitat. També podem consultar la informació de totes les unitats amb:\n\nsystemctl status: Mostra informació sobre l’estat actual del sistema o d’una unitat específica acompanyada de les dades més recents del registre del diari.\nsystemctl list-units: Mostra una llista de totes les unitats carregades al sistema, incloent les unitats actives, inactives i fallades.",
    "crumbs": [
      "Activitats",
      "Unitat 02 · Arrencada del sistema",
      "Activitat 6 · Anàlisi del procés d'arrencada amb systemd"
    ]
  },
  {
    "objectID": "exercises/02-booting/07-ex-week4.html",
    "href": "exercises/02-booting/07-ex-week4.html",
    "title": "Servei de Còpia de Seguretat Automàtica amb systemd",
    "section": "",
    "text": "Aprendre a crear un servei bàsic amb systemd.\nConfigurar un servei que s’executi a l’inici del sistema.\nEntendre els fitxers d’unitat de systemd i com gestionar-los.\nCrear un script senzill per realitzar una còpia de seguretat de la carpeta /home i desar-lo a /backup.",
    "crumbs": [
      "Activitats",
      "Unitat 02 · Arrencada del sistema",
      "Activitat 7 · Servei de Còpia de Seguretat Automàtica amb systemd"
    ]
  },
  {
    "objectID": "exercises/02-booting/07-ex-week4.html#objectius",
    "href": "exercises/02-booting/07-ex-week4.html#objectius",
    "title": "Servei de Còpia de Seguretat Automàtica amb systemd",
    "section": "",
    "text": "Aprendre a crear un servei bàsic amb systemd.\nConfigurar un servei que s’executi a l’inici del sistema.\nEntendre els fitxers d’unitat de systemd i com gestionar-los.\nCrear un script senzill per realitzar una còpia de seguretat de la carpeta /home i desar-lo a /backup.",
    "crumbs": [
      "Activitats",
      "Unitat 02 · Arrencada del sistema",
      "Activitat 7 · Servei de Còpia de Seguretat Automàtica amb systemd"
    ]
  },
  {
    "objectID": "exercises/02-booting/07-ex-week4.html#requeriments-previs",
    "href": "exercises/02-booting/07-ex-week4.html#requeriments-previs",
    "title": "Servei de Còpia de Seguretat Automàtica amb systemd",
    "section": "Requeriments Previs",
    "text": "Requeriments Previs\n\nTenir una màquina virtual (MV) amb Debian instal·lat.\nTotes les comandes s’han d’executar amb permisos de superusuari (root). Per tant, su -.\nRealitzar un apt update -y && apt upgrade -y per assegurar-se que el sistema està actualitzat.\nInstal·lar el paquet vim per editar fitxers: apt install vim -y.\nCrear la carpeta /backup on es desaran les còpies de seguretat: mkdir -p /backup.",
    "crumbs": [
      "Activitats",
      "Unitat 02 · Arrencada del sistema",
      "Activitat 7 · Servei de Còpia de Seguretat Automàtica amb systemd"
    ]
  },
  {
    "objectID": "exercises/02-booting/07-ex-week4.html#servei-bàsic-amb-systemd",
    "href": "exercises/02-booting/07-ex-week4.html#servei-bàsic-amb-systemd",
    "title": "Servei de Còpia de Seguretat Automàtica amb systemd",
    "section": "Servei bàsic amb systemd",
    "text": "Servei bàsic amb systemd\n\nCrearem un script que farà la còpia de seguretat de la carpeta /home, per fer-ho simplement crearem un arxiu .tar.gz amb la data i hora actual al nom de l’arxiu. Aquest arxiu es desarà a la carpeta /backup que hem creat anteriorment. El script es col·locarà a /usr/local/bin/backup.sh.\n#!/bin/bash\ntar -czf /backup/system_backup_$(date +%Y%m%d_%H%M%S).tar.gz /home\nConfigurarem un servei que faci una còpia de seguretat cada cop que s’iniciï el sistema. Crearem un fitxer de servei a /etc/systemd/system/backup.service.\n[Unit]\nDescription=Backup Service\nAfter=network.target\n\n[Service]\nType=oneshot\nExecStart=/usr/local/bin/backup.sh\n\n[Install]\nWantedBy=multi-user.target\n\n\n\n\n\n\n\nNota\n\n\n\nEl target multi-user.target s’utilitza perquè el servei s’executi quan el sistema està en mode multiusuari, és a dir, quan la majoria dels serveis del sistema ja estan en funcionament.\n\n\n\nActivarem el servei perquè s’executi a l’inici del sistema amb la comanda:\nsystemctl start backup.service\nComprova l’estat del servei amb:\nsystemctl status backup.service\n\n\n\n\n\n\n\nImportant\n\n\n\nEl servei no s’ha arrancat degut a errors en l’script. Revisa el fitxer de registre amb journalctl -xeu backup.service per veure els errors i corregir-los. On xeu indica que volem veure els missatges d’error i advertència filtrant per unitat. El error que observareu és que el script no té permisos d’execució. Per solucionar-ho, simplement afegiu permisos d’execució a l’script amb chmod +x /usr/local/bin/backup.sh i torneu a iniciar el servei amb systemctl restart backup.service.\n\n\n\nComprovarem el contigut de la carpeta /backup. Un cop el servei s’hagi executat correctament, hauríeu de veure un fitxer de còpia de seguretat amb la data actual al nom del fitxer.\nls -lh /backup\nActivarem el servei perquè s’executi a l’inici del sistema amb la comanda:\nsystemctl enable backup.service\nFinalment, reiniciarem el sistema per assegurar-nos que el servei s’executa correctament a l’inici:\nreboot\nDesprés de reiniciar, comprova que el fitxer de còpia de seguretat s’ha creat correctament a la carpeta /backup:\nls -lh /backup",
    "crumbs": [
      "Activitats",
      "Unitat 02 · Arrencada del sistema",
      "Activitat 7 · Servei de Còpia de Seguretat Automàtica amb systemd"
    ]
  },
  {
    "objectID": "exercises/02-booting/07-ex-week4.html#servei-amb-timer-amb-systemd",
    "href": "exercises/02-booting/07-ex-week4.html#servei-amb-timer-amb-systemd",
    "title": "Servei de Còpia de Seguretat Automàtica amb systemd",
    "section": "Servei amb Timer amb systemd",
    "text": "Servei amb Timer amb systemd\nEl servei que hem creat anteriorment s’executa només una vegada a l’inici del sistema. Ara crearem un servei que s’executi diàriament a una hora específica utilitzant un timer de systemd. El primer pas és crear el servei que volem executar periòdicament, en aquest cas, el mateix script de còpia de seguretat que hem creat abans. El segon pas és crear un fitxer de timer que programi l’execució del servei.\n\nCrearem un fitxer de timer a /etc/systemd/system/backup-daily.timer per programar l’execució del servei diàriament a les 2:00 AM.\n[Unit]\nDescription=Runs backup-daily.service daily at 2:00 AM\nRequires=backup-daily.service\n\n[Timer]\nOnCalendar=*-*-* 02:00:00\nPersistent=true\n\n[Install]\nWantedBy=timers.target\non el camp OnCalendar, *-*-* 02:00:00 indica que el servei s’executarà diàriament a les 2:00 AM. La línia Persistent=true assegura que si el sistema està apagat a l’hora programada, el servei s’executarà tan aviat com el sistema s’iniciï. El *-*-* és un comodí que representa qualsevol any, mes i dia.\nCrearem el fitxer de servei a /etc/systemd/system/backup-daily.service que serà el que s’executarà diàriament.\n[Unit]\nDescription=Daily Backup Service\n\n[Service]\nType=oneshot\nExecStart=/usr/local/bin/backup.sh\nActivarem el timer perquè s’executi diàriament amb la comanda:\nsystemctl enable --now backup-daily.timer\n\n\n\n\n\n\n\nImportant\n\n\n\nL’argument --now activa el timer immediatament després d’habilitar-lo, de manera que no cal reiniciar el sistema per començar a utilitzar-lo.\n\n\n\nComprova l’estat del timer amb:\nsystemctl status backup-daily.timer\nPer veure quan s’executarà el proper cop el servei, utilitza la comanda:\nsystemctl list-timers --all\nPer provar que el servei funciona correctament, pots forçar l’execució del servei amb la comanda:\nsystemctl start backup-daily.service",
    "crumbs": [
      "Activitats",
      "Unitat 02 · Arrencada del sistema",
      "Activitat 7 · Servei de Còpia de Seguretat Automàtica amb systemd"
    ]
  },
  {
    "objectID": "exercises/02-booting/07-ex-week4.html#exercicis-proposats",
    "href": "exercises/02-booting/07-ex-week4.html#exercicis-proposats",
    "title": "Servei de Còpia de Seguretat Automàtica amb systemd",
    "section": "Exercicis Proposats",
    "text": "Exercicis Proposats\n\nModifica el servei perquè faci una còpia de seguretat de la carpeta /var i /etc en lloc de /home. Un cop fet això, utilitza systemd-analyze i systemd-analyze blame per analitzar el servei abans i després d’activar-lo. Comenta i justifica els resultats obtinguts.\nCrea un servei que permeti actualitzar el sistema automàticament cada diumenge a les 3:00 AM. Aquest servei hauria d’executar apt update && apt upgrade -y.",
    "crumbs": [
      "Activitats",
      "Unitat 02 · Arrencada del sistema",
      "Activitat 7 · Servei de Còpia de Seguretat Automàtica amb systemd"
    ]
  },
  {
    "objectID": "exercises/02-booting/04-ex-week3.html",
    "href": "exercises/02-booting/04-ex-week3.html",
    "title": "Modificant la contrasenya de l’usuari root a través del GRUB",
    "section": "",
    "text": "Entendre com funciona la edició temporal del GRUB.\nEntendre com protegir el GRUB amb una contrasenya.\nEntendre com GRUB pot ser un vector d’accés físic al sistema.",
    "crumbs": [
      "Activitats",
      "Unitat 02 · Arrencada del sistema",
      "Activitat 4 · Modificant la contrasenya de l'usuari root a través del GRUB"
    ]
  },
  {
    "objectID": "exercises/02-booting/04-ex-week3.html#objectiu",
    "href": "exercises/02-booting/04-ex-week3.html#objectiu",
    "title": "Modificant la contrasenya de l’usuari root a través del GRUB",
    "section": "",
    "text": "Entendre com funciona la edició temporal del GRUB.\nEntendre com protegir el GRUB amb una contrasenya.\nEntendre com GRUB pot ser un vector d’accés físic al sistema.",
    "crumbs": [
      "Activitats",
      "Unitat 02 · Arrencada del sistema",
      "Activitat 4 · Modificant la contrasenya de l'usuari root a través del GRUB"
    ]
  },
  {
    "objectID": "exercises/02-booting/04-ex-week3.html#escenari",
    "href": "exercises/02-booting/04-ex-week3.html#escenari",
    "title": "Modificant la contrasenya de l’usuari root a través del GRUB",
    "section": "Escenari",
    "text": "Escenari\nUn atacant amb accés físic al servidor podria modificar la contrasenya de l’usuari root iniciant el sistema des del GRUB. En aquesta pràctica assumirem aquest escenari de manera controlada.",
    "crumbs": [
      "Activitats",
      "Unitat 02 · Arrencada del sistema",
      "Activitat 4 · Modificant la contrasenya de l'usuari root a través del GRUB"
    ]
  },
  {
    "objectID": "exercises/02-booting/04-ex-week3.html#requeriments-previs",
    "href": "exercises/02-booting/04-ex-week3.html#requeriments-previs",
    "title": "Modificant la contrasenya de l’usuari root a través del GRUB",
    "section": "Requeriments previs",
    "text": "Requeriments previs\n\nUna màquina virtual amb Debian 12 amb GRUB com a gestor d’arrencada.",
    "crumbs": [
      "Activitats",
      "Unitat 02 · Arrencada del sistema",
      "Activitat 4 · Modificant la contrasenya de l'usuari root a través del GRUB"
    ]
  },
  {
    "objectID": "exercises/02-booting/04-ex-week3.html#procediment",
    "href": "exercises/02-booting/04-ex-week3.html#procediment",
    "title": "Modificant la contrasenya de l’usuari root a través del GRUB",
    "section": "Procediment",
    "text": "Procediment\n\nAccés al GRUB\n\nReinicia el sistema i accedeix al menú del bootloader GRUB.\nSelecciona la entrada del sistema operatiu i prem e per editar-la.\n\nModificació de la línia del kernel\n\nLocalitza la línia que comença amb linux i acaba amb ro.\nAfageix init=/bin/bash al final.\nAquesta opció indica al kernel iniciar directament un shell sense passar pel procés d’inicialització normal.\n\n\n\n\n\n\n\n\nNotainit=/bin/bash\n\n\n\nAquesta opció fa que el sistema arranqui directament en un shell de bash com a root, evitant els processos d’inicialització habituals. Tots els serveis systemd i altres processos no s’inicien, i el sistema es troba en un estat mínim, amb només el shell disponible.\n\n\n\nInici amb les opcions modificades\n\nPrem Ctrl + X per iniciar el sistema amb aquesta configuració.\nAccediràs a un prompt de bash amb permisos de root.\n\nMuntar el sistema de fitxers en mode escriptura\nmount -o remount,rw /\n\n\n\n\n\n\n\nNotamount -o remount,rw /\n\n\n\nCom alternativa, es pot editar la línia del kernel per canviar ro (read-only) a rw (read-write). Això permetrà que el sistema de fitxers es monti en mode escriptura des del principi, evitant la necessitat de remuntar-lo més tard.\n\n\n\nAccedir a l’arrel amb chroot\nchroot /\n\n\n\n\n\n\n\nNotachroot\n\n\n\nUna chroot (change root) és una operació que canvia el directori arrel aparent d’un procés i els seus fills a un directori especificat. Això crea un entorn aïllat on el procés veu el directori especificat com la seva arrel (/), permetent executar processos en un sistema de fitxers diferent sense afectar el sistema principal.\n\n\n\nCanviar la contrasenya de root\npasswd\n\nIntrodueix la nova contrasenya quan se’t demani.\n\nSincronitzar els canvis i reiniciar\nexit \nreboot\n\n\n\n\n\n\n\nNotaSolcució si reboot no funciona\n\n\n\nSi el sistema no respon a la comanda reboot, pots forçar un reinici físic de la màquina virtual.\n\n\n\nIniciar sessió amb l’usuari normal.\nCanviar a l’usuari root amb la nova contrasenya. su -",
    "crumbs": [
      "Activitats",
      "Unitat 02 · Arrencada del sistema",
      "Activitat 4 · Modificant la contrasenya de l'usuari root a través del GRUB"
    ]
  },
  {
    "objectID": "exercises/02-booting/04-ex-week3.html#protecció-del-grub",
    "href": "exercises/02-booting/04-ex-week3.html#protecció-del-grub",
    "title": "Modificant la contrasenya de l’usuari root a través del GRUB",
    "section": "Protecció del GRUB",
    "text": "Protecció del GRUB\nPer protegir el GRUB i evitar que un atacant amb accés físic pugui modificar les opcions d’arrencada, es pot configurar una contrasenya per al GRUB.\n\nGenerar una contrasenya xifrada\n\nUtilitza la comanda següent per generar una contrasenya xifrada:\ngrub-mkpasswd-pbkdf2\nIntrodueix la contrasenya desitjada i copia la sortida que comença amb pbkdf2.\n\nEditar la configuració del GRUB\n\nObre el fitxer de configuració del GRUB:\n# Com a root\nvi /etc/grub.d/40_custom\nAfegeix les línies següents al fitxer, substituint your_encrypted_password per la contrasenya xifrada que has generat:\nset superusers=\"root\"\npassword_pbkdf2 root your_encrypted_password\n\nActualitzar la configuració del GRUB\n\nDesprés d’haver editat el fitxer, actualitza la configuració del GRUB:\nupdate-grub    # Debian/Ubuntu\ngrub2-mkconfig -o /boot/grub2/grub.cfg  # Alma/Rocky (BIOS)\ngrub2-mkconfig -o /boot/efi/EFI/almalinux/grub.cfg  # Alma/Rocky (UEFI)\n\nReiniciar el sistema\n ```bash\n reboot\n ```\nVerificar la protecció del GRUB\n\nDurant l’arrencada, intenta editar una entrada del GRUB. Hauries de ser sol·licitat per una contrasenya.\n\n\n\n\n\n\n\n\nImportant👁️ Observació\n\n\n\nMalgrat l’ús d’una contrasenya per a protegir el GRUB, aquesta tècnica no és infal·lible. Un atacant amb accés físic pot montar un usb bootable i iniciar el sistema amb aquest dispositiu. Un cop iniciat el sistema, l’atacant podria montar el sistema de fitxers i modificar la contrasenya de l’usuari root. Ara bé, es podria configurar el BIOS o UEFI per a desactivar l’arrencada des de dispositius externs com els USBs. Això dificultaria l’accés no autoritzat al sistema a través d’aquesta tècnica.",
    "crumbs": [
      "Activitats",
      "Unitat 02 · Arrencada del sistema",
      "Activitat 4 · Modificant la contrasenya de l'usuari root a través del GRUB"
    ]
  },
  {
    "objectID": "exercises/02-booting/04-ex-week3.html#reflexions",
    "href": "exercises/02-booting/04-ex-week3.html#reflexions",
    "title": "Modificant la contrasenya de l’usuari root a través del GRUB",
    "section": "Reflexions",
    "text": "Reflexions\n\nControl físic del servidor: Limitar l’accés físic és essencial.\nDesactivar arrencada des de dispositius externs: Configurar BIOS/UEFI per bloquejar USB/CD.\nAmb LUKS/dm-crypt, encara que l’atacant accedeixi físicament al GRUB, no podrà llegir ni modificar les dades sense la clau.\nUEFI Secure Boot: Si està activat i el GRUB està signat, no es podrà iniciar amb init=/bin/bash sense desactivar temporalment Secure Boot.",
    "crumbs": [
      "Activitats",
      "Unitat 02 · Arrencada del sistema",
      "Activitat 4 · Modificant la contrasenya de l'usuari root a través del GRUB"
    ]
  }
]