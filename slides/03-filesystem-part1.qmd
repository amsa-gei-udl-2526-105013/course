---
title: "Sistema de fitxers (I)"
subtitle: "Unitat 3 ¬∑ Administraci√≥ i Manteniment de Sistemes i Aplicacions (AMSA)"
author: "Jordi Mateo Forn√©s"
logo: "/figs/corporative/institute.png"
format: 
  revealjs:
    transition: fade
    slide-number: true
    incremental: true 
    chalkboard: false
    css: styles.css
    footer: "Unitat 3 ¬∑ Administraci√≥ i Manteniment de Sistemes i Aplicacions (AMSA) [üè†](/index.html)</a>"
editor: visual

execute:
  freeze: auto
  echo: false
---

# Introducci√≥

## Necessitat d'un Sistema de Fitxers (I)

La implementaci√≥ d'un **Sistema de Fitxers (FS)** √©s essencial per a l'organitzaci√≥, emmagatzematge i recuperaci√≥ eficient de la informaci√≥ en qualsevol sistema operatiu modern.

::: {.callout-warning title="Observaci√≥"}
En els sistemes operatius moderns (*UNIX-like*), el seu rol s'est√©n molt m√©s enll√† de la gesti√≥ de dades persistents al disc, abracant una filosofia fonamental.
:::

::: {.center-container}
**Everything is a File**
:::

## Necessitat d'un Sistema de Fitxers (II) {.smaller}

| Tipus de Recurs | Exemple de Path | Sistema de Fitxers | Caracter√≠stica |
| :--- | :--- | :--- |
| **Proc√©s/Estat del Kernel** | `/proc/PID` (p. ex., `/proc/1234/status`) | `procfs` (Mem√≤ria, no disc) |
| **Dispositiu de Blocs** | `/dev/sda1` | `devfs` o `udev` |
| **Punts de Configuraci√≥** | `/etc/hosts`, `/usr/bin/comando` | FS persistent (Ext4, XFS) |
| **Dades d'Usuari** | `/home/username/documents` | FS persistent |
| **Xarxa** | `/dev/tcp/80` (en certs entorns, e.g., Plan 9) | √ös de *Sockets* com a *File Descriptors* |

::: {.callout-note title="Avantatge"}
La implementaci√≥ d'un sistema de fitxers permet unificar l'acc√©s a recursos heterogenis. El kernel pot tractar una E/S a `/dev/sda1` (blocs f√≠sics) i una E/S a `/proc/cpuinfo` (informaci√≥ virtual) utilitzant la **mateixa API**. API.
:::

## Dispositius i Device Files {.smaller}

Un Fitxer de Dispositiu (*Device File o Node*) √©s un nom assignat a un dispositiu d'E/S (Entrada/Sortida), ja sigui **f√≠sic** (disc, targeta de so) o **l√≤gic** (port de xarxa, terminal). 

| Tipus de Dispositiu | Exemples Comuns | Caracter√≠stica |
| :--- | :--- | :--- |
| Blocs (Block Devices) | `/dev/sda` (Disc sencer), `/dev/sdb1` (Partici√≥), `/dev/md0` (RAID) | Transfereixen dades en blocs de mida fixa. S√≥n cachejables i permeten acc√©s aleatori. |
| Car√†cters (Character Devices) | `/dev/ttyX` (Terminals), `/dev/lp0` (Port Paral¬∑lel), `/dev/input/mouse0` | Transfereixen dades seq√ºencialment car√†cter a car√†cter. No tenen caching de blocs. |

Els **drivers** √©s el conjunt de rutines del kernel que defineix com s'ha de dur a terme la comunicaci√≥ espec√≠fica amb el Hardware mitjan√ßant **interrupcions**, **acc√©s directe a mem√≤ria (DMA)** i **E/S programada**. Sense el driver, el fitxer a `/dev` seria in√∫til.

# Abstraccions B√†siques del VFS

## Virtual Filesystem Switch (VFS) {.smaller}

Un **Sistema de Fitxers (FS)** √©s la capa l√≤gica fonamental que gestiona l'acc√©s i l'organitzaci√≥ dels objectes (fitxers i directoris) sobre un dispositiu d'emmagatzematge.

::: {.callout-note title="M√∫ltiples FS actius"}
√âs habitual que un sistema operatiu gestioni simult√†niament diverses inst√†ncies de sistemes de fitxers diferents:

- **Ext4** per a dades d'usuari (`/home`)
- **Btrfs** per a backups autom√†tics
- **tmpfs** per a fitxers temporals (`/tmp`)
- **procfs** per a informaci√≥ del kernel (`/proc`)

Cadascun muntat en un punt d'acc√©s l√≤gic diferent.
:::

## Abstraccions Comunes del VFS {.smaller}

Tot i les difer√®ncies estructurals a nivell de disc, el **VFS (Virtual Filesystem Switch)** del *kernel* utilitza abstraccions uniformes per oferir una interf√≠cie consistent als processos.

| Abstracci√≥ | Ubicaci√≥ | Funci√≥ T√®cnica | Persist√®ncia |
|:-|:--|:----|:-|
| **Superbloc** | Disc + Mem√≤ria | Cont√© **metadata global** del FS: tipus, mida, estat, punters clau | Persistent |
| **Inode** | Disc + Mem√≤ria | **Metadata del fitxer**: permisos, timestamps, punters a blocs de dades | Persistent |
| **Dentry** | Nom√©s Mem√≤ria | **Entrada de Directori**: cacheja nom del fitxer ‚Üî inode | Temporal |
| **File Object** | Nom√©s Mem√≤ria | Representa un fitxer obert per un proc√©s (file descriptors) | Temporal |

Permet que un programa pugui treballar amb fitxers *Ext4, XFS, NTFS o FAT32* sense modificar ni una sola l√≠nia de codi.


## Jerarquia L√≤gica de les Abstraccions {.smaller}

Per entendre com el *kernel* mapeja un nom de fitxer a les dades, visualitzem la interacci√≥ entre les estructures *in-memory* i *on-disk*.

```{mermaid}
%%| echo: false
classDiagram
    direction LR
    
    class Superbloc {
        <<On-Disk i In-Memory>>
        + Tipus FS (Ext4, XFS)
        + Mida del Volum
        + Punter a llistes d'Inodes Lliures
    }

    class Inode {
        <<On-Disk i In-Memory>>
        + Num Inode √önic
        + Pointers a Blocs de Dades
        + Permisos/ACLs
        + UID/GID, Timestamps
    }

    class Dentry {
        <<In-Memory Cache>>
        + Nom del Fitxer/Directori
        + Punter a Inode
        + Punter al Dentry Pare
    }

    class FileObject {
        <<In-Memory>>
        + File Descriptor FD
        + Offset de Lectura/Escriptura Actual
        + Punter a Dentry (Path)
    }

    Superbloc "1" --> "*" Inode : Gestiona
    Dentry "1" --> "1" Inode : Caching ¬∑ Nom -> Metadata
    FileObject "1" --> "1" Dentry : Resoluci√≥ de Path
    Inode "1" --> "*" DataBlocks : Adre√ßament
    
    %% Colors per a claredat t√®cnica
    classDef memory fill:#eaf7ff,stroke:#007bff
    classDef disk fill:#f9f5dd,stroke:#c4aa18
    class Dentry
    FileObject memory
    class Inode
    Superbloc disk
```

::: {.callout-warning title="Impacte del Dentry"}
Una `Dentry Cache` saturada o poc eficient pot degradar significativament el rendiment del sistema (**I/O latency**), ja que el kernel es veu for√ßat a re-llegir l'estructura de directoris directament del disc.
:::

::: notes
- FileObject: Un proc√©s obre un fitxer, creant un FileObject amb un File Descriptor.
- Dentry (Cache): El FileObject resol el cam√≠ a trav√©s d'una cadena de Dentries (des de la muntura fins al fitxer final). El Dentry proporciona l'associaci√≥ Nom ‚Üí Inode.
- Inode: El n√∫mero d'Inode permet al VFS carregar les metadades on-disk a mem√≤ria. Aquesta estructura cont√© els punters directes i indirectes als blocs de dades.
:::

## Relacions *In-Memory* del VFS {.smaller}

- M√∫ltiples descriptors de fitxer poden apuntar al mateix fitxer (`dup()`).
- M√∫ltiples abstraccions de fitxer poden apuntar a la mateixa `Dentry` (obrim el mateix *path* diverses vegades).
- M√∫ltiples `Dentries` poden apuntar al mateix `Inode` (Hard Links).

![](../figs/slides/03-fs/vfs-in-memory.png){width=60%}


## El Superbloc

El **Superbloc** √©s el punt de refer√®ncia absolut de qualsevol Sistema de Fitxers (FS). Sense aquesta estructura, el *kernel* no pot ni tan sols intentar muntar el volum.

::: { .callout-important title="Av√≠s"}
Si el **Superbloc** es corromp (per un error de disc o d'E/S), el sistema de fitxers esdev√© **inaccessible** fins que es restaura una de les seves c√≤pies de seguretat (*backup copies*).
:::

Per aquest motiu, els FS moderns mantenen **m√∫ltiples c√≤pies** del superbloc distribu√Ødes pel volum.

## Organitzaci√≥ F√≠sica del Superbloc {.smaller}

![](../figs/slides/03-fs/superblocs.png){width=70%}

::: notes
El diagrama mostra que el superbloc es troba t√≠picament a l'inici del sistema de fitxers i que hi ha diversos blocs utilitzats amb diferents prop√≤sits: alguns per emmagatzemar dentries, alguns per emmagatzemar inodes i alguns per emmagatzemar blocs de dades d'usuari. Tamb√© hi ha blocs utilitzats per gestionar els blocs lliures disponibles (p. ex., mapes de bits per als sistemes de fitxers simples).
:::


## Abstraccions del Superbloc {.smaller}

| Component | Funci√≥ | Ubicaci√≥ |
| :- | :---- | :-- |
| **Superbloc** | Cont√© la metadata global del FS: tipus, mida, estat, i punters clau. | Inici del FS (i c√≤pies de seguretat). |
| **IMAP (Inode Map)** | Bitmap per a l'assignaci√≥ i desassignaci√≥ d'Inodes. Indica quins Inodes estan lliures o en √∫s dins de la IZONE. | Bloc(s) assignat(s) pel Superbloc. |
| **DMAP (Data Map)** | Bitmap per a l'assignaci√≥ i desassignaci√≥ de Blocs de Dades. Indica quins blocs de la DZONE estan lliures o en √∫s. | Bloc(s) assignat(s) pel Superbloc. |
| **IZONE** | √Ärea que cont√© les estructures d'Inode dels fitxers. | Despr√©s dels mapes. |
| **DZONE** | √Ärea que cont√© les dades d'usuari (el contingut real dels fitxers). | Despr√©s de la IZONE. |


## Estructura i Implementaci√≥ del Superbloc {.smaller}

El Superbloc no nom√©s s'autodefineix, sin√≥ que defineix l'arquitectura de tota la partici√≥:

* **`fs_type`**: El tipus de FS (p. ex., EXT4\_MAGIC).
* **`s_blocks_count`**: El nombre total de blocs al FS.
* **`s_log_block_size`**: Defineix la mida del bloc l√≤gic (p. ex., 1K, 4K). **Tota la I/O es fa en aquesta unitat.**
* **Punters a Bitmaps**: Adreces del primer bloc de l'**IMAP** i el **DMAP**.
* **Estat del FS**: Indica si el FS va ser desmuntat netament o si va patir un *crash* (`s_state` - important per al *fsck*).

## Mapes de Bits (Bitmaps) {.smaller}

Els mapes de bits s√≥n crucials per a l'efici√®ncia en l'assignaci√≥:

1.  **IMAP (Inode Bitmap):** Cada bit representa l'estat d'un √∫nic Inode a la IZONE. `1` = En √∫s, `0` = Lliure.
2.  **DMAP (Data Bitmap):** Cada bit representa l'estat d'un √∫nic bloc a la DZONE. `1` = Ocupat per dades, `0` = Lliure per assignaci√≥.

::: { .callout-tip }
#### Optimitzaci√≥ (*Caching*)
Quan el FS es munta, el *kernel* carrega el **Superbloc** i, almenys parcialment, els mapes **IMAP** i **DMAP** a la mem√≤ria. Aix√≤ permet que les noves assignacions de fitxers i blocs siguin extremadament r√†pides sense requerir una E/S de disc constant.
:::

:::{ .callout-note title="FS Grans"}
Es carreguen parcialment i a demanda per no gastar massa mem√≤ria en FS grans.
:::

# Operacions B√†siques del VFS i crides al Sistema

## Mapping: Crides de Sistema ‚Üí VFS {.smaller}

::: columns
::: {.column width="60%"}
| Crida al Sistema | Operaci√≥ VFS | Descripci√≥ |
| :- | :- | :--- |
| `mount()` | `vfs_mount()` | Muntar un FS. |   
| `open()` | `vfs_open()` | Obrir un fitxer (i obtenir un FD). |
| `stat()` / `fstat()` | `vfs_stat()` / `vfs_fstat()` | Consultar atributs del fitxer. |
| `read()` / `write()` | `vfs_read()` / `vfs_write()` | Llegir o escriure dades. |
| `create()` / `delete()` | `vfs_create()` / `vfs_unlink()` | Crear i eliminar fitxers. |
| `close()` | `vfs_close()` | Tancar un fitxer |
:::
::: {.column width="40%"}

El VFS √©s l'abstracci√≥ de Linux que permet gestionar m√∫ltiples tipus de FS (Ext4, XFS, NTFS) de manera transparent. 

```{mermaid}
%%| echo: false
graph TD
    A[Crida al Sistema open, read] --> B{VFS};
    B -->|Operaci√≥ abstracta| C1[Driver FS Espec√≠fic Ext4];
    B -->|Operaci√≥ abstracta| C2[Driver FS Espec√≠fic XFS];
    C1 --> D[Subsistema d'Emmagatzematge E/S];
    C2 --> D;
    
    style B fill:#eaf7ff,stroke:#007bff
    style C1 fill:#f9f5dd,stroke:#c4aa18
    style C2 fill:#f9f5dd,stroke:#c4aa18
```

:::
:::

## Montatge d'un FS {.smaller}

```bash
# Sintaxi: mount -t <fs_type> <device> <mount_point>
mount -t ext4 /dev/nvme0n1p2 /home
mount -t btrfs /dev/sdb1 /backup
mount -t tmpfs -o size=1G tmpfs /tmp/ramdisk
```

| Pas	| Descripci√≥	| Implicaci√≥ |
| :- | :--- | :- |
| 1. *Entrada/Sortida*	| **Input**: Dispositiu de blocs (Partici√≥). **Output**: Dentry arrel del FS.	|  |
| 2. *Check Device*	| Validaci√≥ de l'estructura inicial del FS.	|  |
| 3. *Llegir Superbloc*	| Determinar par√†metres (mida de bloc, magic number). Carregar el Superbloc a mem√≤ria.	| Cr√≠tic: Estableix el context global. |
| 4. *Crear Inode i Dentry*	| Localitzar el Root Inode (e.g., inode 2 a Ext4) i crear l'estructura Dentry arrel a la mem√≤ria.	| Inici de la navegaci√≥ l√≤gica. |


## Obertura d'un Fitxer {.smaller}

```{mermaid}
%%| echo: false
sequenceDiagram 
    participant P as Proc√©s
    participant VFS as VFS (Kernel)
    participant FS as Driver de FS (read_inode)

    P->>VFS: open -> /a/b/fitxer.txt 
    VFS->>VFS: 1. Per cada component a, b, fitxer.txt:
    VFS->>VFS: Resoldre Dentry Pare (Cache)
    VFS->>FS: 2. Carregar Inode si no est√† en cache (via Num. Inode)
    VFS->>VFS: 3. Final: Crear nou **FILE OBJECT**
    VFS->>P: 4. Assignar **File Descriptor** (FD)
```



## Consultar Atributs 

```{mermaid}
%%| echo: false
sequenceDiagram
    participant P as Proc√©s
    participant VFS as VFS (Kernel)
    participant FS as Driver de FS (read_inode)
    P->>VFS: stat -> fitxer.txt o fstat -> FD
    VFS->>VFS: 1. Acc√©s a l'Inode via FD
    VFS->>FS: 2. Si no est√† en cache, llegir Inode del disc
    FS-->>VFS: 3. Retornar Atributs
    VFS-->>P: 4. Retornar Atributs UID, GID, Permisos, Mida, Timestamps
```


## Operacions de Lectura

```{mermaid}
%%| echo: false
sequenceDiagram
    participant P as Proc√©s
    participant VFS as VFS 
    participant FS as Driver de FS ¬∑ read
    P->>VFS: read -> FD, buf, len
    VFS->>VFS: 1. Validar FD i permisos
    VFS->>VFS: 2. Calcular blocs a llegir -> offset, len
    VFS->>FS: 3. Llegir dades file->dentry->inode->data blocks
    FS-->>VFS: 4. Retornar dades a VFS
    VFS-->>P: 5. Copiar dades a l'espai d'usuari
```

## Operacions d'Escriptura 

```{mermaid}
%%| echo: false
sequenceDiagram
    participant P as Proc√©s
    participant VFS as VFS
    participant PC as Page Cache
    participant FS as Driver FS
    participant J as Journal
    participant BD as Block Device

    P->>VFS: write -> fd=5, buffer, 4096
    VFS->>VFS: Validar FD i permisos d'escriptura
    VFS->>VFS: Calcular nous blocs necessaris
    
    alt Fitxer necessita cr√©ixer
        VFS->>FS: Assignar nous blocs de dades
        FS->>FS: Actualizar bitmaps i inode
        FS->>J: Registrar transacci√≥ al journal
    end
    
    VFS->>PC: Escriure dades a la page cache ¬∑ dirty pages
    VFS-->>P: Retornar bytes escrits 
    
    Note over PC,BD: Writeback as√≠ncron 
    PC->>BD: Flush dirty pages al disc
    J->>BD: Commit transacci√≥ journal
```


## Escriptura As√≠ncrona i Writeback {.smaller}

La escriptura as√≠ncrona permet que les operacions d'escriptura es realitzin en segon pla, millorant la resposta del sistema. Les dades es desplacen a la *page cache* i es poden escriure al disc m√©s tard.

- **Dirty Pages:** P√†gines a la mem√≤ria que han estat modificades per√≤ encara no s'han escrit al disc.
- **Writeback:** Proc√©s de transferir les *dirty pages* de la mem√≤ria al disc.
- **Journaling:** Mecanisme per assegurar la integritat del FS en cas de fallada durant el writeback.
- **Flush:** Operaci√≥ per escriure immediatament les *dirty pages* al disc.


## Creaci√≥ de Directoris {.smaller}

```{mermaid}
%%| echo: false
sequenceDiagram
    participant P as Proc√©s
    participant VFS as VFS
    participant FS as Driver de FS ¬∑ mkdir
    P->>VFS: mkdir -> /a/b/novedirectori
    VFS->>VFS: 1. Resoldre Dentry Pare -> /a/b -> Determinar Inode Pare
    VFS->>VFS: 2. Llegir blocs de dades del directori pare ¬∑ Trobar espai per a nova Dentry
    VFS->>FS: 4. Crear nou Inode per al directori
    FS-->>VFS: 5. Retornar Num. Inode
    VFS->>VFS: 6. Afegir Dentry al directori par ¬∑ Escriure els blocs de dades del directori pare modificats
    VFS-->>P: 8. Retornar √®xit o error
```

## Eliminaci√≥ de Fitxers {.smaller}

```{mermaid}
%%| echo: false
sequenceDiagram
    participant P as Proc√©s
    participant VFS as VFS
    participant FS as Driver de FS ¬∑ unlink
    P->>VFS: unlink -> /a/b/fitxer.txt
    VFS->>VFS: 1. Resoldre Dentry Pare -> /a/b -> Determinar Inode Pare
    VFS->>VFS: 2. Llegir blocs de dades del directori pare ¬∑ Trobar i esborrar la Dentry
    VFS->>VFS: 4. Comprovar enlla√ßos -> Si √©s l'√∫ltim enlla√ß, desassignar blocs de dades i blocs d'inode
    VFS->>FS: 6. Actualitzar metadades al disc
    FS-->>VFS: 7. Confirmaci√≥ d'actualitzaci√≥
    VFS-->>P: 8. Retornar √®xit o error
```

## Superbloc i Operacions d'Inode {.smaller}

El **VFS (Virtual Filesystem Switch)** estableix dos conjunts d'operacions que el *driver* de cada Sistema de Fitxers ha d'implementar. Aquests m√®todes permeten al *kernel* interactuar amb les metadades de forma uniforme.

| Operaci√≥ | Funci√≥ T√®cnica | Prop√≤sit |
| :--- | :--- | :--- |
| **`fill_super()`** | Llegeix l'estat global del FS (total/lliure d'Inodes i Blocs). | Inicialitzaci√≥ i muntatge. |
| **`write_super()`** | Persisteix les estad√≠stiques i l'estat actualitzat al disc. | Canvis en l'assignaci√≥. |
| **`put_super()`** | Allibera la mem√≤ria associada a la inst√†ncia del FS. | Desmuntatge (`umount`). |

## Operacions de l'Inode {.smaller}

Malgrat el nom, la majoria d'aquestes operacions tracten amb la gesti√≥ de les **Dentries** i la jerarquia de noms de fitxer (no el contingut de l'Inode en si).

* **Creaci√≥ i Cerca:** `create`, **`lookup`**, `link`, `unlink`.
* **Directori i Enlla√ßos:** `mkdir`, `rmdir`, `symlink`, `readlink`, `rename`.

::: { .callout-note title="Tipus d'Inode"}
Els *drivers* de FS treballen amb dos tipus d'Inode:

1.  **VFS Inode:** Estructura gen√®rica utilitzada pel *kernel*.
2.  **FS Inode:** Estructura interna del *driver* (p. ex., la versi√≥ Ext4 o XFS).
   
El *driver* √©s responsable de la conversi√≥ entre aquestes dues estructures segons sigui necessari.
:::

# Cache i Optimitzacions

## Cache d'Inodes (Icache) {.smaller}

Aquesta *cache* emmagatzema les metadades del fitxer a mem√≤ria (l'estructura de l'Inode), evitant lectures repetitives a la **IZONE** del disc.

* **Estructura:** S'indexa mitjan√ßant una **Taula Hash** (*hash table*).
* **Clau Hash:** Es genera a partir de la tupla **(Superbloc, N√∫mero d'Inode)**.
* **Pol√≠tica:** Els Inodes es mantenen fins que el FS es desmunta, s'elimina el fitxer, o hi ha pressi√≥ de mem√≤ria (*memory pressure*).

## Cache de Dentries {.smaller}

La Dcache √©s l'eina m√©s important per a la resoluci√≥ r√†pida de camins (*path lookup*). **Cacheja la relaci√≥ Nom $\rightarrow$ Inode.**

| Estat de la Dentry | Implicaci√≥ T√®cnica |
| :- | :--- |
| **`Used`** | L'objecte est√† en √∫s (p. ex., associat a un `FILE Objecte`). El seu `d_inode` √©s v√†lid. |
| **`Unused`** | El `d_inode` √©s v√†lid, per√≤ l'objecte Dentry no est√† sent utilitzat activament per cap proc√©s. |
| **`Negative`** | L'`d_inode` no √©s v√†lid. S'utilitza per recordar que un fitxer **no existeix** o ha estat eliminat, evitant cerques futures innecess√†ries al disc. |

::: { .callout-tip title="Optimitzaci√≥ de la Dentry Cache"}
L'acc√©s a l'Inode *cache* (per al seu alliberament en condicions de mem√≤ria baixa) utilitza l'estat d'√∫s, basat en el Superbloc i el n√∫mero d'Inode. La Dentry *cache* tamb√© fa servir taules hash per a cerques ultra-r√†pides.
:::

## Cache de p√†gines: Dades i E/S {.smaller}

La **Cache de p√†gines** √©s el mecanisme principal del *kernel* per a la gesti√≥ de dades d'E/S, utilitzat per tots els sistemes de fitxers. Emmagatzema els blocs de dades del fitxer a la mem√≤ria del sistema,per a la lectura r√†pida i per a l'escriptura diferida.

:::{.callout-important title="Gesti√≥ de Mem√≤ria"}
Linux reutilitza la mem√≤ria lliure com a cache, per√≤ l‚Äôallibera quan un proc√©s necessita RAM.
:::

* **Dades Cachejades:** Nom√©s dades de fitxers, no metadades de nivell de bloc (*block device data*).
* **Mecanismes d'E/S:** Suporta operacions `read()`, `write()` i **`mmap()`** (mapes de mem√≤ria).

::: { .callout-warning title="Estructura Interna: R√†dix-Arbre" }
La **Cache de p√†gines** utilitza una estructura de dades Radix Tree per mapejar de manera eficient els offsets de fitxer a les p√†gines de mem√≤ria. Aix√≤ permet acc√©s r√†pid a p√†gines de dades grans.
:::

# Sistemes de Fitxers Espec√≠fics

## FAT: File Allocation Table {.smaller}

- Sistema de fitxers creat el 1977 i popularitzat gr√†cies a MS-DOS.
- Encara popular avui (FAT32): USB, targetes de mem√≤ria, partici√≥ d'arrencada EFI.
- **File Allocation Table**: Estructura de llista enlla√ßada que cont√© informaci√≥ sobre els blocs ocupats per cada fitxer.
- Tamb√© determina si un bloc est√† en √∫s o no.

![](../figs/slides/03-fs/FAT.png){width=60%}

## FAT: Organitzaci√≥ de Directoris {.smaller}

Els directoris en FAT s√≥n fitxers especials que contenen entrades de **32 bytes per a cada fitxer o subdirectori**. Cada entrada inclou: *nom, atributs, timestamps, primer cl√∫ster i mida del fitxer*.

| Nom | Index | Dir? | Permisos |
| :--- | :---: | :---: | :---: |
| `.` | 2 | S√≠ | rwx |
| `Windows` | 3 | S√≠ | rwx |
| `Users` | 4 | S√≠ | rwx |
| `pagefile.sys` | 5 | No | r-- |

El superbloc actua com a punt de refer√®ncia per a tot el sistema de fitxers, emmagatzemant informaci√≥ cr√≠tica com la mida del cl√∫ster, la ubicaci√≥ de la FAT i la ubicaci√≥ del directori arrel.

## FAT: Limitacions T√®cniques {.smaller}

**Limitacions de capacitat:**

- **FAT32**: m√†xim 2TB per volum
- **FAT32**: m√†xim 4GB per fitxer

**Problemes de rendiment:**

- Localitzaci√≥ de blocs lliures: **scan complet** de la FAT
- Fragmentaci√≥ severa (pobra localitat)
- Fragmentaci√≥ de metadata: cerques costoses
- Llistes enlla√ßades ineficients per fitxers grans

**Impacte pr√†ctic:**

- Un fitxer de 16MB (4096 cl√∫sters de 4KB) requereix **4096 lectures** de la FAT per acc√©s seq√ºencial complet


## EXT: Extended File System {.smaller}

Els sistemes **EXT** van ser dissenyats espec√≠ficament per a Linux com a evoluci√≥ dels sistemes Unix tradicionals.

**Evoluci√≥:**

- **ext** (1992): Primera versi√≥, problemes de rendiment
- **ext2** (1993): Inodes, directoris flexibles  
- **ext3** (2001): **Journaling** per a consist√®ncia
- **ext4** (2008): **Extents**, millor rendiment

**Caracter√≠stiques:**

- **Inodes** com a element b√†sic
- **Bitmaps** per gesti√≥ d'assignaci√≥
- **Block Groups** per localitat de dades
- **Journaling** per integritat

## EXT: Estructura de l'Inode {.smaller}

L'**inode** √©s el nucli del sistema EXT. Cada fitxer t√© almenys un inode que cont√© tota la seva metadata:

```c
struct ext4_inode {
    uint16_t i_mode;        // Permisos i tipus de fitxer
    uint16_t i_uid;         // User ID del propietari
    uint32_t i_size;        // Mida del fitxer en bytes
    uint32_t i_atime;       // √öltim temps d'acc√©s
    uint32_t i_ctime;       // Temps de creaci√≥ de l'inode
    uint32_t i_mtime;       // √öltim temps de modificaci√≥
    uint16_t i_gid;         // Group ID del propietari
    uint16_t i_links_count; // Nombre de hard links
    
    // Punters a blocs de dades
    uint32_t i_block[15];   // Blocs directes i indirectes
    /*
     * i_block[0-11]: 12 punters directes (48KB amb blocs de 4KB)
     * i_block[12]:   1 punter simple indirecte (4MB addicionals)
     * i_block[13]:   1 punter doble indirecte (4GB addicionals)
     * i_block[14]:   1 punter triple indirecte (4TB addicionals)
     */

};
```

Els **i-nodes** consumeixen un 10% de l'emmagatzematge del disc (*es pot configurar en el moment de la creaci√≥ del sistema de fitxers*).

## EXT: Adre√ßament de Blocs (ext2) {.smaller}

![](../figs/slides/03-fs/inodes-ext.png)

Un fitxer de **100MB** (25.600 blocs de 4KB) necessita **2 nivells d'indirecci√≥**, requerint m√∫ltiples lectures de metadades abans d'accedir a les dades reals.

## EXT: Organitzaci√≥ {.smaller}

![](../figs/slides/03-fs/ext-filesystem.png){width=70%}

- **Bitmap d'Inodes:** mapa de bits d'inodes ocupats/lliures.
- **Bitmap de Blocs:** mapa de bits de blocs ocupats/lliures.
- **Taula d'Inodes:** cada entrada √©s un √∫nic inode.

## EXT3: Problema de Consist√®ncia (I)  {.smaller}

Imagineu que un fitxer necessita augmentar la seva mida, i aix√≤ requereix assignar un nou bloc de dades i actualitzar l'inode per reflectir aquesta nova assignaci√≥. Aquest proc√©s implica m√∫ltiples operacions d'escriptura al disc.

![](../figs/slides/03-fs/ext3-size-increase.png)

## EXT3: Problema de Consist√®ncia (II)  {.smaller}

::: {.center-container}
Imagina que el proc√©s es veu interromput (crash) a mitja operaci√≥. 
:::

![](../figs/slides/03-fs/ext3-crash.png)

## Journaling - Consist√®ncia  {.smaller}

```{mermaid}
%%| echo: false
sequenceDiagram
    participant P as Proc√©s
    participant K as Kernel
    participant J as Journal
    participant FS as Filesystem

    P->>K: write() - ampliar fitxer
    
    Note over K,J: FASE 1: Preparaci√≥
    K->>J: Crear transacci√≥: T1
    K->>J: Nou bloc dades ¬∑ Update bitmap ¬∑ Update inode
    K->>J: COMMIT transacci√≥ T1
    
    Note over K,FS: FASE 2: Aplicaci√≥
    K->>FS: Aplicar canvis del journal
    K->>J: Marcar T1 com a completa
    
    K-->>P: write() completat
```

## Journaling: Modes {.smaller}

- **Journaling Complet:** Tant les dades com les metadades s'escriuen al journal abans d'aplicar-les al sistema de fitxers. M√†xima seguretat, per√≤ m√©s lent.

- **Journaling de Metadades:** Nom√©s les metadades s'escriuen al journal. Les dades es poden escriure directament al sistema de fitxers. Equilibri entre seguretat i rendiment.

- **Escriptura Diferida (Writeback):** Les dades i les metadades es poden escriure directament al sistema de fitxers sense passar pel journal. M√†xim rendiment, per√≤ risc de corrupci√≥ de dades en cas de fallada.

## ext3 ¬∑ Journaling {.smaller}

- **Pre-escriptura (Write-Ahead Logging)**:
   - Abans d'escriure qualsevol dada o metadada al disc, es registra la intenci√≥ d'aquesta escriptura en un registre especial anomenat **journal**. Garanteix que les operacions es completin correctament, fins i tot en cas de fallades.

- **Si escriu el journal correctament**:
   - La transacci√≥ es marca com a completa. Els canvis es poden aplicar al sistema de fitxers de manera segura.

- **Si la escriptura del journal es veu interrompuda**:
   - La transacci√≥ no es completa (p√®rdua de dades), per√≤ el sistema de fitxers roman consistent.

- **Si el journal s'escriu correctament, per√≤ el disc no**:
   - Temporalment, el sistema de fitxers perd la consist√®ncia.El registre t√© la informaci√≥ per restaurar-la (durant l'arrencada, els journals inacabats es completen).



## ext4: Extents per a Millor Efici√®ncia {.smaller}

El principal problema (*ext2/ext3*) era la gesti√≥ ineficient dels punters a blocs de dades, especialment per a fitxers grans.

:::{.fragment}
Un **extends** √©s un descriptor que representa un rang contigu de blocs, millorant l'efici√®ncia en l'assignaci√≥ i reduint la fragmentaci√≥.
:::

- Rangs de blocs f√≠sics contigus, descrits amb una entrada (bloc inicial + nombre de blocs).
- Un extent pot mapar fins a 128 MiB (blocs de 4KB) d‚Äôespai contigu amb blocs de 4 KiB.
- L‚Äôinode d‚Äôext4 pot contenir directament fins a 4 extents; si el fitxer √©s gran o fragmentat, s‚Äôutilitza una estructura d‚Äôarbre (HTree) per indexar m√©s extents.

## ext4: Estructura d'un Extent {.smaller}

```c
struct ext4_extent {
    uint32_t ee_block;      // Bloc l√≤gic inicial al fitxer
    uint16_t ee_len;        // Longitud en blocs (m√†xim 32.768)
    uint16_t ee_start_hi;   // Bits alts del bloc f√≠sic
    uint32_t ee_start_lo;   // Bits baixos del bloc f√≠sic
};
```

```{mermaid}
%%| echo: false
graph TD
    A[Inode] --> B[Extent Header]
    B --> C1[Extent 1]
    B --> C2[Extent 2]
    B --> C3[Extent 3]
    B --> C4[Extent 4]
    C1 --> D1[Bloc F√≠sic 1000 - 1023]
    C2 --> D2[Bloc F√≠sic 2000 - 2023]
    C3 --> D3[Bloc F√≠sic 3000 - 3023]
    C4 --> D4[Bloc F√≠sic 4000 - 4023]
    style A fill:#eaf7ff,stroke:#007bff
    style B fill:#f9f5dd,stroke:#c4aa18
```

## ext4: HTree/Btree {.smaller}

::: columns
::: {.column width="50%"}
- Un **B-tree** √©s una estructura d'arbre auto-balancejada que mant√© dades ordenades i permet cerques, insercions i eliminacions en temps logar√≠tmic. 


- Un **HTree** √©s una variant de *B-tree* utilitzada espec√≠ficament per indexar fitxers i directoris en **ext4**. 
  
- La principal difer√®ncia √©s que les entrades es distribueixen en nodes fulla i no fulla, amb una estructura de cap√ßalera espec√≠fica per a cada node.

- **Inode/Arrel**: Apunta a la cap√ßalera de l‚ÄôHTree.


:::
::: {.column width="50%"}

```{mermaid}
%%| echo: false
graph TD
    A[Inode] --> B[HTree Root]
    B --> C1[Node No Fulla 1]
    B --> C2[Node No Fulla 2]
    C1 --> D1[Node Fulla 1]
    C1 --> D2[Node Fulla 2]
    C2 --> D3[Node Fulla 3]
    C2 --> D4[Node Fulla 4]
    D1 --> E1[Extent 1]
    D1 --> E2[Extent 2]
    D2 --> E3[Extent 3]
    D3 --> E4[Extent 4]
    D4 --> E5[Extent 5]
```

- **Nodes no fulla**: Indexen altres nodes, permetent que l‚Äôarbre creixi i es mantingui balancejat.
- **Nodes fulla**: Contenen les extents, que s√≥n rangs de blocs f√≠sics contigus.
- **Extents**: Descriuen els blocs reals del fitxer o directori.

:::
:::

## ext4 ¬∑ Assignaci√≥ multibloc i retrassada {.smaller}

- **Assignaci√≥ Multibloc**:
  - ext4 pot assignar m√∫ltiples blocs a la vegada, agrupant blocs consecutius per minimitzar la fragmentaci√≥.
  - Aix√≤ redueix la sobrec√†rrega d'assignaci√≥ i millora la localitat de les dades.
- **Assignaci√≥ Retardada**:
  - L‚Äôassignaci√≥ retardada espera a bloquejar l‚Äôespai fins just abans d‚Äôescriure, optimitzant la distribuci√≥ de blocs.
  - Aix√≤ permet agrupar escriptures i minimitzar la fragmentaci√≥.

## Exercicis Propostas

-   [Administraci√≥ B√†sica de Sistemes de Fitxers](../exercises/03-fs/08-ex-week5.qmd)
-   Discussi√≥: [**Secure Boot √©s realment segur?**](https://github.com/amsa-gei-udl-2526-105013/course/issues/3): Cerca not√≠cies recents sobre Secure Boot i comparteix-les al f√≤rum del curs. Debatiu sobre avantatges, desavantatges, vulnerabilitats conegudes i experi√®ncies personals.
-   [Pr√†ctica 01: Snapshots i restauraci√≥ amb systemd i initramfs](../projects/01-project/01-project.qmd)


## That's all

::::::: columns
:::: {.column width="45%"}
::: {.callout-note title="Take Home Message"}
Els sistemes de fitxers s√≥n complexos i cr√≠tics per al rendiment i la fiabilitat del sistema operatiu. El VFS proporciona una capa d'abstracci√≥ que permet gestionar diferents tipus de sistemes de fitxers de manera uniforme. Sistemes de fitxers com EXT4 han evolucionat per abordar problemes de rendiment i consist√®ncia, incorporant caracter√≠stiques com els extents i el journaling.
:::
::::

::: {.column width="5%"}
:::

::: {.column width="50%"}
![](https://static.posters.cz/image/750/posters/looney-tunes-thats-all-folks-i295.jpg){width="70%"}
:::
:::::::


