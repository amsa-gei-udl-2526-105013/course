---
title: "Virtualitzaci√≥ i Contenidors"
subtitle: "Unitat 5 ¬∑ Administraci√≥ i Manteniment de Sistemes i Aplicacions (AMSA)"
author: "Jordi Mateo Forn√©s"
format: 
  revealjs:
    theme: simple
    transition: fade
    slide-number: true
    incremental: true
    css: styles.css
    footer: "Unitat 5 ¬∑ Administraci√≥ i Manteniment de Sistemes i Aplicacions (AMSA) [üè†](/index.html)</a>"
---

## Qu√® √©s la virtualitzaci√≥? {.smaller}

La virtualitzaci√≥ √©s una tecnologia que permet executar m√∫ltiples sistemes complets (SO, aplicacions i maquinari virtualitzat) sobre un √∫nic host f√≠sic.

:::{.fragment}

### Per a qu√® serveix?

- **A√Øllament**: cada m√†quina virtual s‚Äôexecuta de manera independent, sense interferir amb les altres.
- **Flexibilitat**: permet crear, modificar i eliminar entorns r√†pidament.
- **Efici√®ncia de recursos**: aprofita millor el hardware compartint CPU, mem√≤ria i emmagatzematge.
- **Facilitat de desplegament i manteniment**: simplifica proves, r√®pliques, desastres i actualitzacions.
:::

## Emulaci√≥ i virtualitzaci√≥ {.smaller}

::: columns
::: {.column width="50%"}

### Emulaci√≥  

- Reprodueix una arquitectura diferent de la del host (p. ex. executar programari ARM en un host x86).
- M√©s lenta, perqu√® s‚Äôhan de traduir instruccions.
- √ötil per a **compatibilitat**, proves o sistemes antics.

::: {.center-container .fragment}
Exemple: QEMU en mode full emulation.
:::

::: {.fragment}

```text
Host (x86)
   ‚Üì traducci√≥
Guest (ARM)  --> Lenta
```

:::

:::
::: {.column width="50%"}

### Virtualitzaci√≥

- Guest i host **comparteixen** la mateixa arquitectura.
- El hypervisor aprofita instruccions de hardware ‚Üí rendiment molt proper al natiu.
- √ötil per executar diversos SO al mateix temps en un host.

::: {.center-container .fragment}
Exemples: KVM, VMware, Hyper-V.
:::

::: {.fragment}

```text
Host (x86)
   ‚Üì execuci√≥ directa
Guest (x86) --> Proper al natiu
```

:::

:::
:::

## Hypervisor {.smaller}

Un hypervisor √©s el programari que crea, executa i gestiona m√†quines virtuals (VMs). Permet compartir el maquinari f√≠sic entre diversos sistemes operatius.

::: columns
::: {.column width="50%"}
### Type 1 (bare metal)

- S‚Äôexecuta directament sobre el hardware (no hi ha un SO host).
- M√©s rendiment, menys lat√®ncia i millor seguretat.
- Utilitzat en servidors i centres de dades.
- Exemples: VMware ESXi, Microsoft Hyper-V Server, Xen.

:::
::: {.column width="50%"}

### Type 2 (hosted)

- S‚Äôexecuta a sobre d‚Äôun sistema operatiu host.
- M√©s senzill d‚Äôinstal¬∑lar i ideal per a entorns de desenvolupament o escriptori.
- Lleugerament menys eficient.
- Exemples: VirtualBox, VMware Workstation, Parallels.

:::
:::


## Arquitectura t√≠piques

::: {.center-container}
![](../figs/slides/01-foundations-of-systems-administration/virtualitzacio.png)
:::

## Paravirtualitzaci√≥ {.smaller}

El sistema operatiu guest es modifica per cooperar amb el VMM:

-   **CPU paravirtualitzada**: √∫s de hypercalls en lloc d‚Äôinstruccions privilegiades.
-   **MMU paravirtualitzada**: gesti√≥ compartida de les taules de p√†gines.
-   **I/O paravirtualitzada**: dispositius virtuals optimitzats (Virtio).

:::{.fragment}
El VMM exposa **hypercalls** per:

-   Activar/desactivar interrupcions
-   Canviar taules de p√†gines
-   Accedir a perif√®rics virtualitzats
:::

:::{.fragment .center-container}
El VMM pot injectar **interrupcions virtuals** a trav√©s d‚Äôesdeveniments.
:::

## Intel VT- {.smaller}

-   Extensi√≥ que transforma x86 en una arquitectura virtualitzable.
    -   **Root mode**: s‚Äôexecuta el VMM
    -   **Non-root mode**: s‚Äôexecuten els guests
-   Cada inst√†ncia en non-root mode mant√© un VMCS (Virtual Machine Control Structure) amb:
    -   Estat del guest (registres, CR3, IDTR, etc.)
    -   Estat intern invisible
-   Transicions:
    -   **VM Entry**: c√†rrega l‚Äôestat del guest des del VMCS
    -   **VM Exit**: guarda l‚Äôestat del guest i restaura el del host

## Com guardar/restaurar una VM? {.smaller}

Una m√†quina virtual es pot guardar, copiar o restaurar perqu√® est√† formada per un conjunt d‚Äôarxius que descriuen:

- L‚Äôestat de la VM (configuraci√≥)
- El disc dur virtual
- (Opcional) Snapshots o estats suspesos

:::{.fragment }
Cada hypervisor utilitza formats propis:

- VMware: .vmx (configuraci√≥), .vmdk (disc virtual)
- VirtualBox: .vbox (configuraci√≥), .vdi (disc virtual)
- KVM/QEMU: .qcow2, .img (disc virtual)
:::

::: {.fragment .center-container}
Per exemple, quan vau realitar la pr√†ctica 2, us vaig facilitar una imatge .vmdk de VMware.
:::

## Caracter√≠stiques

| **Avantatges**                                      | **Inconvenients**                                                    |
| --------------------------------------------------- | -------------------------------------------------------------------- |
| Permeten executar **arquitectures i SO diferents**  | **M√©s pesants**: cal un SO complet ‚Üí **mida de la imatge elevada**   |
| **A√Øllament i seguretat** molt alts                 | **Temps d‚Äôarrencada** m√©s lent que contenidors                       |
| Es poden **compartir i importar imatges** f√†cilment | **Interoperabilitat limitada** entre hypervisors (formats diferents) |

::: notes

- Recorda-los que una VM ocupa ‚Äúcom un ordinador real‚Äù ‚Üí per aix√≤ les imatges poden ser de diversos GB.
- Subratlla que compartir una imatge d‚Äôuna VM vol dir reproduir exactament el mateix entorn (molt √∫til en doc√®ncia i DevOps).
- Compara amb contenidors: VM = PC complet, contenidor = proc√©s a√Øllat.
- Explica que la interoperabilitat no est√† garantida: un .vmdk no sempre funciona en VirtualBox o QEMU sense conversi√≥.

:::

## Com podem millorar una m√†quina virtual?

- Imaginem que volem executar un programa senzill, com un petit servidor web.
- Amb una VM, necessitem instal¬∑lar un sistema operatiu complet (Linux, Windows‚Ä¶).
- Aix√≤ vol dir:
  - Molt m√©s espai en disc (GB de la imatge)
  - M√©s mem√≤ria RAM per al SO
  - Temps d‚Äôarrencada for√ßa m√©s elevat

## Per√≤‚Ä¶ √©s realment necessari un SO complet? {.smaller}

- Un servidor web no necessita totes les funcions del kernel.
- Ens agradaria dir-li al sistema:
  - **Executa aquest proc√©s, per√≤ a√Øllat de la resta del sistema.**
- Un servidor web no necessita:
  - funcions d‚Äôinici de sessi√≥,
  - gesti√≥ d‚Äôusuaris complexa,
  - serveis de fons innecessaris,
  - processos del sistema que no tenen res a veure amb l‚Äôaplicaci√≥

::: {.fragment .center-container}
un paquet m√≠nim que inclou biblioteques + configuraci√≥ + aplicaci√≥,
executat de manera a√Øllada per√≤ sense un SO complet per cada inst√†ncia.
:::

## Quantes vegades hem sentit aix√≤? {.smaller}

:::{.fragment .center-container}
**Works on my machine**
:::

::: columns
::: {.column width="50%"}

- Al meu PC funciona‚Ä¶ per√≤ al teu no.
- A l‚Äôentorn de tests va perfecte, per√≤ en producci√≥ peta.
- La versi√≥ de la llibreria X √©s diferent.
- Aquest programa necessita permisos que aqu√≠ no t√©.
- Funciona a la meva m√†quina virtual‚Ä¶ per√≤ al servidor no.
:::
::: {.column width="50%"}

- Depend√®ncies diferents
- Versions de llibreries inconsistents
- Configuracions de sistema no iguals
- Permisos, usuaris o paths que no coincideixen
- Serveis que al teu entorn estan actius, per√≤ en un altre no
:::
:::

## Contenidors {.smaller}

:::{.center-container}
La caracter√≠stica que estem buscant rep el nom de contenidors.
:::

:::{.fragment}
Els contenidors no aparareixen com a tals al kernel de Linux. S√≥n una combinaci√≥ de diverses funcionalitats del nucli:

- **Namespaces** ‚Üí A√Øllen processos
- **cgroups v2** ‚Üí Limiten i controlen recursos (CPU, mem√≤ria, E/S‚Ä¶)
- **Overlay filesystems** ‚Üí Proporcionen sistemes d‚Äôarxius lleugers i capa√ßos d‚Äôapilar capes
:::

::: {.fragment .center-container}
La combinaci√≥ d‚Äôaquests tres elements crea l‚Äôefecte que nosaltres anomenem contenidors.
:::

## cgroups - Control de recursos {.smaller}

Els cgroups s√≥n una funcionalitat del kernel que permet limitar i controlar els recursos que utilitza un grup de processos (o un contenidor).

::: {.fragment}
Aquests l√≠mits poden ser:

- CPU: quant temps de processador poden consumir
- Mem√≤ria: l√≠mit de RAM i swap
- Disc (I/O): velocitat de lectura/escriptura
- Xarxa: ample de banda
:::

:::{.fragment .center-container}
**Per qu√® s√≥n importants?** Eviten que un proc√©s o contenidor monopolitzi el sistema.
:::

## Namespaces - A√Øllament {.smaller}

Els namespaces permeten que cada contenidor tingui la seva pr√≤pia visi√≥ del sistema, com si fos un entorn independent

- PID ‚Üí processos propis
- UTS ‚Üí hostname propi
- NET ‚Üí interf√≠cies de xarxa i rutes separades
- MNT ‚Üí sistema de fitxers a√Øllat
- USER ‚Üí UIDs/GIDs independents
- IPC ‚Üí recursos IPC separats
- CGROUP namespaces ‚Üí cgroups propis

:::{.center-container .fragment}
Efecte de m√†quina virtualitzada, per√≤ compartint el mateix nucli real.
:::

## Overlay Filesystems {.smaller}

Els contenidors utilitzen OverlayFS (o variants) per gestionar un sistema d‚Äôarxius:

- Les capes inferiors s√≥n de nom√©s lectura (base de la imatge).
- La capa superior √©s d‚Äôescriptura, on viu el que modifica el contenidor.
- Diversos contenidors poden compartir les capes inferiors ‚Üí estalvi d‚Äôespai i efici√®ncia.

:::{.fragment}
Aix√≤ fa que les imatges siguin:

- Lleugeres
- R√†pides de desplegar
- Facils de distribuir i versionar
:::

## Arquitectura simplificada {.smaller}

::: columns
::: {.column width="60%"}

Aquesta figura mostra com un contenidor √©s, en realitat, un conjunt de processos normals del sistema Linux:

- El kernel √©s compartit per tots els processos.
- systemd (o un altre init) gestiona processos de l‚Äôamfitri√≥.
- Els programes normals (A, B, C‚Ä¶) conviuen en el mateix sistema.
- Els processos del contenidor tamb√© s√≥n processos normals, per√≤:
  - Estan a√Øllats per namespaces,
  - Tenen l√≠mits de recursos amb cgroups,
  - Veuen un sistema de fitxers propi (OverlayFS).
:::
::: {.column width="40%"}

![](../figs/slides/04-virt/container_simple.png){width="80%"}

:::{.center-container .fragment}
Tot i estar dins del contenidor, segueixen sent processos Linux del host.
:::

:::
:::



## Motors o Llibreries de Contenidors {.smaller}

### LXC (Linux Containers)

- Sistema de contenidors de baix nivell integrat al kernel.
- Contenidors de sistema complet (semblants a mini-m√†quines lleugeres).
- Ideal per entorns que necessiten un sistema d‚Äôinici complet (init, serveis‚Ä¶).
- √âs la base t√®cnica sobre la qual Docker es va inspirar als inicis.

## Motors o Llibreries de Contenidors {.smaller}

### containerd
- Motor de contenidors de baix nivell.
- Gestiona el cicle de vida dels contenidors (crear, executar, aturar, eliminar).
- Utilitza **runc** per crear els contenidors reals.

## Motors o Llibreries de Contenidors {.smaller}

### Docker

- Plataforma molt estesa per crear, distribuir i executar contenidors.
- Enfocada en contenidors d‚Äôaplicacions, no de sistema.
- Funcionalitats integrades:
    - imatges en capes
    - xarxes virtuals
    - volums
    - API, logs, build‚Ä¶
    - Buildkit sistema principal de construcci√≥

## Motors o Llibreries de Contenidors {.smaller}

### Podman

- Alternativa moderna i compatible amb Docker.
- No necessita daemon: cada contenidor √©s un proc√©s del propi usuari.
- Permet executar contenidors com usuari normal (rootless).
- Compatible amb:
    - imatges Docker
    - comandes Docker (alias docker=podman)
    - Kubernetes (podman generate kube)
    - Permet executar `pods` (grups de contenidors) sense `kubelet`

## Passos per executar un contenidor (I)  {.smaller}

1. **Escriure un Containerfile** ‚Üí Descriu com ha de ser el contenidor:
   - sistema base
   - depend√®ncies
   - fitxers a copiar
   - com s‚Äôexecuta l‚Äôaplicaci√≥

2. **Construir la imatge** ‚Üí A partir del Containerfile, el *Engine* crea una imatge. Pots pensar en la imatge com un .ova o .vmdk de VirtualBox:
   - cont√© el sistema d‚Äôarxius 
   - √©s immutable (*entre cometes*)
   - es pot copiar o distribuir (*portable*)

## Passos per executar un contenidor (II)  {.smaller}

3. **Executar un contenidor**: Amb una imatge, el motor ( Engine / containerd + runc):
   - crea un sistema d‚Äôarxius a√Øllat (OverlayFS)
   - aplica namespaces i cgroups
   - arrenca el proc√©s principal del contenidor

:::: {.fragment .center-container}
Els passos 1 i 2 nom√©s es fan un cop per crear la imatge. Per executar el contenidor, nom√©s cal el pas 3.
::::

## Qu√® √©s una imatge de contenidor? {.smaller}

Un contenidor s‚Äôexecuta a partir d‚Äôuna **imatge OCI** (Open Container Initiative).
Una imatge cont√©:

   - Root filesystem: El sistema d‚Äôarxius que el contenidor veu com a **arrel (/)**:
     - binaris
     - llibreries
     - fitxers de configuraci√≥

   - Metadades que indiquen com s‚Äôha d‚Äôexecutar el contenidor:
     - variables d‚Äôentorn
     - comanda o entrypoint
     - ports exposats
     - usuaris
     - configuraci√≥ de xarxa
     - punts de muntatge (volums)

## `manifest.json` {.smaller}

√âs el mapa general de la imatge.

Cont√©:

- identificador de les capes (layers)
- el fitxer de configuraci√≥ a utilitzar
- el tipus de sistema d‚Äôarxius
- checksums (sha256) per assegurar integritat

:::{.center-container .fragment}
Pensa en el manifest com l‚Äô√≠ndex de tot el que forma la imatge.
:::

## `config.json` {.smaller}

Defineix el comportament del contenidor quan s‚Äôexecuti.

Cont√©:

- Entrypoint i Cmd
- Variables d‚Äôentorn
- Usuari d‚Äôexecuci√≥
- Volums
- Directori de treball (WORKDIR)
- Autor, timestamps, historial de construcci√≥
- Informaci√≥ d‚Äôarquitectura (amd64, arm64‚Ä¶)

:::{.center-container .fragment}
El config √©s la **recepta** que diu com s‚Äôha d‚Äôexecutar la imatge.
:::

## Capes d‚Äôuna imatge de contenidor

- El filesystem d‚Äôuna imatge est√† format per diverses capes apilades (OverlayFS).
- Cada capa representa un conjunt de canvis respecte la capa anterior (instal¬∑lar paquets, afegir fitxers‚Ä¶).
- Les capes s√≥n de nom√©s lectura i es poden reutilitzar entre imatges diferents ‚Üí estalvi d‚Äôespai i efici√®ncia.

:::{.center-container .fragment}
Les capes s√≥n com **commits**: cada una √©s un increment sobre l‚Äôanterior.
:::


## Caracter√≠stiques dels contenidors {.smaller}

::: columns
::: {.column width="50%"}

### Avantatges

- **Alt rendiment**: Els contenidors s‚Äôexecuten gaireb√© a velocitat nativa perqu√® s√≥n processos d‚Äôusuari que comparteixen el kernel del host.

- **Desplegament molt r√†pid**: Arranquen instant√†niament, ja que no cal inicialitzar un sistema operatiu complet.

- **Interoperabilitat d‚Äôexecuci√≥**: Poden funcionar amb diferents engines i runtimes (Docker, containerd, CRI-O, Podman, runc‚Ä¶).

:::
::: {.column width="50%"}

### Desavantatges

- Nom√©s per a Linux
- Depenen de funcionalitats del kernel de Linux (namespaces, cgroups, OverlayFS).
- Per aix√≤ les imatges sempre s√≥n Linux encara que executis Docker a Windows/Mac.
- A√Øllament redu√Øt
- Comparteixen el kernel del host ‚Üí menor seguretat que la virtualitzaci√≥ completa (VMs), on cada m√†quina t√© el seu kernel.

:::
:::

## Immutable per√≤ modificable {.smaller}

- Les imatges de contenidors s√≥n **immutables**: La imatge original no canvia mai.
- Per√≤ quan un contenidor s‚Äôexecuta, s√≠ que es pot modificar.
- Com √©s possible?

::: {.center-container .fragment}
**Perqu√® NO √©s una c√≤pia bit a bit**
:::

- Els contenidors utilitzen un filesystem en capes (OverlayFS):
- Les capes inferiors (base image) s√≥n nom√©s lectura.
- El contenidor t√© una capa superior (writable layer) on fa els canvis.
- Totes les modificacions (fitxers nous, modificats o eliminats) van nom√©s a la capa superior.
- El commit d‚Äôun contenidor crea una nova imatge amb els canvis de la capa superior.

::: {.center-container .fragment}
La imatge no canvia. El contenidor s√≠.
:::

## Portable si ... per√≤ no totalment {.smaller}

- Les imatges de contenidors s√≥n **portables**: es poden copiar i executar en qualsevol sistema amb el mateix motor (Docker, Podman, containerd‚Ä¶).
- Per√≤ hi ha algunes limitacions:
    - **Arquitectura**: una imatge x86 no funcionar√† en un host ARM. (Tot i que existeix multi-arch amb manifest i buildx.)
    - **Depend√®ncies del kernel**: els contenidors depenen de funcionalitats espec√≠fiques del kernel (namespaces, cgroups, OverlayFS). Si el host no les suporta, el contenidor no funcionar√†.
    - **Recursos del host**: si el host no t√© suficients recursos (CPU, mem√≤ria, disc), el contenidor pot no funcionar correctament
    - Els contenidors no encapsulen el kernel ABI, per tant, si una aplicaci√≥ dep√®n d‚Äôuna versi√≥ espec√≠fica del kernel, pot no funcionar en un host amb un kernel diferent.

## VMs vs Contenidors {.smaller}

::: columns
::: {.column width="50%"}

**Quan utilitzar m√†quines virtuals (VMs)**

- Control complet del sistema operatiu (kernel propi, drivers, init, serveis‚Ä¶)
- A√Øllament molt fort: Ideal per seguretat estricta o entorns multi-tenant desconfiats.
- Compatibilitat d‚Äôarquitectura
- Necessitat  d'emular o executar altres arquitectures i sistemes.

:::
::: {.column width="50%"}

**Quan utilitzar contenidors**

- Desplegament molt r√†pid: S‚Äôaixequen gaireb√© instant√†niament.
- Consum redu√Øt de recursos: Comparteixen el kernel ‚Üí menys RAM i CPU.
- Ideals per aplicacions i serveis.

:::
:::

## Arquitectura Docker

:::{.center-container}
![](../figs/slides/04-virt/docker-on-linux.png){width="70%"}
:::

## Components principals Docker {.smaller}

- **Docker client**: interf√≠cie d‚Äôusuari (CLI, GUI, API)
- **Docker Engine**: motor de contenidors
  - **containerd**: Gestiona el cicle de vida dels contenidors (crear, aturar, eliminar).
  - **runc**: Crea el contenidor real utilitzant namespaces i cgroups. (√âs l‚Äô√∫nica part que parla directament amb el kernel.)
  - **libnetwork**: Gesti√≥ de xarxes virtuals (bridges, NAT, interfaces virtuals).
  - **graphdriver**: Gesti√≥ d‚Äôimatges i del sistema de capes (OverlayFS, btrfs, zfs‚Ä¶). Recentment anomenat **snapshotter**.
  - **plugins**: Extensions per storage, logging i networking.
- **Kernel de Linux**: El kernel √©s on realment s‚Äôexecuta el contenidor.
  - Network stack, system calls, VFS‚Ä¶
  - Namespaces, cgroups v2, OverlayFS

:::{.center-container .fragment}
Docker √©s nom√©s una capa d‚Äôorquestraci√≥. Els contenidors els crea el kernel.
:::


## Instal¬∑laci√≥ de Docker a EC2 (I)

- Instal¬∑lar el paquet amb `dnf` a Amazon Linux 2:

:::{.fragment}  
```bash
sudo dnf install docker -y
```
:::

- Iniciar el servei de Docker:

:::{.fragment}
```bash
sudo systemctl enable --now docker
```
:::

- Comprovar la instal¬∑laci√≥:

:::{.fragment}
```bash
docker --version
```
:::

## Instal¬∑laci√≥ de Docker a EC2 (II)

- Per a poder executar comandes de Docker sense necessitat de ser un usuari root, afegirem el nostre usuari al grup docker:

::: {.fragment}

```bash
sudo usermod -a -G docker ec2-user
newgrp docker # Per a aplicar els canvis
```

:::

- Actualitzarem els permissos del socket de Docker per permetre als usuaris del grup docker llegir i escriure el fitxer: `/var/run/docker.sock`

:::{.fragment}

```bash
sudo chmod g+rw /var/run/docker.sock
```

:::


## Experiment 1: Temps d‚Äôarrencada {.smaller}

En aquest experiment compararem la velocitat d‚Äôarrencada d‚Äôuna m√†quina virtual (VM) amb la d‚Äôun contenidor Docker.

1. **M√†quina Virtual (VM)**:
   - Utilitzeu VirtualBox per crear una m√†quina virtual amb Debian.
   - Mesureu el temps d‚Äôarrencada des de l‚Äôinici fins que el sistema est√† llest per a l‚Äô√∫s. `systemd-analyze` √©s una eina √∫til per aix√≤.

2. **Contenidor Docker**:
   - Creeu un contenidor Docker utilitzant la imatge oficial de Debian.
   - Mesureu el temps d‚Äôarrencada del contenidor des de la comanda `docker run` fins que el proc√©s principal est√† en execuci√≥. Podeu utilitzar la comanda `time` per mesurar-ho.   
   - Per exemple: `time docker run --rm debian sleep 1`


## Exemple 1 (I)

### Imagineu un servidor amb molts recursos

:::{.center-container}
![](../figs/slides/04-virt/server-0.png){width="60%"}
:::

## Exemple 1 (II)
### Despleguem primer una aplicaci√≥ amb JAVA

:::{.center-container}
![](../figs/slides/04-virt/server-1.png){width="60%"}
:::

## Exemple 1 (III)
### Despleguem despr√©s una amb Python

:::{.center-container}
![](../figs/slides/04-virt/server-2.png){width="60%"}
:::

## Exemple 1 (IV)
### Una web amb react
:::{.center-container}
![](../figs/slides/04-virt/server-3.png){width="60%"}
:::

## Exemple 1 (V) {.smaller}

### aix√≤ no escalar√† gaireb√© b√©

- Cal definir usuaris i permisos per a cada aplicaci√≥. 
- Cal evitar conflictes de versions de llibreries.
- I si Java necessita OpenSSL 1.1.x i Python OpenSSL 3.x?
- Cal evitar que una aplicaci√≥ pugui accedir a fitxers d‚Äôuna altra aplicaci√≥.
- Necessitem a√Øllament:
  - Una m√†quina virtual per aplicaci√≥ seria massa costosa en recursos.
  - Necessitem un contenidor per aplicaci√≥!

## Exemple 1 (VI) {.smaller}

- Contru√Øm un contenidor per a cada aplicaci√≥:
  - Un contenidor amb Java + app Java
  - Un contenidor amb Python + app Python
  - Un contenidor amb Node.js + app React
- Cada contenidor t√© el seu propi sistema d‚Äôarxius, llibreries i configuraci√≥.
- Compartim el mateix kernel del host, per√≤ cada aplicaci√≥ est√† a√Øllada.

## Exemple 1 (VII)

### I ara s√≠ que escala b√©!
:::{.center-container}
![](../figs/slides/04-virt/server-4.png){width="60%"}
:::


## Imatge `ubuntu`

- La imatge d'`ubuntu` √©s una imatge oficial lleugera de Ubuntu.
- Cont√© una sola capa.
- Podeu utiltizar `docker inspect <image_name>` per veure els detalls com les capes, el sistema d'arxius i la configuraci√≥.

## Mida de les imatges {.smaller}

Si utiltizeu la comanda `docker pull ubuntu && docker image ls ubuntu`, veureu que la imatge ocupa nom√©s 139 MB. 

:::{.fragment}
Aquest imatge √∫nicament cont√© el **userspace filesystem** i els paquets b√†sics de Ubuntu. No cont√©:

- Kernel
- Drivers
- Serveis de `systemd`
- Entorn gr√†fic
- bootloader
:::

:::{.center-container .fragment}
Un contenidor no √©s una VM, √©s un proc√©s a√Øllat que comparteix el kernel del host.
:::

## Dockerfile b√†sic {.smaller}

- Crear un fitxer anomenat `Dockerfile`.
- Afegeix al fitxer, la imatge per on vols comen√ßar:

::: {.fragment}

```dockerfile
FROM ubuntu
```
:::

- Per construir la imatge, utilitza la comanda:

:::{.fragment}
```bash
docker build . -t amsa
```
:::

- Aquesta imatge **amsa** t√© una sola capa, basada en `ubuntu`.

## Dockerfile amb m√©s instruccions {.smaller}

```bash
FROM ubuntu
RUN apt update && apt install figlet
CMD figlet "amsa"
```

- `RUN` executa comandes a la imatge base.
- `CMD` defineix la comanda per defecte quan s‚Äôexecuta el contenidor.

- La imatge resultatn tindr√† 2 capes:
  - Capa base: `ubuntu`
  - Capa RUN: amb `figlet` instal¬∑lat i les depend√®ncies actualitzades.

:::{.center-container .fragment}
**Ouch! Com √©s que estic instal¬∑lant sense `sudo`?**
:::

::: notes
- Explica que dins del contenidor, el proc√©s s‚Äôexecuta com a root per defecte.
- Aix√≤ no afecta el sistema host, ja que el contenidor est√† a√Øllat.
- Per√≤ cal tenir cura amb els permisos quan es munten volums o es comparteixen recursos.
:::

## Executant la imatge

1. Reconstru√Øm la imatge: `docker build . -t amsa`
2. Executem el contenidor: `docker run amsa`

:::{.fragment}
```bash
$ docker run amsa

  __ _ _ __ ___  ___  __ _
 / _` | '_ ` _ \/ __|/ _` |
| (_| | | | | | \__ \ (_| |
 \__,_|_| |_| |_|___/\__,_|
```
:::

- Veurem que s‚Äôexecuta la comanda `figlet "amsa"` i es mostra el text ASCII.

## Execuci√≥ interactiva

Per executar el contenidor de manera interactiva, utilitzeu: `docker run -it amsa bash`. 

- Aquesta comanda dona al contenidor una terminal interactiva mantenint  STDIN obert (-i) i assignant una terminal TTY (-t).

:::{.fragment}
`docker run -it ubuntu` us permetr√† explorar el sistema de fitxers d‚ÄôUbuntu dins del contenidor amb una shell bash, mentre que `docker run ubuntu` nom√©s executa la comanda per defecte i surt.
:::

## Compartint fitxers {.smaller}

Anem a modificar `figlet` per mostrar un missatge personalitzat, a partir d‚Äôun fitxer local `message.txt`.

:::{.fragment}
```bash
echo "Hello from amsa!" > message.txt
```
:::

- COPY <origen> <dest√≠> copia fitxers/directoris del host al sistema de fitxers del contenidor.

:::{.fragment}
```dockerfile
FROM ubuntu
COPY message.txt my-message.txt
RUN apt update && apt install -y figlet
CMD cat my-message.txt | figlet
```
:::

:::{.center-container .fragment}
Cada cop que modifiqueu el fitxer `message.txt`, haureu de reconstruir la imatge per veure els canvis.
:::

## Pregunta 1 {.smaller}

Quina √©s la difer√®ncia entre aquests dos Dockerfiles?

::: columns
::: {.column width="50%"}

### A

```dockerfile
FROM ubuntu
COPY message.txt my-message.txt
RUN apt update && apt install -y figlet
CMD cat my-message.txt | figlet
```

:::
::: {.column width="50%"}

### B

```dockerfile
FROM ubuntu
RUN apt update && apt install -y figlet
COPY message.txt my-message.txt
CMD cat my-message.txt | figlet
```

:::
:::

:::{.fragment}
Les capes es construeixen en ordre. Si el fitxer `message.txt` canvia, nom√©s la capa que el copia (COPY) es tornar√† a construir en el Dockerfile **B**. En el Dockerfile **A**, si `message.txt` canvia, tota la capa RUN (instal¬∑laci√≥ de figlet) tamb√© es tornar√† a construir, fent el proc√©s m√©s lent.
:::

## Treballant amb python {.smaller}

Imagine que teniu un projecte amb python amb els fitxers seg√ºents:

```
‚îú‚îÄ‚îÄ main.py
‚îú‚îÄ‚îÄ message.txt      # The message we want pfiglet to print
‚îú‚îÄ‚îÄ requirements.txt # pyfiglet declared as a dependency
‚îî‚îÄ‚îÄ .venv            # The python virtual env
```

on el `main.py` cont√©:

```python
from pyfiglet import Figlet

with open("message.txt") as file:
  print(Figlet().renderText(file.read()))
```

## Dockerfile per a l‚Äôaplicaci√≥ Python {.smaller}

- Normalment, per executar-ho sense contenidors, far√≠em:

:::{.fragment}
```bash
python -m venv .venv
source .venv/bin/activate
pip install -r requirements.txt
python main.py
```
:::

- Per√≤ amb Docker, podem crear un Dockerfile aix√≠:

:::{.fragment}

```dockerfile
FROM python
COPY main.py main.py
COPY message.txt message.txt
COPY requirements.txt requirements.txt
RUN pip install -r requirements.txt
CMD python main.py
```
:::

:::{.center-container .fragment}
Com √©s que no estem utilitzant un entorn virtual `.venv` dins del contenidor?
:::

::: notes
- Explica que dins del contenidor, el sistema est√† a√Øllat.
- No hi ha conflictes amb altres aplicacions o versions de Python.
- Per aix√≤, no √©s necessari utilitzar un entorn virtual dins del contenidor.
:::

## `COPY . .` {.smaller}

- En lloc de copiar fitxer per fitxer, podem copiar tot el directori de treball amb:

```dockerfile
FROM python
COPY . .
RUN pip install -r requirements.txt
CMD python main.py
```

## Optimitzant la imatge

- Quan es treballa amb contenidors, √©s important mantenir les imatge tant petites com sigui possible.
- El contenidor √∫nicament necessita (`message.txt`, `main.py`, `requirements.txt`).
- Com estem fent `COPY . .`, tamb√© estem copiant el directori `.venv`, que pot ser molt gran i innecessari dins del contenidor.

## Dockerignore

- Per evitar copiar fitxers/directoris innecessaris, podem utilitzar un fitxer `.dockerignore`.
- Sembla un `.gitignore`, per√≤ per a Docker.

:::{.fragment}
```bash
echo ".venv" >> .dockerignore
echo "Dockerfile" >> .dockerignore
echo .dockerignore >> .dockerignore
```
:::

- Aix√≤ evitar√† que el directori `.venv`, el `Dockerfile` i el propi `.dockerignore` es copi√Øn a la imatge.

## Optimitzaci√≥ final del Dockerfile

```dockerfile
FROM python
COPY . .
RUN pip install -r requirements.txt
CMD python main.py
```

- **Qu√® m√©s es pot optimitzar?**
- Qu√® passa si √∫nicament modifico el fitxer `message.txt`?


## Cach√© de capes

- Els projectes reals tenen moltes depend√®ncies, i haver de reinstal¬∑lar-les cada cop que un fitxer canvia seria molt lent.
- √âs bona pr√†ctica primer copiar nom√©s els fitxers necessaris per instal¬∑lar les depend√®ncies, i despr√©s copiar la resta del projecte:

:::{.fragment}
```dockerfile
FROM python
COPY requirements.txt requirements.txt
RUN pip install -r requirements.txt
COPY . .
CMD python main.py
```
:::

:::notes
- Explica que aix√≠, si nom√©s canvia `message.txt` o `main.py`, nom√©s es tornar√† a construir la capa que copia aquests fitxers.
- La capa que instal¬∑la les depend√®ncies es mantindr√† en cach√©, fent el proc√©s de construcci√≥ molt m√©s r√†pid.
:::

## Dockerfile `ubuntu`  {.smaller}

Si mireu el contingut de la imatge oficial d'`ubuntu`, veureu que el Dockerfile √©s aix√≠:

```Dockerfile
FROM scratch
ADD rootfs-22.04-amd64.tar /
CMD ["/bin/bash"]
```

- `FROM scratch` indica que aquesta imatge no t√© cap capa base (√©s buida).
- `ADD rootfs-22.04-amd64.tar /` semblant a `COPY`, per√≤ amb m√©s funcionalitats, per exemple, pot descomprimir arxius.
- `CMD ["/bin/bash"]` estableix la comanda per defecte quan s‚Äôexecuta el contenidor.

:::{.center-container .fragment}
Quina difer√®ncia hi ha entre  `CMD["/bin/bash"]` i `CMD /bin/bash`? √âs el mateix?
:::

::: notes
- Explica que la primera forma √©s la forma exec (recomanada), on s'executa directament el binari sense passar per un shell.
- La segona forma √©s la forma shell, on s'executa a trav√©s d'un shell (com `/bin/sh -c`).
- La forma exec √©s m√©s eficient i evita problemes amb senyals i processos fills.
:::


## Exercici 1: Contenidor amb depend√®ncies

Imagineu que executeu la comanda seg√ºent:

```bash
docker run python:3.9 python -c "import numpy as np; print(np.random.rand())"
```

Explica qu√® passa?

## Exercici 1: Contenidor amb depend√®ncies (soluci√≥)

La imatge oficial de `python:3.9` no inclou la llibreria NumPy per defecte. Per tant, quan s'intenta executar el codi Python que importa NumPy, es produeix un error perqu√® la llibreria no est√† instal¬∑lada dins del contenidor.

```Dockerfile
FROM python:3.9
RUN pip install numpy
```

## Exercici 2: Compartint dades

Imagina que tens un script de Python anomenat `hola.py` al teu sistema host amb el seg√ºent contingut:

```python
print("Hola m√≥n!")
```

Vols executar aquest script dins d'un contenidor Docker basat en la imatge oficial de Python 3.9. Com ho faries?

## Exercici 2: Compartint dades (soluci√≥ 1)

Creariam un dockerfile per a la nostra aplicaci√≥ Python:

```Dockerfile
FROM python:3.9
COPY hola.py hola.py
CMD python hola.py
```

## Exercici 3: Compartint dades de sortida

Per√≤, i si volem que el script `hola.py` escrigui un fitxer de sortida anomenat `sortida.txt` dins del sistema host? Com ho far√≠em?

## Compartint dades amb un contenidor Docker

Per compartir dades est√†tiques estem utiltizant la instrucci√≥ `COPY` al Dockerfile. Per√≤, i si volem compartir dades din√†miques entre el sistema host i el contenidor, com els fitxers de sortida generats pel contenidor?

Cal compartir un directori o fitxer entre el sistema host i el contenidor. Per aix√≤, utilitzarem l'opci√≥ `-v` de la comanda `docker run`.

```bash
docker run -v <directori_host>:<directori_contenidor> <imatge> <comanda>
```

## Quins s√≥n els directoris del contenidor? {.smaller}

- Podem utilitzar la comanda `docker run -it <imatge> bash` per accedir a la consola del contenidor i explorar el sistema de fitxers. 
- Un cop dins, podem utilitzar comandes com `ls`, `pwd` i `cd` per navegar pels directoris.
- Alguns directoris comuns s√≥n:
  - `/app`: sovint utilitzat com a directori de treball per a aplicacions.
  - `/data`: sovint utilitzat per emmagatzemar dades persistents.
  - `/tmp`: directori temporal.

## `WORKDIR` {.smaller}

- La instrucci√≥ `WORKDIR` al Dockerfile estableix el directori de treball per a qualsevol comanda seg√ºent (`RUN`, `CMD`, `ENTRYPOINT`, `COPY`, `ADD`).
- Si el directori no existeix, Docker el crear√† autom√†ticament.
- Per exemple:
  
```dockerfile
FROM python:3.9
WORKDIR /app
COPY hola.py .
CMD python hola.py
```

## Exericici 3: Compartint dades de sortida (soluci√≥)

Primer, crearem un script `hola2.py` que escriu un fitxer de sortida:  
```python
output = open("sortida.txt", "w")
output.write("Hola m√≥n!")
output.close()
```

Despr√©s, executarem el contenidor Docker amb l'opci√≥ `-v` per compartir el directori actual del sistema host amb el directori `/app` del contenidor:

```bash
docker run -v $(pwd):/app python:3.9 python /app/hola2.py
```

## Taula de comandes √∫tils de Docker {.smaller}

| Comanda                        | Descripci√≥                                      |
|-------------------------------|------------------------------------------------|
| `docker build -t <nom> .`     | Construir una imatge des del Dockerfile actual.  |
| `docker run <imatge>`         | Executar un contenidor des d'una imatge.      |
| `docker run -it <imatge> bash` | Executar un contenidor en mode interactiu amb una shell. |
| `docker ps`                    | Llistar els contenidors en execuci√≥.           |  
| `docker stop <contenidor>`    | Aturar un contenidor en execuci√≥.              |
| `docker rm <contenidor>`      | Eliminar un contenidor aturat.                     |
| `docker rmi <imatge>`         | Eliminar una imatge.                           |
| `docker images`               | Llistar les imatges disponibles.                |
| `docker logs <contenidor>`    | Veure els logs d'un contenidor.                |
| `docker inspect <imatge/contenidor>` | Veure els detalls d'una imatge o contenidor.   |



## Xarxes i Contenidors

Imagineu que tenim un servidor web molt simple:

```python
python -m http.server <port>
```

Si executem aquesta comanda exposarem els fitxers a una interf√≠cie de xarxa del host.

![](../figs/slides/04-virt/python-webserver.png)


## Contenidor amb servidor web

1. Creem un Dockerfile per al servidor web:

:::{.fragment}
```dockerfile
FROM python
CMD ["python", "-m", "http.server", "8080"]
```
:::

2. Constru√Øm la imatge i executem el contenidor:

:::{.fragment}
```bash
docker build . -t amsa
docker run AMSA
Serving HTTP on 0.0.0.0 port 8080 (http://0.0.0.0:8080/) ...
```
:::

:::{.center-container .fragment}
Si accedim a `http://localhost:8080` des del host, no veurem res!
:::


## Per qu√® no funciona?

- Els contenidors per defecte estan a√Øllats.
- A part del seu sistema de fitxers propri, tamb√© tenen la seva pr√≤pia pila de xarxa.
- El port 8080 del contenidor no √©s el port 8080 de la m√†quina host.

## Mapeig de ports

- Per accedir als serveis d‚Äôun contenidor des del host, cal fer un **mapeig de ports**.
- Utilitzem l‚Äôopci√≥ `-p` de `docker run` per mapar un port del host a un port del contenidor:

:::{.fragment}
```bash
docker run -p 8085:8080 amsa
Serving HTTP on 0.0.0.0 port 8080 (http://0.0.0.0:8080/) ...
```
:::

- La sintaxi √©s `-p <port_host>:<port_contenidor>`, on ara podem accedir al servidor web a `http://localhost:8085`.

## Multistage Builds (I) {.smaller}

En els exemples anteriors, hem vist que el Dockerfile per a l‚Äôaplicaci√≥ Python √©s aix√≠:

```Dockerfile
FROM python
COPY requirements.txt requirements.txt
RUN pip install -r requirements.txt
COPY . .
CMD python main.py
```

::: {.fragment .center-container}
estem fent servir tota la imatge de Python per construir i executar...
:::

- Paquets de compilaci√≥ innecessaris
- Fitxers temporals deixats per pip
- Llibreries que nom√©s fan falta durant la instal¬∑laci√≥

::: {.fragment .center-container}
... una imatge final molt m√©s gran del necessari!!!
:::

## Multistage Builds (II) {.smaller}

La idea de les multistage builds √©s utilitzar diverses etapes de construcci√≥ dins del mateix Dockerfile. Separam la fase de construcci√≥ de la fase d‚Äôexecuci√≥.

::: columns
::: {.column width="50%"}

:::{.fragment}
```Dockerfile
FROM python AS builder
WORKDIR /app

COPY requirements.txt .
RUN pip install --prefix=/install \
  -r requirements.txt
```
:::

- instal¬∑la depend√®ncies a /install
- python complet, amb pip
- pot incloure eines de compilaci√≥ si calguessin

::: {.center-container .fragment}
üëâ Per√≤ res d‚Äôaix√≤ formar√† part de la imatge final.
:::

:::
::: {.column width="50%"}

:::{.fragment}

```Dockerfile
FROM python:slim
WORKDIR /app

COPY --from=builder /install /usr/local
COPY . .

CMD ["python", "main.py"]
```

:::

- utilitza una imatge slim (molt m√©s petita)
- nom√©s copia les depend√®ncies instal¬∑lades i el codi font
- no inclou pip, ni temporals, ni eines de build

::: {.center-container .fragment}
üëâ Imatge m√©s petita, lleugera i √≤pitma
:::

:::
:::

## Multistage Builds (III) {.smaller}

::: columns
::: {.column width="50%"}

### Sense multistage builds

- Python complet
- Pip + eines de build
- Fitxers temporals
- .pyc, caches...

::: {.center-container .fragment}
$$\geq ~400MB$$
:::

:::
::: {.column width="50%"}

### Amb multistage builds

- Python slim
- Nom√©s depend√®ncies finals
- Cap fitxer temporal

::: {.center-container .fragment}
$$\leq ~150MB$$
:::

:::
:::

:::{.center-container .fragment}
Obtenim el mateix servei, per√≤ amb imatges molt m√©s petites i √≤ptimes!
:::

## Multistage Builds (IV) {.smaller}

- Menys espai al disc ‚Üí ideal per CI/CD i servidors amb recursos limitats
- Menys temps de build i push/pull
- Menys superf√≠cie d‚Äôatac ‚Üí menys eines instal¬∑lades
- M√©s efici√®ncia a AWS Lambda, EC2, Kubernetes
- Imatges m√©s professionals i **production-ready**

## Exercici: Multistage Build {.smaller}

1. Utilitzeu el Dockerfile original i constru√Øu la imatge.
2. Utilitzeu el Dockerfile amb multistage build i constru√Øu la imatge.
3. Compareu la mida de les dues imatges amb `docker images` i amb `docker image ls`.
4. Executeu `docker run -it <amb/sense>-multistage bash` per explorar el sistema de fitxers de cada imatge i veure les difer√®ncies.

::: {.center-container .fragment}
Quins fitxers i eines addicionals hi ha a la imatge sense multistage build que no estan a la imatge amb multistage build? Quines s√≥n les difer√®ncies principals?
:::

## Preguntes de revisi√≥ {.smaller}

- Com podem assegurar-nos que fitxers i carpetes espec√≠fiques no es copi√Øn al contenidor?
- Quina √©s la difer√®ncia entre `COPY` i `ADD` en un Dockerfile?
- Quin √©s el prop√≤sit de la instrucci√≥ `CMD`, i per qu√® no crea una capa?
- Quina √©s la difer√®ncia entre `RUN` i `CMD` en un Dockerfile?
- Quina √©s la difer√®ncia entre `ENTRYPOINT` i `CMD` en un Dockerfile?
- Qu√® significa l'opci√≥ `-p 8085:8080` en `docker run`?
- Per qu√® no es pot accedir al servidor web d‚Äôun contenidor a `localhost:8080` tret que es mapi un port?

## Preguntes d'ampliaci√≥ {.smaller}

- Quins perills pot comportar fer `docker run -v /:/host alpine`?
- Per qu√® es considera perill√≥s executar `docker run --network host`?
- Quins riscos de seguretat reals existeixen si un contenidor executa processos que fan √∫s de ptrace o inspecci√≥ de processos del sistema?
- Com funcionaria el desplegament d‚Äôun contenidor creat en un host ARM en un host x86 sense suport multi-arch?
- Explica en detall qu√® passa internament quan un contenidor rep un SIGTERM i despr√©s un SIGKILL en una execuci√≥ de Docker.
- Investigueu les difer√®ncies entre `python:slim`, `python:alpine` i `python:full`. Quins avantatges i desavantatges t√© cadascuna per a diferents casos d'√∫s?


## Exercicis

- [Exercicis de Contenidors Docker](../exercises/05-virtualitzation/01-docker.qmd)
