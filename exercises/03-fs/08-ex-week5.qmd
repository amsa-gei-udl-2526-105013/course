---
title: "Migració de directoris a particions diferents"
lang: ca
---

## Objectius

- Crear particions i sistemes de fitxers (**ext4, xfs**).
- Migrar directoris reals a particions separades amb coherència i sense pèrdua de dades.
- Configurar el muntatge automàtic amb UUID i opcions de seguretat (*nodev, nosuid, noexec*).
- Diagnosticar i recuperar problemes reals: saturació d'espai i corrupció de sistema de fitxers.
- **Eines**: `fdisk`, `mkfs.*`, `tune2fs`, `mount`, `rsync`, `xfs_repair`, `hexedit`.

## Requeriments previs

- Tenir una màquina virtual (MV) amb Debian instal·lat.
- Crear un disc dur virtual addicional de 10GB del tipus SATA o NVMe.
- Instal·lar els paquets `xfsprogs`, `rsync`, `hexedit` i `build-essential`:
  
  ```bash
  apt update -y && apt install xfsprogs rsync hexedit build-essential -y
  ```
- Totes les comandes s'han d'executar amb permisos de superusuari (`root`). Per tant, `su -`.
- Compte amb el nom del disc dur addicional, en aquest cas `/dev/nvme0n2`, però pot variar en funció de la configuració de la màquina virtual, utilitza la comanda `lsblk` per a identificar el disc dur addicional. Utilitza el nom correcte actualitzant-lo en les comandes que apareixen en aquest exercici.


## Particions i Sistemes de Fitxers

### Crear Particions i Sistemes de Fitxers

Assegurarem que el disc dur addicional està detectat pel sistema. En aquest cas, el disc dur és `/dev/nvme0n2`, però pot variar en funció de la configuració de la màquina virtual, utilitza la comanda `lsblk` per a identificar el disc dur addicional.

Utilitzarem la comanda `fdisk` per a crear tres noves particions en el disc dur.

- La primera partició serà per a `/var` amb el sistema de fitxers `ext4`, etiqueta `var` mida 4GB.
- La segona partició serà per a `/tmp` amb el sistema de fitxers `xfs`,  sense etiqueta i mida 2GB.
- La tercera partició serà per a `/opt` amb el sistema de fitxers `ext4`, etiqueta `opt` mida 3GB.
- La quarta partició serà `/home` amb el sistema de fitxers `ext4`, etiqueta `home` i la resta d'espai disponible (1GB).

Crearem les noves particions en el disc dur. Podeu utilzar una pipeline per a automatitzar la creació de les particions.

```bash
echo -e "n\np\n\n\n+4G\nn\np\n\n\n+2G\nn\np\n\n\n+3G\nn\np\n\n\n+1G\nw" | fdisk /dev/nvme0n2
```

El següent pas és crear els sistemes de fitxers en les particions que acabem de crear i assignar les etiquetes corresponents.

```bash
mkfs.ext4 /dev/nvme0n2p1
tune2fs -L "var" /dev/nvme0n2p1
mkfs.xfs /dev/nvme0n2p2
mkfs.ext4 /dev/nvme0n2p3
tune2fs -L "opt" /dev/nvme0n2p3
mkfs.xfs /dev/nvme0n2p4
tune2fs -L "home" /dev/nvme0n2p4
 ```

Monteu les particions en directoris temporals per a migrar les dades, per a això, creeu els directoris `/mnt/var`, `/mnt/tmp` , `/mnt/opt` i `/mnt/home`.

```bash
mkdir /mnt/var /mnt/tmp /mnt/opt /mnt/home
mount /dev/nvme0n2p1 /mnt/var
mount /dev/nvme0n2p3 /mnt/opt
mount /dev/nvme0n2p4 /mnt/home
```

::: {.callout-note title="/tmp"}
La partició `/tmp` és temporal i no conté dades importants, per tant, no la muntarem en aquest pas, ja que no necessitem migrar cap dada. Les seves dades es perdran en el reinici del sistema.
:::

### Migrar Directoris a les Noves Particions

Abans de migrar les dades, és important assegurar-se que no hi ha processos que estiguin utilitzant els directoris que volem migrar. Per a això, podem utilitzar la comanda `lsof` per a llistar els fitxers oberts en aquests directoris.

```bash
lsof +D /var
lsof +D /opt
lsof +D /home
```

::: {.callout-note title="Fitxers oberts"}
Si hi ha processos que estan utilitzant els directoris que volem migrar, és recomanable aturar aquests processos abans de continuar amb la migració. Això és especialment important per al directori `/var`, ja que conté fitxers de registre i altres dades que poden ser utilitzades per diversos serveis del sistema.
:::

Hi ha moltes comandes per a migrar dades entre directoris, però en aquest cas utilitzarem la comanda `rsync` ja que ens permet mostrar el progrés de la còpia i també ens permet reprendre la còpia en cas que es talli la connexió o hi hagi un error. A més, també ens permet excloure directoris o fitxers que no volem migrar i ens permet fer còpies incrementals.

```bash
rsync -av /var/ /mnt/var
rsync -av /opt/ /mnt/opt
rsync -av /home/ /mnt/home
```

:::{.callout-note title="rsync"}
`rsync` és una eina molt potent per a la sincronització de fitxers i directoris. En aquest cas, utilitzem les opcions `-a` (mode arxiu) i `-v` (verbose) per a conservar els permisos, propietaris, marques de temps i per a mostrar el progrés de la còpia. La barra inclinada (`/`) al final dels directoris d'origen és important perquè indica a `rsync` que només volem copiar el contingut del directori i no el directori en si mateix. Si no posem la barra inclinada, `rsync` crearà un subdirectori amb el mateix nom que el directori d'origen dins del directori de destinació. Per a més informació sobre `rsync`, podeu consultar la documentació (`man rsync`).
:::

Un cop copiem les dades, és important verificar que les dades s'han copiat correctament. Per a això, podem utilitzar la comanda `diff` per a comparar els directoris d'origen i destinació.

```bash
diff -r /var /mnt/var
diff -r /opt /mnt/opt
diff -r /home /mnt/home
```

Si la comanda `diff` no mostra cap sortida, significa que els directoris són idèntics i que les dades s'han copiat correctament. Si hi ha diferències, la comanda `diff` mostrarà les línies que són diferents entre els dos directoris.

Muntarem les noves particions en els directoris corresponents.

```bash
mount /dev/nvme0n2p1 /var
mount /dev/nvme0n2p3 /opt
mount /dev/nvme0n2p4 /home
```

Utiltiza la comanda `df` per a comprovar que les particions s'han muntat correctament o `lsblk` per a veure totes les particions i els seus punts de muntatge.

### Configurar el Muntatge Automàtic

Si ara reinicieu el sistema `reboot`, les particions no estaran muntades automàticament. Per a que les particions es muntin automàticament en l'arrencada del sistema, hem d'editar el fitxer `/etc/fstab` i afegir les noves particions amb els seus punts de muntatge corresponents.

```bash
echo "/dev/nvme0n2p1 /var ext4 defaults 0 0" >> /etc/fstab
echo "/dev/nvme0n2p2 /tmp xfs defaults 0 0" >> /etc/fstab
echo "/dev/nvme0n2p3 /opt ext4 defaults 0 0" >> /etc/fstab
echo "/dev/nvme0n2p4 /home xfs defaults 0 0" >> /etc/fstab
```

:::{.callout-note title="`/etc/fstab`"}
El fitxer `/etc/fstab` conté la informació de les particions que es muntaran automàticament en l'arrencada del sistema. Cada línia del fitxer conté la informació d'una partició. Els camps de cada línia són: dispositiu, punt de muntatge, sistema de fitxers, opcions, freqüència de comprovació i ordre de comprovació. Podeu consultar la documentació del fitxer per a més informació (`man fstab`).
:::

Pots provar la configuració del fitxer `/etc/fstab` sense reiniciar el sistema amb la comanda `mount -a`. Aquesta comanda muntarà totes les particions que estan definides en el fitxer `/etc/fstab`. També podem fer un `reboot` per a comprovar que les particions es muntin automàticament en l'arrencada del sistema, sempre hi quan la comanda `mount -a` no hagi donat cap error.

En aquest punt podriam optimitzar la configuració particions per a millorar el rendiment del sistema. 

1. Utiltizarem els UUIDs en lloc dels dispositius per a muntar les particions. Això ens permetrà identificar les particions de forma unívoca i evitar problemes en cas que els dispositius canviïn d'identificador. Per fer-ho podem utilitzar la comanda `sed` per actualitzar el fitxer `/etc/fstab`.

    ```bash
    sed -i "s|/dev/nvme0n2p1|UUID=$(blkid -s UUID -o value /dev/nvme0n2p1)|" /etc/fstab
    sed -i "s|/dev/nvme0n2p2|UUID=$(blkid -s UUID -o value /dev/nvme0n2p2)|" /etc/fstab
    sed -i "s|/dev/nvme0n2p3|UUID=$(blkid -s UUID -o value /dev/nvme0n2p3)|" /etc/fstab
    sed -i "s|/dev/nvme0n2p4|UUID=$(blkid -s UUID -o value /dev/nvme0n2p4)|" /etc/fstab
    ```

    > 🔍  **Pregunta**: *En quins casos poden canviar els dispositius o tenir duplicats?*
    >
    > Els dispositius poden canviar d'identificador en cas que es connectin més dispositius al sistema o es canvii l'ordre de connexió dels dispositius. Això pot provocar que les particions es muntin en llocs diferents dels esperats. Per a evitar aquest problema, és recomanable utilitzar els UUIDs en lloc dels dispositius per a muntar les particions.

2. Utilitzarem opcions més específiques per protegir la partició `/tmp` per a evitar que s’executin programes des de la partició. Utilitzant les opcions **nodev**, **nosuid**, i **noexec**:
  
    - Edita el fitxer `/etc/fstab` i afegeix les opcions `nodev`, `nosuid`, i `noexec` a la partició `/tmp`.

:::{.callout-note title="Opcions de Muntatge"}
La opció `defaults` és una col·lecció d'opcions que s'utilitzen per defecte en la majoria de sistemes de fitxers. Aquestes opcions inclouen `rw` (lectura i escriptura), `suid` (permet l'ús de l'atribut suid), és a dir, evita que es puguin exectuar programaes amb permisos de superusuari, `dev` (permet l'ús de dispositius), `exec` (permet l'execució de fitxers binaris), `auto` (muntatge automàtic en l'arrencada del sistema), `nouser` (només l'usuari root pot muntar la partició) i `async` (permet l'escriptura asíncrona).
:::

    - Comprova les opcions després d'editar el fitxer `/etc/fstab`.

        ```bash
        mount | grep /tmp
        ```
    - Per aplicar les opcions de muntatge a la partició `/tmp`, farem un `reboot` del sistema.
  
    - Testem les opcions de muntatge de la partició `/tmp`:
  
        1. Prova d'executar un programa des de la partició `/tmp` com a usuari no privilegiat.

            ```bash
            echo "echo 'Hello, World'" > /tmp/hello.sh
            chmod +x /tmp/hello.sh
            /tmp/hello.sh
            bash /tmp/hello.sh
             ```

        2. Prova de fer el mateix com a usuari privilegiat.

            ```bash
            su -
            /tmp/hello.sh
            bash /tmp/hello.sh
            ```

            > 👁️ **Observació**:
            >
            > Observeu que la opció `noexec` impedeix la execució dels binaris però no ens protegeix contra l'execució de scripts de bash.

        3. Prova d'accedir a un dispositiu creat a `/tmp`:

            - Inicialitza un dispositiu a `/tmp` utilitzant la comanda `mknod`.

                ```bash
                mknod /tmp/dispositiu c 1 3
                ```

                > ⚠️ **Compte**:
                >
                > La comanda `mknod` única i exclusivament la poden fer els usuaris amb permisos de superusuari. Per tant, feu servir la comanda `su` per a canviar a l'usuari `root` abans de fer servir la comanda `mknod`.

            - Per accedir al dispositiu, utilitza la comanda `cat`.

                ```bash
                cat /tmp/dispositiu
                ```

            > 👁️ **Observació**:
            >
            > Fixeu-vos que quan intento accedir a un dispositiu al directori actual, no hi ha cap problema. Però quan intento accedir al dispositiu creat a `/tmp`, rebre un missatge d'error indicant que no es pot accedir al dispositiu. Això és degut a la opció `nodev` que impedeix l'accés a dispositius en la partició.

        4. Per veure, les implicacions de la opció `nosuid`, podem realitzar el següent experiment:

            Per fer-ho, crearem un executable amb c que ens indicarà l'identificador de l'usuari real i l'identificador de l'usuari efectiu. On l'usuari real és l'usuari que ha iniciat la sessió i l'usuari efectiu és l'usuari que executa el programa. Si un programa té el bit `suid` activat, l'usuari efectiu serà l'usuari propietari del programa i no l'usuari que l'ha executat.

            ```c
            #include <stdio.h>
            #include <sys/types.h>
            #include <unistd.h>

            int main() {
                printf("Effective user ID: %d\n", geteuid());
                printf("Real user ID: %d\n", getuid());
                return 0;
            }
            ```

            Compilem el programa amb la comanda `gcc`.

            ```bash
            gcc -o /tmp/suid /tmp/suid.c
            ```

            - Desactiva la opció `nosuid` i també la opció `noexec` per a la partició `/tmp`. Per fer-ho, utilitza l'usuari `root` per a editar el fitxer `/etc/fstab`.

            - Remunta la partició `/tmp`.

            - Prova d'executar el programa com a usuari no privilegiat.

                ```bash
                /tmp/suid
                ```

            - Activa la opció `nosuid` i torna a provar d'executar el programa.

                ```bash
                /tmp/suid
                ```


            > 👁️ **Observació**:
            >
            > Fixeu-vos que quan la opció `nosuid` està activada, no es pot executar el programa amb permisos de superusuari. Això és important per a evitar que els usuaris no privilegiats puguin executar programes amb permisos de superusuari. Aquesta opció pot permetre escalar privilegis i comprometre la seguretat del sistema.

> 🔍  **Pregunta**: *Per què és important tenir els directoris `/var`, `/tmp` i `/opt` en particions diferents?*
>
> La raó principal per a tenir els directoris `/var`, `/tmp` i `/opt` en particions diferents és per a millorar el rendiment i la seguretat del sistema. El directori `/var` conté dades variables com ara logs, bases de dades, correu electrònic, etc. Si aquest directori es queda sense espai, el sistema podria fallar. El mateix raonament s'aplica al directori `/tmp` i `/opt`. Per això, és important tenir-los en particions separades per a evitar que el sistema falli. A més, tenir els directoris `/var`, `/tmp` i `/opt` en particions separades també millora la seguretat del sistema ja que si una partició falla, les altres particions seguiran funcionant.

Anem a fer una simulació de com respon el sistema en cas de no tenir els directoris `/var`, `/tmp` i `/opt` en particions separades. Per a això, simularem que el directori `/opt` es va omplint fins a ocupar tot l'espai disponible en la partició principal del sistema.

1. Desmuntem la partició `/opt` per a poder continuar amb l'exercici.

    ```bash
    umount /opt
    ```

2. Creeu un fitxer de 20GB al directori `/opt`:

    ```bash
    dd if=/dev/urandom of=/opt/fitxer bs=1M count=20480
    ```

3. Comprova l'estat del sistema.

    ```bash
    df -h
    ```

    ![Comprova l'estat del sistema](../../figs/exercises/fs-01/df-omplert.png)

4. Intenta instal·lar un paquet amb `apt` i comprova que el sistema falla.

    ```bash
    apt install htop
    ```

    ![Intenta instal·lar un paquet amb `apt` i comprova que el sistema falla](../../figs/exercises/fs-01/apt-fallit.png)

    Com podeu veure, el sistema fallarà ja que no té espai suficient per a instal·lar el paquet. Això és un problema greu ja que el sistema no podrà funcionar correctament fins que no alliberem espai en la partició principal.

5. Elimina el fitxer que has creat per a poder continuar amb la resta de l'exercici.

    ```bash
    rm /opt/fitxer
    ```

6. Munteu la partició `/opt` i torneu a crear el fitxer per a omplir el directori.

    ```bash
    mount /dev/nvme0n2p3 /opt
    dd if=/dev/urandom of=/opt/fitxer bs=1M count=20480
    ```

7. Ara únicament teniu la partició `/opt` plena; però el sistema pot continuar fent tasques:

    ```bash
    apt install htop
    ```

## Simulant una corrupció a `/home`

En aquest escenari simularem que hem patit una corrupció a la partició `/home` i quines eines podem utiltzar per intentar recuperar les dades. Bàsicament editarem alguns bits de la partició `/home` amb un editor hexadecimal per a simular la corrupció i després utilitzarem l'eina `xfs_repair` per a intentar recuperar les dades.

El primer pas que farem serà migrar el directori `/home` a una partició diferent per a poder simular la corrupció. A continuació, simularem la corrupció i finalment recuperarem les dades.

Ara podem crear fitxers i directoris al directori `/home` del vostre usuari normal, en el meu cas `jordi`.

```bash
mkdir codi
mkdir dades
touch dades/pokemon.csv
touch codi/main.c
touch codi/Makefile
touch codi/README.md
touch .vim
```

Per a simular una corrupció editarem alguns valors de la partició `/home` amb un editor hexadecimal.

1. Desmuntem la partició `/home`.

    ```bash
    umount /home
    ```

    > **Compte!**: Si esteu connectats per SSH, no podreu desmuntar la partició `/home` ja que el vostre usuari està utilitzant aquesta partició. En la primera sessió. Per tant, haure de fer-ho a la consola de la màquina virtual.

2. Obrirem la partició `/home` amb un editor hexadecimal:
   
```bash
hexedit /dev/nvme0n2p4 
```

3. Modifiqueu bits a l'atzar i deseu els canvis. Per fer-ho escriviu damunt dels valors hexadecimals altres valors. Un cop fet guardeu amb **Ctrl + X i Y**.


4. Ara intentarem muntar la partició `/home` per a comprovar que ha estat corrompuda.

```bash
mount /home
```

    Si la partició `/home` s'ha corromput, hauríeu de veure un missatge d'error com aquest:

    ![home_corrupte](../../figs/exercises/fs-01/home_corrupte.png)

5. Els diferents sistemes de fitxers tenen eines per a comprovar la integritat dels fitxers. Per exemple, el sistema de fitxers `xfs` té l'eina `xfs_ncheck` que permet comprovar la integritat dels fitxers.

    ```bash
    xfs_ncheck /dev/nvme0n2p4
    ```

6. Per a reparar la partició `/home` utilitzarem l'eina `xfs_repair`.

    ```bash
    xfs_repair /dev/nvme0n2p4
    ```

7. Un cop reparada la partició `/home`, la muntarem de nou.

    ```bash
    mount /home
    ```

8. Comprovarem que la partició `/home` s'ha muntat correctament i conté els fitxers que havíem creat.

    ```bash
    ls /home
    ```
